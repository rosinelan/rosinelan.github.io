<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>持续不断</title>
  
  <subtitle>要松懈的时候再坚持一下</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rosinelan.github.io/"/>
  <updated>2018-11-15T01:00:17.527Z</updated>
  <id>https://rosinelan.github.io/</id>
  
  <author>
    <name>小灰灰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git安装和使用</title>
    <link href="https://rosinelan.github.io/2018/11/14/git%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://rosinelan.github.io/2018/11/14/git安装和使用/</id>
    <published>2018-11-14T08:52:28.000Z</published>
    <updated>2018-11-15T01:00:17.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h2><p>centos 7安装git很简单，直接使用<code>yum install -y git</code>即可。<br>安装完成之后配置信息<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "rosinelan"</span><br><span class="line">git config --global user.email "mqwanghui327@hotmail.com"</span><br></pre></td></tr></table></figure></p><a id="more"></a>   <p><code>global</code>表示全局配置，所有该机器每次提交的文件默认为该用户。</p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>安装完成之后创建版本库。  </p><ol><li><p>创建一个目录用于存放文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /studypy</span><br><span class="line">cd /studypy</span><br></pre></td></tr></table></figure></li><li><p>使用<code>git init</code>命令将该目录变成git可管理的仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li></ol><p>出现提示信息<code>Initialized empty Git repository in /studypy/.git/</code>说明成功初始化。<br>此时该目录下会新增一个<code>.git</code>目录，该目录是git用来跟踪管理版本库的，不可手动修改。</p><ol><li>将文件添加到版本库。<br>新建一个名字为<code>1.py</code>的文件，内容如下<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line">num1 = input(<span class="string">"Please a number:"</span>)</span><br><span class="line">num2 = input(<span class="string">"Please a number:"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s + %s = %s"</span> %(num1,num2,num1+num2)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s - %s = %s"</span> %(num1,num2,num1-num2)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s * %s = %s"</span> %(num1,num2,num1*num2)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s / %s = %s"</span> %(num1,num2,num1/num2)</span><br></pre></td></tr></table></figure></li></ol><p>该文件一定要位于<code>/studypy</code>目录下面，然后执行下面命令。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add 1.py</span><br><span class="line">git commit -m "wtote a python file"</span><br></pre></td></tr></table></figure></p><p>出现提示信息<code>[master (root-commit) 1cb292d] wtote a python file 1 file changed, 10 insertions(+) create mode 100644 1.py</code>。<br><code>git add</code>为添加文件至仓库，可多次添加；<code>git commit</code>为提交文件至仓库，一次可提交多个文件，<code>-m</code>命令为添加提交文件的说明信息。  </p><h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><h3 id="github配置ssh连接"><a href="#github配置ssh连接" class="headerlink" title="github配置ssh连接"></a>github配置ssh连接</h3><p>注册github账号，然后配置机器和github的ssh，用于文件传输。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "mqwanghui327@hotmail.com"</span><br></pre></td></tr></table></figure></p><p>创建完成之后可以在<code>/root/.ssh/</code>目录查看公钥文件<code>id_rsa.pub</code>。<br>登录github，点击右上角头像，选择<code>Settings</code>，然后选择<code>SSH and GPG keys</code>。<br><img src="http://cdn.rosinelan.com/blog/system/git-ssh-Setting.png" alt="gti-ssh-Setting" title="git-ssh-Setting"><br>点击<code>New SSH key</code>，添加对应的公钥。<br><img src="http://cdn.rosinelan.com/blog/system/git-Newsshkey.png" alt="git-Newsshkey" title="git-Newsshkey"><br>添加之后使用下面命令测试公钥添加是否成功。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>若出现下面的提示信息说明添加正确。<br><code>Hi rosinelan! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p><h3 id="github创建远程仓库"><a href="#github创建远程仓库" class="headerlink" title="github创建远程仓库"></a>github创建远程仓库</h3><p>接下来我们在github创建一个远程仓库，然后将远程仓库和本地仓库关联，最后将本地仓库的内容推送至远程仓库。</p><ol><li>创建远程仓库<br>在github创建新建仓库，通过右上角的<code>+</code>，选择<code>New repository</code>即可新建。<br><img src="http://cdn.rosinelan.com/blog/system/Create%20new%20repository.png" alt="Create new repository" title="Create new repository"><br>创建完成之后可以看到下面提示信息<br><img src="http://cdn.rosinelan.com/blog/system/new%20repository%20info.png" alt="new repository info" title="new repository info"></li><li>关联本地仓库<br>根据提示信息，在本地仓库<code>studypy</code>进行下面操作<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:rosinelan/studypy.git</span><br></pre></td></tr></table></figure></li></ol><p>上面操作需要在本地仓库<code>studypy</code>执行，注意切换到<code>/studypy</code>目录下。<br>此处<code>origin</code>是远程仓库的名字，git默认的叫法。  </p><ol><li>推送本地仓库至github远程仓库<br>执行下面命令将本地仓库内容推送至远程仓库。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li></ol><p>此时出现下面提示信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added the RSA host key <span class="keyword">for</span> IP address <span class="string">'52.74.223.119'</span> to the list of known hosts.</span><br><span class="line">Counting objects: <span class="number">3</span>, done.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">326</span> bytes | <span class="number">0</span> bytes/s, done.</span><br><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">remote: </span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">'master'</span> on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/rosinelan/studypy/pull/new/master</span><br><span class="line">remote: </span><br><span class="line">To git@github.com:rosinelan/studypy.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch master set up to track remote branch master <span class="keyword">from</span> origin.</span><br></pre></td></tr></table></figure></p><p>提示信息可以看出，当前推送的内容数量，还有就是推送是将本地的master分支推送至远程。<br>此处<code>git push</code>使用了参数<code>-u</code>，意思是将本地master分支推送至远程的新master分支，同时将两者关联起来，以后推送默认就是推送至master分支。第一次使用该参数，之后就不用添加参数。<br>例如：新建一个<code>README.md</code>，然后推送至远程仓库。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "studypy" &gt;&gt;README.md</span><br></pre></td></tr></table></figure></p><p>本地仓库提交<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add README.md</span><br><span class="line">git commit -m "wrote readme"</span><br></pre></td></tr></table></figure></p><p>提示信息如下说明本地提交成功。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[master ce31753] wrote readme</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 README.md</span><br></pre></td></tr></table></figure></p><p>推送至远程仓库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p>提示如下信息说明提交成功。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Counting objects: 4, done.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 280 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:rosinelan/studypy.git</span><br><span class="line">   1cb292d..ce31753  master -&gt; master</span><br></pre></td></tr></table></figure></p><p>注意：<br>假如不使用改参数将两者关联，之后的推送就需要使用下面命令进行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master:master</span><br></pre></td></tr></table></figure></p><p>命令格式为<code>git push 远程主机名 本地分支名：远程分支名</code>。  </p><h2 id="远程仓库克隆"><a href="#远程仓库克隆" class="headerlink" title="远程仓库克隆"></a>远程仓库克隆</h2><p>假如没有本地仓库，想要直接从github拉取文件怎么办呢？远程仓库克隆。<br>首先在github创建一个远程仓库。<br><img src="http://cdn.rosinelan.com/blog/system/git-origin-creat.png" alt="git-origin-creat" title="git-origin-creat"><br>勾选初始化<code>README.md</code>文件，此时远程仓库创建完成后可以看到该文件。<br>接下来使用<code>git clone</code>克隆本地库。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br><span class="line">git clone git@github.com:rosinelan/studypy2.git</span><br></pre></td></tr></table></figure></p><p>进入本地的目录<code>/study2</code>，可以看到<code>README.md</code>文件。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;git安装&quot;&gt;&lt;a href=&quot;#git安装&quot; class=&quot;headerlink&quot; title=&quot;git安装&quot;&gt;&lt;/a&gt;git安装&lt;/h2&gt;&lt;p&gt;centos 7安装git很简单，直接使用&lt;code&gt;yum install -y git&lt;/code&gt;即可。&lt;br&gt;安装完成之后配置信息&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.name &quot;rosinelan&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.email &quot;mqwanghui327@hotmail.com&quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="系统管理" scheme="https://rosinelan.github.io/categories/system/"/>
    
      <category term="python实战" scheme="https://rosinelan.github.io/categories/system/python%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="master" scheme="https://rosinelan.github.io/tags/master/"/>
    
      <category term="git" scheme="https://rosinelan.github.io/tags/git/"/>
    
      <category term="仓库" scheme="https://rosinelan.github.io/tags/%E4%BB%93%E5%BA%93/"/>
    
      <category term="origin" scheme="https://rosinelan.github.io/tags/origin/"/>
    
  </entry>
  
  <entry>
    <title>variable of python</title>
    <link href="https://rosinelan.github.io/2018/11/14/variable-of-python/"/>
    <id>https://rosinelan.github.io/2018/11/14/variable-of-python/</id>
    <published>2018-11-14T08:51:45.000Z</published>
    <updated>2018-11-14T10:24:48.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python配置"><a href="#python配置" class="headerlink" title="python配置"></a>python配置</h2><p>默认python的编辑器并不提供补全功能，建议安装<code>ipython</code>。ipython可以通过python提供的包管理工具<code>pip</code>安装和管理。<br>具体步骤为  </p><ol><li>安装扩展源epel  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a>   <ol><li><p>安装pip  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y python-pip</span><br></pre></td></tr></table></figure></li><li><p>安装ipython</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ipython==<span class="number">5.3</span><span class="number">.0</span></span><br></pre></td></tr></table></figure></li></ol><p>安装ipython的时候需要注意对应版本适配问题，例如：最新版本的ipython不适用于python2.6。  </p><h3 id="pip代理设置"><a href="#pip代理设置" class="headerlink" title="pip代理设置"></a>pip代理设置</h3><p>假如机器通过代理方式上网，可以通过设置全局代理或者添加参数方式处理。  </p><h4 id="全局代理设置"><a href="#全局代理设置" class="headerlink" title="全局代理设置"></a>全局代理设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /root/.bash_profile</span><br><span class="line">export http_proxy=<span class="string">"http://xxxx:8888"</span></span><br><span class="line">export https_proxy=<span class="string">"https://xxxx:8888"</span></span><br></pre></td></tr></table></figure><p>然后<code>source /root/.bash_profile</code>使之生效。</p><h4 id="pip添加参数"><a href="#pip添加参数" class="headerlink" title="pip添加参数"></a>pip添加参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --proxy http://xxxx:<span class="number">8888</span> ipython</span><br></pre></td></tr></table></figure><h2 id="python文件类型"><a href="#python文件类型" class="headerlink" title="python文件类型"></a>python文件类型</h2><p>文件类型有3种，分别为源代码、字节代码和优化代码。  </p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p>以<code>py</code>作为扩展名，由python程序解释，不需要编译。</p><h3 id="字节代码"><a href="#字节代码" class="headerlink" title="字节代码"></a>字节代码</h3><p>源码文件编译之后生成的扩展名为<code>pyc</code>的文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> py_compile</span><br><span class="line">py_compile.compile(‘<span class="number">1.</span>py’)</span><br></pre></td></tr></table></figure></p><h3 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h3><p>经过优化的源码文件，扩展名为<code>pyo</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -O -m py_compile <span class="number">1.</span>py</span><br></pre></td></tr></table></figure></p><p>字节代码和优化代码都可在无源码情况下直接执行；编译和优化之后的代码非文本文件，无法看到源码。  </p><h2 id="python变量"><a href="#python变量" class="headerlink" title="python变量"></a>python变量</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>变量是计算机内的一块区域，可以存储规定范围内的值，而且值可以改变。<br>python下变量是对一个数据的引用。<br>变量重新赋值时，会重新指向另一个地址。</p><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>变量名由字母、数字、下划线组成，不能以数字开头，不可以使用关键字。  </p><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>赋值时变量的声明和定义的过程。<br><code>a = 1</code><br><code>id(a)</code> 内置函数，查看变量a的内存地址。<br><code>type(a)</code> 查看变量a的类型。</p><h3 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h3><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=</span><br><span class="line">+=</span><br><span class="line">-+</span><br><span class="line">*=</span><br><span class="line">/=</span><br><span class="line">%=</span><br></pre></td></tr></table></figure><h4 id="算符运算符"><a href="#算符运算符" class="headerlink" title="算符运算符"></a>算符运算符</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+</span><br><span class="line">-</span><br><span class="line">*</span><br><span class="line">/  除数和被除数均为整数时为整除，含有浮点数时结果含小数</span><br><span class="line">//  整除，只取整数部分</span><br><span class="line">%  取余</span><br><span class="line">**  指数运算(<span class="number">2</span>**<span class="number">3</span>==<span class="number">8</span>)</span><br></pre></td></tr></table></figure><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>返回结果为布尔值，<code>True</code>或者<code>False</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br><span class="line">&lt;</span><br><span class="line">&gt;=</span><br><span class="line">&lt;=</span><br><span class="line">==</span><br><span class="line">!=</span><br></pre></td></tr></table></figure></p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span>  逻辑与</span><br><span class="line"><span class="keyword">or</span>  逻辑或</span><br><span class="line"><span class="keyword">not</span>  逻辑非</span><br></pre></td></tr></table></figure><h4 id="优先级列表"><a href="#优先级列表" class="headerlink" title="优先级列表"></a>优先级列表</h4><p>从上向下优先级越高，从左向右优先级越高<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Lambda</span><br><span class="line">逻辑运算：<span class="keyword">or</span></span><br><span class="line">逻辑运算：<span class="keyword">and</span></span><br><span class="line">逻辑运算：<span class="keyword">not</span></span><br><span class="line">成员测试：<span class="keyword">in</span>，<span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">同一性测试：<span class="keyword">is</span>，<span class="keyword">is</span> <span class="keyword">not</span></span><br><span class="line">比较：&lt;，&lt;=，&gt;，&gt;=，!=，==</span><br><span class="line">按位或：|</span><br><span class="line">按位异或：^</span><br><span class="line">按位与：&amp;</span><br><span class="line">移位：&lt;&lt;，&gt;&gt;</span><br><span class="line">加法和减法：+，-</span><br><span class="line">乘法、除法与取余：*，/，%</span><br><span class="line">正负号：+x，-x</span><br><span class="line">按位翻转：~x</span><br><span class="line">指数：**</span><br></pre></td></tr></table></figure></p><p>表达式是将不同的数据用运算符按一定的规则连接起来。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>四则运算，从键盘读取输入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line">num1 = input(<span class="string">"Please a number:"</span>)</span><br><span class="line">num2 = input(<span class="string">"Please a number:"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s + %s = %s"</span> %(num1,num2,num1+num2)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s - %s = %s"</span> %(num1,num2,num1-num2)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s * %s = %s"</span> %(num1,num2,num1*num2)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"%s / %s = %s"</span> %(num1,num2,num1/num2)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;python配置&quot;&gt;&lt;a href=&quot;#python配置&quot; class=&quot;headerlink&quot; title=&quot;python配置&quot;&gt;&lt;/a&gt;python配置&lt;/h2&gt;&lt;p&gt;默认python的编辑器并不提供补全功能，建议安装&lt;code&gt;ipython&lt;/code&gt;。ipython可以通过python提供的包管理工具&lt;code&gt;pip&lt;/code&gt;安装和管理。&lt;br&gt;具体步骤为  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装扩展源epel  &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install -y epel-release&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="系统管理" scheme="https://rosinelan.github.io/categories/system/"/>
    
      <category term="python实战" scheme="https://rosinelan.github.io/categories/system/python%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="pip" scheme="https://rosinelan.github.io/tags/pip/"/>
    
      <category term="变量" scheme="https://rosinelan.github.io/tags/%E5%8F%98%E9%87%8F/"/>
    
      <category term="文件类型" scheme="https://rosinelan.github.io/tags/%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="运算符" scheme="https://rosinelan.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>install of python</title>
    <link href="https://rosinelan.github.io/2018/11/14/install-of-python/"/>
    <id>https://rosinelan.github.io/2018/11/14/install-of-python/</id>
    <published>2018-11-14T08:51:28.000Z</published>
    <updated>2018-11-14T10:18:56.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python介绍"><a href="#python介绍" class="headerlink" title="python介绍"></a>python介绍</h2><p>python是荷兰人Guidovan Rossum于1989年发明的，第一个公开发行版本发行于1991年。<br>python的设计哲学是”优雅”、”明确”、”简单”，也因此python得以迅速的发展起来，得到大量用户的欢迎。<br>除了大家熟知的“脚本语言”作用之外，python还提供了很多与网络、GUI、图片、文件等相关的基础代码库和第三方库，这样很多功能可以不用从零开始，非常便捷。<br>根据<a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener">TIOBE</a>2018年3月发布的最新一期编程语言排行榜，python排名第4，仅位于Java/C/C++之后，可见python的流行程度。<br><a id="more"></a>   </p><h2 id="python版本"><a href="#python版本" class="headerlink" title="python版本"></a>python版本</h2><p>当前python主要使用版本有2种，分别是python2和python3，且python2.7在将来的2020年之后将失去后续支持。<br>包括centos7版本系统默认安装的python依然是2.7版本，且大多数公司依然在使用python2。<br>学习以python3为主，使用最新的语法和类库，同时掌握python2和python3的主要区别，保证代码在2个版本的兼容性。   </p><h2 id="python安装"><a href="#python安装" class="headerlink" title="python安装"></a>python安装</h2><p>以最新的python3.6为基础进行安装。   </p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>linux系统下载源码编译安装，windows系统下载可执行文件运行安装。<br><a href="https://www.python.org" target="_blank" rel="noopener">点击</a>进入python官方网站<br>选择Downloads –&gt; All releases<br><img src="http://cdn.rosinelan.com/blog/program/python-dowload.png" alt="python-Download" title="python-Download"><br>点击<code>Download Python 3.64</code><br><img src="http://cdn.rosinelan.com/blog/program/python-v364.png" alt="python-v364" title="python-v364"><br>在新的Python 3.6.4页面下拉至Files部分<br><img src="http://cdn.rosinelan.com/blog/program/python-install.png" alt="python-install" title="python-install"><br>其中linux系统使用 <code>Gzipped source tarball</code>,<a href="https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tgz" target="_blank" rel="noopener">点击下载</a></p><p>64位windows使用 <code>Windows x86-64 executable installer</code>,<a href="https://www.python.org/ftp/python/3.6.4/python-3.6.4-amd64.exe" target="_blank" rel="noopener">点击下载</a></p><p>32位windwos使用 <code>Windows x86 executable installer</code>,<a href="https://www.python.org/ftp/python/3.6.4/python-3.6.4.exe" target="_blank" rel="noopener">点击下载</a></p><h3 id="在linux上安装python"><a href="#在linux上安装python" class="headerlink" title="在linux上安装python"></a>在linux上安装python</h3><p>centos系统默认会安装python2.7,现在安装最新版本python3.6。<br>centos下使用源码编译安装，步骤如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf Python-3.6.4.tgz   </span><br><span class="line">cd Python-3.6.4   </span><br><span class="line">./configure --prefix=/usr/local/python364   </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>此时发现/usr/bin/python依然是原来的老版本,需要修改/usr/bin/python对应的链接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/bin/python /usr/bin/python_27</span><br><span class="line">ln -s /usr/local/python364/bin/python /usr/bin/python</span><br></pre></td></tr></table></figure></p><p>此时通过<code>python -v</code>命令可以看到版本为v3.6.4.<br>注意：采用此方法安装后会发现yum不可用，原因是yum使用依赖老版本python，此时需要修改<code>/usr/bin/yum</code>第一行为<code>#!/usr/bin/python_27</code>就可以了。</p><h3 id="在windows上安装python"><a href="#在windows上安装python" class="headerlink" title="在windows上安装python"></a>在windows上安装python</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>双击<code>python-3.6.4-amd64.exe</code>开始安装<br><img src="http://cdn.rosinelan.com/blog/program/python-win-install.png" alt="python-win-install" title="python-win-install"><br>注意要勾选<code>Add Python 3.6 tp PATH</code>,然后点<code>Install Now</code>即可完成安装。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>通过<code>win+R</code>打开运行，输入<code>cmd</code>，在弹出的windows命令提示符输入<code>python</code>。<br>若提示信息如下，说明python安装正确。<br><img src="http://cdn.rosinelan.com/blog/program/python-win-test.png" alt="python-win-test" title="python-win-test"><br>若得到如下错误信息，说明安装的时候未勾选<code>Add Python 3.6 tp PATH</code><br><img src="http://cdn.rosinelan.com/blog/program/python-win-wrong.png" alt="python-win-wrong" title="python-win-wrong"><br>此时需要修改环境变量使计算机能找到python所在位置。<br>通过<code>我的电脑--&gt;右键--&gt;属性--&gt;高级系统设置--&gt;环境变量</code>，在弹出的对话框中找到用户变量/系统变量中的<code>Path</code>变量，根据python安装位置添加路径。<br><img src="http://cdn.rosinelan.com/blog/program/python-win-path.png" alt="python-win-path" title="python-win-path"><br><img src="http://cdn.rosinelan.com/blog/program/python-win-add.png" alt="python-win-add" title="python-win-add"><br>win10系统默认安装路径如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\username\AppData\Local\Programs\Python\Python36\Scripts\   </span><br><span class="line">C:\Users\username\AppData\Local\Programs\Python\Python36\</span><br></pre></td></tr></table></figure></p><p>此处建议添加到系统变量中的Path变量中，系统变量是全局变量，无论什么用户登录均可生效；用户变量只针对当前用户生效，若更换其他用户登录则不会生效。<br>若认为添加环境变量操作太复杂，建议直接重装python，记得勾选<code>Add Python 3.6 tp PATH</code>。    </p><h2 id="python开发工具"><a href="#python开发工具" class="headerlink" title="python开发工具"></a>python开发工具</h2><h3 id="python开发工具介绍"><a href="#python开发工具介绍" class="headerlink" title="python开发工具介绍"></a>python开发工具介绍</h3><p>安装好python环境之后，简单的使用直接使用文本编辑器即可，比较常用的有Sublime Text、Notepad++等。<br>大型项目建议使用比较专业的集成开发环境，有利于提高效率，推荐PyCharm。<br><a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">点击访问官方地址</a><br>PyCharm是Python IDE for Professional Developers。高大上的开发工具，工欲善其事必先利其器嘛。专业版为收费工具，请支持正版。<br>windows版本pycharm v2017.3.4<br><a href="https://download.jetbrains.8686c.com/python/pycharm-professional-2017.3.4.exe" target="_blank" rel="noopener">点击下载</a></p><h3 id="PyCharm使用"><a href="#PyCharm使用" class="headerlink" title="PyCharm使用"></a>PyCharm使用</h3><h4 id="设置python版本"><a href="#设置python版本" class="headerlink" title="设置python版本"></a>设置python版本</h4><p>通过File–&gt;Setting–&gt;Project:XXXX–&gt;Project Interpreter下拉框选择相应版本的python。<br><img src="http://cdn.rosinelan.com/blog/program/pycharm-set-version.png" alt="pycharm-set-version" title="pycharm-set-version"><br>注意：当前选择的python版本用于当前Project，这样对于同时维护或开发不同版本的python非常便捷。   </p><h4 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h4><p>通过File–&gt;Setting–&gt;Editor–&gt;Font设置合适的字体、大小、行距。<br><img src="http://cdn.rosinelan.com/blog/program/pycharm-set-font.png" alt="pycharm-set-font" title="pycharm-set-font">   </p><h4 id="设置文件模板"><a href="#设置文件模板" class="headerlink" title="设置文件模板"></a>设置文件模板</h4><p>通过File–&gt;setting–&gt;Editor–&gt;Code Style–&gt;File and Code Templates–&gt;Python Script添加文件模板。<br><img src="http://cdn.rosinelan.com/blog/program/pycharm-set-template.png" alt="pycahrm-set-template" title="pycharm-set-template"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class="line"># @Author  : xiaohuihui</span><br><span class="line"># @File    : $&#123;NAME&#125;.py</span><br></pre></td></tr></table></figure></p><p>其中Time为创建时间，Author为作者，File为文件名。   </p><h4 id="pycharm运行"><a href="#pycharm运行" class="headerlink" title="pycharm运行"></a>pycharm运行</h4><p>通过File–&gt;New Project创建新的项目。<br><img src="http://cdn.rosinelan.com/blog/program/pycharm-new-python.png" alt="pycharm-new-python" title="pycharm-new-python"><br>通过项目–&gt;右键–&gt;New Python File创建第一个python文件。<br><img src="http://cdn.rosinelan.com/blog/program/pycharm-new-File.png" alt="pycharm-new-file" title="pycharm-new-file"><br>python文件的运行有3种方式<br>在python文件中右键–&gt;Run ‘input’，或者使用快捷键Ctrl+Shift+F10。<br>点击左下角的绿色<code>运行</code>按钮。<br>点击右上角的绿色<code>运行</code>按钮。<br><img src="http://cdn.rosinelan.com/blog/program/pycharm-run-python.png" alt="pycharm-run-python" title="pycharm-run-python"><br>注意：左下角和右上角的<code>运行</code>按钮默认执行的为上次执行过的python文件，也就是当切换到另一个python文件时，直接点击<code>运行</code>按钮，其执行文件不是当前文件。建议使用快捷键或者右键执行的方式。<br>windows下命令行运行python文件<br>在不打开pycharm时可以运行python文件嘛？<br>只要windows安装好python环境，答案自然是肯定的。<br>在命令行中使用<code>python D:\pythondev\calculate\print.py</code>方式运行即可。<br><img src="http://cdn.rosinelan.com/blog/program/python-run-cmd.png" alt="python-run-cmd" title="python-run-cmd">   </p><h4 id="pycharm参数传递"><a href="#pycharm参数传递" class="headerlink" title="pycharm参数传递"></a>pycharm参数传递</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import sys   </span><br><span class="line">print(&quot;File name:&#123;0&#125;&quot;.format(sys.argv[0]))  </span><br><span class="line">print(&quot;First argv:&#123;0&#125;&quot;.format(sys.argv[1]))  </span><br><span class="line">print(&quot;Second argv:&#123;0&#125;&quot;.format(sys.argv[2]))</span><br></pre></td></tr></table></figure><p>上述文件位于D:\pythondev\calculate，文件名称为print.py。<br>在命令行中参数传递方式<code>python print.py xiaohh 1000</code>。<br><img src="http://cdn.rosinelan.com/blog/program/python-argv-cmd.png" alt="python-argv-cmd" title="python-argv-cmd"><br>在pycharm中如何传递参数呢？<br>直接右键执行结果如下<br><img src="http://cdn.rosinelan.com/blog/program/pycharm-argv-wrong.png" alt="pycharm-argv-wrong" title="pycharm-argv-wrong"><br>需要传递参数的情况下，点击右上角<code>运行</code>左边下拉框，选择<code>Edit Configurations</code>，弹出的对话框中选择对应python文件–&gt;Configuration–&gt;Parameters，输入参数，空格区分。<br><img src="http://cdn.rosinelan.com/blog/program/pycharm-argv-right.png" alt="pycharm-argv-right" title="pycharm-argv-right">    </p><h4 id="pycharm快捷键"><a href="#pycharm快捷键" class="headerlink" title="pycharm快捷键"></a>pycharm快捷键</h4><p><code>Ctrl + c</code> 复制<br><code>Ctrl + x</code> 剪切<br><code>Ctrl + d</code> 复制当前行<br><code>Ctrl + /</code> 注释当前行<br><code>Ctrl + r</code> 替换<br><code>Shift + Enter</code> 换行<br><code>Alt + Enter</code> 导入包(当写出包名时，按快捷键可自动添加<code>import</code>)<br><code>Ctrl + Shift + f</code> 查找(中文输入法冲突，需关闭才能生效)<br><code>Ctrl + Shift + n</code> 查找文件<br><code>Alt + 鼠标左键</code> 块编辑<br><code>光标批量选中 + Tab</code> 整体向右移动<br><code>光标批量选中 + Shift + Tab</code> 整体向左移动<br><code>Ctrl + a,Ctrl + Alt + L</code> 格式化(和QQ锁定快捷键一致，需修改QQ锁定快捷键)<br><code>Ctrl + Alt + 方向键</code> 查找引用和依赖包时，向右方向键为前进至下一个依赖包处，向左方向键为返回上一个依赖包处(此快捷键和Intel核心显卡快捷键冲突，建议禁用intel核心显卡快捷键)   </p><h4 id="pycharm调试"><a href="#pycharm调试" class="headerlink" title="pycharm调试"></a>pycharm调试</h4><p>设置断点<br>在行号和代码中间位置点击鼠标左键即可添加断点。<br><img src="http://cdn.rosinelan.com/blog/program/pycharm-debug-dot.png" alt="pycahrm-debug-dot" title="pycharm-debug-dot"><br>调试模式<br>点击右上角的蜘蛛图标进行调试(Debug)模式<br><img src="http://cdn.rosinelan.com/blog/program/pycharm-debug-start.png" alt="pycharm-debug-start" title="pycharm-debug-start"><br><code>F7</code> Step into 跳入代码<br><img src="http://cdn.rosinelan.com/blog/program/pycharm-debug-F7.gif" alt="pycharm-debug-F7" title="pycharm-debug-F7"><br><code>F8</code> Step Over 继续下一步<br><img src="http://cdn.rosinelan.com/blog/program/pycharm-debug-F8.gif" alt="pycharm-debug-F8" title="pycharm-debug-F8"><br><code>F9</code> Resume Program 执行到下一个断点或恢复程序<br><img src="http://cdn.rosinelan.com/blog/program/pycharm-debug-F9.gif" alt="pycharm-debug-F9" title="pycharm-debug-F9"><br>断点是调试时快速查找代码错误最有用的方法，需要熟悉并了解不同快捷键的作用。</p><h4 id="pycharm激活"><a href="#pycharm激活" class="headerlink" title="pycharm激活"></a>pycharm激活</h4><p>一般学习下载安装免费的社区版本足够，若有较大项目开发需求，专业版的pycharm激活可以参考<a href="http://idea.lanyus.com/" target="_blank" rel="noopener">IntelliJ IDEA 注册码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;python介绍&quot;&gt;&lt;a href=&quot;#python介绍&quot; class=&quot;headerlink&quot; title=&quot;python介绍&quot;&gt;&lt;/a&gt;python介绍&lt;/h2&gt;&lt;p&gt;python是荷兰人Guidovan Rossum于1989年发明的，第一个公开发行版本发行于1991年。&lt;br&gt;python的设计哲学是”优雅”、”明确”、”简单”，也因此python得以迅速的发展起来，得到大量用户的欢迎。&lt;br&gt;除了大家熟知的“脚本语言”作用之外，python还提供了很多与网络、GUI、图片、文件等相关的基础代码库和第三方库，这样很多功能可以不用从零开始，非常便捷。&lt;br&gt;根据&lt;a href=&quot;https://www.tiobe.com/tiobe-index/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TIOBE&lt;/a&gt;2018年3月发布的最新一期编程语言排行榜，python排名第4，仅位于Java/C/C++之后，可见python的流行程度。&lt;br&gt;
    
    </summary>
    
      <category term="系统管理" scheme="https://rosinelan.github.io/categories/system/"/>
    
      <category term="python实战" scheme="https://rosinelan.github.io/categories/system/python%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="python" scheme="https://rosinelan.github.io/tags/python/"/>
    
      <category term="安装" scheme="https://rosinelan.github.io/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>django基础</title>
    <link href="https://rosinelan.github.io/2018/07/26/django%E5%9F%BA%E7%A1%80/"/>
    <id>https://rosinelan.github.io/2018/07/26/django基础/</id>
    <published>2018-07-26T09:20:00.000Z</published>
    <updated>2018-07-26T09:20:00.623Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jquery基础</title>
    <link href="https://rosinelan.github.io/2018/07/18/jquery%E5%9F%BA%E7%A1%80/"/>
    <id>https://rosinelan.github.io/2018/07/18/jquery基础/</id>
    <published>2018-07-18T03:32:58.000Z</published>
    <updated>2018-07-23T08:02:09.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jQuery简介"><a href="#jQuery简介" class="headerlink" title="jQuery简介"></a>jQuery简介</h3><p>jQuery是一个JavaScript函数库，它可以完成以下操作：</p><ul><li>HTML元素选取</li><li>HTML元素操作</li><li>CSS操作<a id="more"></a></li><li>HTML事件函数</li><li>JavaScript特效和动画</li><li>HTML DOM 遍历和修改</li><li>AJAX</li><li>Utilities</li></ul><p>那么如何使用jQuery库呢？<br>jQuery库其实就在一个JavaScript文件中，其中包含了所有的jQuery函数。通过下面的标记就可以将jQuery添加到网页。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>jQuery的下载可以点击<a href="http://jquery.com/download/" target="_blank" rel="noopener">jQuery</a>从官网下载。<br>要是不想在本地计算机存放Jquery库，也可以从Google或者Microsoft加载CDN jQuery文件，具体使用方式如下。<br>使用Google的CDN<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://ajax.googleapis.com/ajax/libs</span></span></span><br><span class="line"><span class="tag"><span class="string">/jquery/1.4.0/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>使用Microsoft的CDN<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://ajax.microsoft.com/ajax/jquery</span></span></span><br><span class="line"><span class="tag"><span class="string">/jquery-1.4.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="jQuery语法"><a href="#jQuery语法" class="headerlink" title="jQuery语法"></a>jQuery语法</h3><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><p>基础语法是<code>$(selector).action()</code>。  </p><ul><li><code>$</code>符号定义jQuery</li><li><code>selector</code>查询或查找HTML元素</li><li><code>action()</code>执行对元素的操作</li></ul><p>示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">this</span>).hide() <span class="comment">//隐藏当前元素</span></span><br><span class="line">$(<span class="string">"p"</span>).hide()  <span class="comment">//隐藏所有段落</span></span><br><span class="line">$(<span class="string">".test"</span>).hide()  <span class="comment">//隐藏所有class="test”的元素</span></span><br><span class="line">$(<span class="string">"#test"</span>).hide()  <span class="comment">//隐藏所有id="test"的元素</span></span><br></pre></td></tr></table></figure></p><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>jQuery元素选择器和属性选择器允许通过标签名、属性名或内容对HTML元素进行选择。<br>选择器允许对HTML单个元素进行操作。  </p><ul><li><p>jQuery元素选择器<br>jQuery使用呢CSS选择器来选取HTML元素。<br>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>)  <span class="comment">//选取&lt;p&gt;元素</span></span><br><span class="line">$(<span class="string">"p.intro"</span>)  <span class="comment">//选取所有class="intro"的&lt;p&gt;元素</span></span><br><span class="line">$(<span class="string">"p#demo"</span>)  <span class="comment">//选取所有id="demo"的&lt;p&gt;元素</span></span><br></pre></td></tr></table></figure></li><li><p>jQuery属性选择器<br>jQuery使用XPath表达式选择带有给定属性的元素。<br>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"[href]"</span>)  <span class="comment">//选取所有带有href属性的元素</span></span><br><span class="line">$(<span class="string">"[href='#']"</span>)  <span class="comment">//选取所有带有href值等于"#"的元素</span></span><br><span class="line">$(<span class="string">"[href!='#']"</span>)  <span class="comment">//选取所有带有href值不等于"#"的元素</span></span><br><span class="line">$(<span class="string">"[href='.jpg']"</span>)  <span class="comment">//选取所有href值以.jpg结尾的元素</span></span><br></pre></td></tr></table></figure></li><li><p>jQuery CSS选择器<br>jQuery CSS选择器可用于改变HTML元素的CSS属性。<br>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"background-color"</span>,<span class="string">"red"</span>);  <span class="comment">//所有p元素的背景颜色修改为红色</span></span><br></pre></td></tr></table></figure></li></ul><p>关于选择器有更多的内容，可以点击<a href="http://www.w3school.com.cn/jquery/jquery_ref_selectors.asp" target="_blank" rel="noopener">jQuery 参考手册 - 选择器</a>查看。</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><ul><li>jQuery 事件函数<br>jQuery事件处理方法是jQuery中的核心函数。<br>通常会把jQuery代码放到<code>&lt;head&gt;</code>部分的事件处理方法中。<br>示例<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="built_in">document</span>).read(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"p"</span>).hide();</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is another paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>当按钮的点击事件被触发时会调用一个函数，该方法隐藏所有的<code>&lt;p&gt;</code>元素。  </p><ul><li>常用的事件方法<br><code>$(document).ready()</code><br>允许在文档完全加载完成后执行函数。  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(docunment).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//jQuery代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>上述写法简化为<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//jQuery代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>click()</code><br>当按钮点击事件被触发时调用一个函数。<br>示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).hide();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>当点击事件在某个<code>&lt;p&gt;</code>元素出发时，隐藏当前的<code>&lt;p&gt;</code>元素。<br><code>dbclick()</code><br>双击元素时，会发生dbclick事件。此时将调用对应函数。<br>示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).dbclick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).hide();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>focus()</code><br>当元素获得焦点时，发生focus事件。<br>focus()方法出发focus事件，或规定发生focus事件时运行的函数。<br>示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"input"</span>).foucs(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">"background-color"</span>,<span class="string">"#cccccc"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>更多关于jQuery事件可以点击<a href="http://www.w3school.com.cn/jquery/jquery_ref_events.asp" target="_blank" rel="noopener">jQuery 参考手册 - 事件</a>查看介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;jQuery简介&quot;&gt;&lt;a href=&quot;#jQuery简介&quot; class=&quot;headerlink&quot; title=&quot;jQuery简介&quot;&gt;&lt;/a&gt;jQuery简介&lt;/h3&gt;&lt;p&gt;jQuery是一个JavaScript函数库，它可以完成以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML元素选取&lt;/li&gt;
&lt;li&gt;HTML元素操作&lt;/li&gt;
&lt;li&gt;CSS操作
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="web" scheme="https://rosinelan.github.io/categories/program/web/"/>
    
    
      <category term="jquery" scheme="https://rosinelan.github.io/tags/jquery/"/>
    
      <category term="查询" scheme="https://rosinelan.github.io/tags/%E6%9F%A5%E8%AF%A2/"/>
    
      <category term="操作" scheme="https://rosinelan.github.io/tags/%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>css基础</title>
    <link href="https://rosinelan.github.io/2018/07/17/css%E5%9F%BA%E7%A1%80/"/>
    <id>https://rosinelan.github.io/2018/07/17/css基础/</id>
    <published>2018-07-17T07:52:14.000Z</published>
    <updated>2018-07-23T08:01:57.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CSS概述"><a href="#CSS概述" class="headerlink" title="CSS概述"></a>CSS概述</h3><p>CSS指层叠样式表，是<code>Cascading Style Sheets</code>的缩写。<br>样式定义了如何显示HTML元素，通常存储在样式表中，使用样式解决了内容和表扬分离的问题。<br>使用外部样式表可以极大提高工作效率，通常存储在CSS文件中，多个样式定义可层叠为一。<br>同一个元素被多个样式定义时的优先级(其中数字4拥有最高的优先权)：<br><a id="more"></a></p><ol><li>浏览器缺省设置</li><li>外部样式表</li><li>内部样式表(位于<code>&lt;head&gt;</code>标签内部)</li><li>内联样式(在HTML元素内部)<h3 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4>CSS规则主要由2个部分构成：选择器以及一条或多条声明。  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector &#123;declaration1; declaration2;... declarationN&#125;</span><br></pre></td></tr></table></figure></li></ol><p>选择器通常是需要改变样式的HTML元素。<br>每条元素由一个属性和一个值组成。属性是希望设置的样式属性，每个属性有一个值，属性和值使用冒号分开。<br>下面代码的作用是将h1元素内的文字颜色定义为红色，字体大小设置为14px。选择器是<code>h1</code>，属性是<code>color</code> <code>font-size</code> 值是<code>red</code> <code>14px</code>。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>:red; <span class="attribute">font-size</span>:<span class="number">14px</span>;&#125;</span><br></pre></td></tr></table></figure></p><h4 id="选择器分组"><a href="#选择器分组" class="headerlink" title="选择器分组"></a>选择器分组</h4><p>对选择器进行分组，这样被分组的选择器可以分享相同的声明。用逗号将需要分组的选择器分开。<br>下面代码对所有标签元素进行分组，所有标题元素都是绿色的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><ul><li>派生选择器<br>通过依据元素在其位置的上下文关系类定义样式。<br>例如：假如希望列表中的strong元素变为斜体，可以这样定义一个派生选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">strong</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>我是粗体字，不是斜体字，因为我不在列表当中，所以这个规则对我不起作用<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>我是斜体字。这是因为 strong 元素位于 li 元素内。<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>我是正常的字体。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只有<code>li</code>元素中的<code>strong</code>元素样式为斜体，无需为strong元素定义特别的class或id，代码更加整洁。  </p><ul><li>id选择器<br>id选择器可以为标有特定id的HTML元素指定特定的样式。id选择器以<code>#</code>定义。<br>下面示例中的id选择器，第一个定义元素颜色为红色，第二个定义元素颜色为绿色。  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#red</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-id">#green</span> &#123;<span class="attribute">color</span>:green;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在下面的HTML代码中，id属性为red的p元素显示为红色，id属性为green的p元素显示为绿色。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"red"</span>&gt;</span>这个段落是红色。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"green"</span>&gt;</span>这个段落是绿色。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>类选择器<br>类选择器以<code>.</code>定义。  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;<span class="attribute">text-align</span>: center&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上面的示例表示所有用于center类的HTML元素均为居中。<br>下面的示例中，h1和p元素都有center类，豆浆遵守<code>.center</code>选择器的规则。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">This heading will be center-aligned</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">This paragraph will also be center-aligned.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>属性选择器<br>对带有指定属性的HTML元素设置样式，不仅仅限于class和id属性。<br>下面示例为带有title属性的所有元素设置样式。  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[title]</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>也可以指定属性的值。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[title=hello]</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">5px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还包括下面一些属性和值的对一个关系。<br>|选择器|描述|<br>|-|:-|<br>[attribute]|用于选取带有指定属性的元素<br>[attribute=value]|用于选取带有指定属性和值的元素<br>[attribute~=value]|用于选取属性值中包含指定词汇的元素<br>[attribute|=value]|用于选取带有以指定值开头的属性值的元素，该值必须是整个单词<br>[attribute^=value]|匹配属性值以指定值开头的每个元素<br>[attribute$=value]|匹配属性值以指定值结尾的每个元素<br>[attribute*=value]|匹配属性值中包含指定值的每个元素</p><h3 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>使用<code>background-color</code>属性为元素设置背景色。可为所有元素设置背景色，但是不能继承，其默认值为<code>transparent</code>，也就是透明。<br>下面的示例将元素背景色设置为灰色<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">background-color</span>: gray;&#125;</span><br></pre></td></tr></table></figure></p><p>使用<code>background-image</code>属性将图像放入背景。默认值为none。不能继承。<br>下面示例为段落应用了一个背景<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.flower</span> &#123;<span class="attribute">background-image</span>: <span class="built_in">url</span>(/i/eg_bg_03.gif);&#125;</span><br></pre></td></tr></table></figure></p><p>使用<code>background-repeat</code>属性对背景图像进行平铺。<br>属性值 repeat 导致图像在水平垂直方向上都平铺，就像以往背景图像的通常做法一样。repeat-x 和 repeat-y 分别导致图像只在水平或垂直方向上重复，no-repeat 则不允许图像在任何方向上平铺。<br>默认将从一个元素的左上角开始。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(/i/eg_bg_03.gif);</span><br><span class="line">    <span class="attribute">background-repeat</span>: repeat-y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用<code>background-position</code>属性改变图像在背景中的位置。该属性对应的值有多种。  </p><ol><li>关键字，top/bottom/left/right/center。</li><li>长度值，100px/5cm</li><li>百分数，50%/70%<br>示例：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    background-position: center;    居中</span><br><span class="line">    <span class="selector-tag">background-position</span><span class="selector-pseudo">:50</span>% 50%;    居中</span><br><span class="line">    <span class="selector-tag">background-position</span><span class="selector-pseudo">:50px</span> 100<span class="selector-tag">px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>最后一个表示图像的左上角将在元素内边距区左上角向右 50 像素、向下 100 像素的位置上。<br>使用<code>background-attachment</code>属性表示图像是否随着文档滚动而滚动，属性值有<code>fixed</code> <code>scroll</code>。其中<code>scroll</code>为默认值。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> </span><br><span class="line">  &#123;</span><br><span class="line">  <span class="attribute">background-image</span>:<span class="built_in">url</span>(/i/eg_bg_02.gif);</span><br><span class="line">  <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">  <span class="attribute">background-attachment</span>:fixed</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><h3 id="CSS框模型"><a href="#CSS框模型" class="headerlink" title="CSS框模型"></a>CSS框模型</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CSS概述&quot;&gt;&lt;a href=&quot;#CSS概述&quot; class=&quot;headerlink&quot; title=&quot;CSS概述&quot;&gt;&lt;/a&gt;CSS概述&lt;/h3&gt;&lt;p&gt;CSS指层叠样式表，是&lt;code&gt;Cascading Style Sheets&lt;/code&gt;的缩写。&lt;br&gt;样式定义了如何显示HTML元素，通常存储在样式表中，使用样式解决了内容和表扬分离的问题。&lt;br&gt;使用外部样式表可以极大提高工作效率，通常存储在CSS文件中，多个样式定义可层叠为一。&lt;br&gt;同一个元素被多个样式定义时的优先级(其中数字4拥有最高的优先权)：&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="web" scheme="https://rosinelan.github.io/categories/program/web/"/>
    
    
      <category term="css" scheme="https://rosinelan.github.io/tags/css/"/>
    
      <category term="语法" scheme="https://rosinelan.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="选择器" scheme="https://rosinelan.github.io/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>html基础(二)</title>
    <link href="https://rosinelan.github.io/2018/07/17/html%E5%9F%BA%E7%A1%80-%E4%BA%8C/"/>
    <id>https://rosinelan.github.io/2018/07/17/html基础-二/</id>
    <published>2018-07-17T07:52:01.000Z</published>
    <updated>2018-07-23T08:01:42.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无须列表"><a href="#无须列表" class="headerlink" title="无须列表"></a>无须列表</h4><p>无序列表是一个项目的列表，此列项目使用粗体圆点(典型的小黑圆圈)进行标记。<br>无序列表始于<code>&lt;ul&gt;</code>标签。每个列表项始于<code>&lt;li&gt;</code>。<br><a id="more"></a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>显示结果如下</p><p><ul></ul></p><p><li>Coffee</li></p><p><li>Milk</li><br><br>列表项内部也可以使用换行符、图片、链接及其他列表等。  </p><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>有序列表也是一列项目，列表项目使用数字进行标记。<br>有序列表始于<code>ol</code>标签。每个列表项始于<code>li</code>标签。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>显示结果如下</p><p><ol></ol></p><p><li>Coffee</li></p><p><li>Milk</li><br><br>列表项内部也可以使用换行符、图片、链接及其他列表等。 </p><h4 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h4><p>自定义列表以<code>&lt;dl&gt;</code>标签开始。每个自定义列表项以<code>&lt;dt&gt;</code>开始。每个自定义列表项的定义以<code>&lt;dd&gt;</code>开始。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>Black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>White cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>显示结果如下  </p><p><dl></dl></p><p><dt>Coffee</dt></p><p><dd>Black hot drink</dd></p><p><dt>Milk</dt></p><p><dd>White cold drink</dd><br><br>定义列表的列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格由<code>&lt;table&gt;</code>标签定义。每个表格均有若干行(由<code>&lt;tr&gt;</code>标签定义)，每行被分割为若干单元格(由<code>&lt;td&gt;</code>标签定义)。<br>单元格可以包含文本、图片、表格等。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>显示如下</p><table><br><tr><br><td>row 1, cell 1</td><br><td>row 1, cell 2</td><br></tr><br><tr><br><td>row 2, cell 1</td><br><td>row 2, cell 2</td><br></tr><br></table><p>其他属性</p><ul><li>显示边框使用<code>border</code>属性。</li><li>表头使用<code>&lt;th&gt;</code>标签定义。</li><li>合并行使用<code>rowspan</code>。</li><li>和并列使用<code>colspan</code>。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>电话<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Bill Gates<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>55577854<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>55577855<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bill Gates<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>电话<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>55577854<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>55577855<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示如下<br>列合并</p><table border="1"><br><tr><br><th>姓名</th><br><th colspan="2">电话</th><br></tr><br><tr><br><td>Bill Gates</td><br><td>55577854</td><br><td>55577855</td><br></tr><br></table><br>行合并<br><table border="1"><br><tr><br>  <th>姓名</th><br>  <td>Bill Gates</td><br></tr><br><tr><br>  <th rowspan="2">电话</th><br>  <td>55577854</td><br></tr><br><tr><br>  <td>55577855</td><br></tr><br></table><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>HTML表单用于搜集不同用户类型的用户输入。使用<code>&lt;form&gt;</code>定义HTML表单。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">form elements</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>表单中包括的元素有<code>input元素</code> <code>复选框</code> <code>单选按钮</code> <code>提交按钮</code>等。  </p><ul><li>input元素<br><code>&lt;input&gt;</code>元素根据不同的type属性，有很多形态。<br><code>&lt;input type=&quot;text&quot;&gt;</code>定义用于文本输入的单行输入字段。<br><code>&lt;input type=&quot;radio&quot;&gt;</code>定义单选按钮，允许用户在有限数量的选项中选择其中之一。<br><code>&lt;select&gt;</code>定义下拉列表，<code>option</code>定义具体列表项，<code>size</code>表示下拉列表可见项的数目。<br><code>&lt;input type=&quot;submit&quot;&gt;</code>定义用于向表单处理程序提交表单的按钮。通常包含用来处理输入数据的脚本的服务器页面。处理程序在表单的action属性中指定。  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"action_page.php"</span>&gt;</span></span><br><span class="line">First name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"firstname"</span> <span class="attr">value</span>=<span class="string">"Mickey"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Last name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"lastname"</span> <span class="attr">value</span>=<span class="string">"Mouse"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Gender:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"male"</span> <span class="attr">checked</span>&gt;</span>Male</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"female"</span>&gt;</span>Female</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Education:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"list"</span> <span class="attr">size</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>postgraduate<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>undergraduate<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>junior college student<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>technical secondary school<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>显示如下</p><form action="action_page.php"><br>First name:<br><br><input type="text" name="firstname" value="Mickey"><br><br><br>Last name:<br><br><input type="text" name="lastname" value="Mouse"><br><br><br>Gender:<br><br><input type="radio" name="sex" value="male" checked>Male<br><br><br><input type="radio" name="sex" value="female">Female<br><br><br>Education:<br><br><select name="list" size="3"><br><option>postgraduate</option><br><option>undergraduate</option><br><option>junior college student</option><br><option>technical secondary school</option><br></select><br><br><br><input type="submit" value="Submit"><br></form>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h3&gt;&lt;h4 id=&quot;无须列表&quot;&gt;&lt;a href=&quot;#无须列表&quot; class=&quot;headerlink&quot; title=&quot;无须列表&quot;&gt;&lt;/a&gt;无须列表&lt;/h4&gt;&lt;p&gt;无序列表是一个项目的列表，此列项目使用粗体圆点(典型的小黑圆圈)进行标记。&lt;br&gt;无序列表始于&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;标签。每个列表项始于&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="web" scheme="https://rosinelan.github.io/categories/program/web/"/>
    
    
      <category term="html" scheme="https://rosinelan.github.io/tags/html/"/>
    
      <category term="列表" scheme="https://rosinelan.github.io/tags/%E5%88%97%E8%A1%A8/"/>
    
      <category term="表格" scheme="https://rosinelan.github.io/tags/%E8%A1%A8%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>saltstack结合ansible实战</title>
    <link href="https://rosinelan.github.io/2018/07/11/saltstack%E7%BB%93%E5%90%88ansible%E5%AE%9E%E6%88%98/"/>
    <id>https://rosinelan.github.io/2018/07/11/saltstack结合ansible实战/</id>
    <published>2018-07-11T10:21:04.000Z</published>
    <updated>2018-07-11T11:18:12.044Z</updated>
    
    <content type="html"><![CDATA[<p>通过<code>saltstack</code>模块调用，结合<code>ansible</code>实现2台服务器之间免密钥登录，同时安装<code>minion</code>端。<br>适用场景：已存在安装<code>saltstack</code>的<code>master</code>端，新上线服务器，需安装<code>minion</code>端加入至<code>master</code>。<br><a id="more"></a><br>在master端事先生成密钥对，写好免密钥登录和安装<code>minion</code>端脚本。脚本统一放在<code>/srv/salt/_shell</code>。  </p><ol><li>免密钥配置脚本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /srv/salt/_shell/installpub.sh   </span><br><span class="line"><span class="built_in">cd</span> /root/</span><br><span class="line"><span class="built_in">umask</span> 077</span><br><span class="line"><span class="built_in">test</span> -d .ssh || mkdir .ssh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'xxxx'</span> &gt;&gt; .ssh/authorized_keys</span><br></pre></td></tr></table></figure></li></ol><p>注意此处<code>.ssh</code>目录权限为700，<code>authorized_keys</code>文件权限为600或700。</p><ol><li><p>安装配置minion端脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat /srv/salt/_shell/minionid.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">yum install -y salt-minion</span><br><span class="line"><span class="comment">#ip=`ifconfig | grep -w 'inet' |grep -v grep |awk ` #根据不同版本centos获取方式不一样</span></span><br><span class="line">ip=ifconfig eth0|grep inet|awk <span class="string">'&#123;print $2&#125;'</span></span><br><span class="line">sed -i <span class="string">'s/^#master:salt/master: 19.168.145.130/'</span> /etc/salt/minion</span><br><span class="line">sed -i <span class="string">'s/^#id:.*/id: $ip/'</span> /etc/salt/minion</span><br></pre></td></tr></table></figure></li><li><p>客户端代码<br><code>saltapi.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaltServer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.session = requests.session()</span><br><span class="line">        self.token = self.getToken()</span><br><span class="line">        print(self.token)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getToken</span><span class="params">(self)</span>:</span></span><br><span class="line">        url =  <span class="string">"http://192.168.48.137:8000/login"</span></span><br><span class="line">        headers = &#123;<span class="string">"Accept"</span>: <span class="string">"application/json"</span>&#125;</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">"username"</span>: <span class="string">"saltapi"</span>,</span><br><span class="line">            <span class="string">"password"</span>: <span class="string">"saltapi"</span>,</span><br><span class="line">            <span class="string">"eauth"</span>: <span class="string">"pam"</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = self.session.post(url=url, headers=headers, data=data)</span><br><span class="line">        text = res.text</span><br><span class="line">        result = json.loads(text)</span><br><span class="line">        token = result.get(<span class="string">"return"</span>)[<span class="number">0</span>].get(<span class="string">"token"</span>)</span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runModules</span><span class="params">(self, minionid, fun, arg=None)</span>:</span></span><br><span class="line">        url = <span class="string">"http://192.168.48.137:8000"</span></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">"client"</span>: <span class="string">"local"</span>,</span><br><span class="line">            <span class="string">"tgt"</span>: minionid,</span><br><span class="line">            <span class="string">"fun"</span>: fun,</span><br><span class="line">            <span class="string">"arg"</span>: arg</span><br><span class="line">        &#125;</span><br><span class="line">        resultBean = dict()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = self.session.post(url=url,  data=data)</span><br><span class="line">            text = res.text</span><br><span class="line">            data = json.loads(text).get(<span class="string">"return"</span>)</span><br><span class="line">            resultBean[<span class="string">'code'</span>] = <span class="number">0</span></span><br><span class="line">            resultBean[<span class="string">'message'</span>] = <span class="string">"success"</span></span><br><span class="line">            resultBean[<span class="string">'data'</span>] = data</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            resultBean[<span class="string">'code'</span>] = <span class="number">1</span></span><br><span class="line">            resultBean[<span class="string">'message'</span>] = <span class="string">"failed"</span></span><br><span class="line">            resultBean[<span class="string">'data'</span>] = e</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">return</span> resultBean</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runRunner</span><span class="params">(self, fun, **kwargs)</span>:</span></span><br><span class="line">        url = <span class="string">"http://192.168.48.137:8000"</span></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">"client"</span>: <span class="string">"runner"</span>,</span><br><span class="line">            <span class="string">"fun"</span>: fun,</span><br><span class="line">        &#125;</span><br><span class="line">        data.update(kwargs)</span><br><span class="line">        print(data)</span><br><span class="line">        resultBean = dict()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = self.session.post(url=url,  data=data)</span><br><span class="line">            text = res.text</span><br><span class="line">            data = json.loads(text).get(<span class="string">"return"</span>)</span><br><span class="line">            resultBean[<span class="string">'code'</span>] = <span class="number">0</span></span><br><span class="line">            resultBean[<span class="string">'message'</span>] = <span class="string">"success"</span></span><br><span class="line">            resultBean[<span class="string">'data'</span>] = data</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            resultBean[<span class="string">'code'</span>] = <span class="number">1</span></span><br><span class="line">            resultBean[<span class="string">'message'</span>] = <span class="string">"failed"</span></span><br><span class="line">            resultBean[<span class="string">'data'</span>] = e</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">return</span> resultBean</span><br></pre></td></tr></table></figure></li><li><p>位于<code>master</code>端，位置为<code>/srv/salt/__runner/masterApp.py</code>，提供具体执行方法<br><code>masterApp.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">publicKey</span><span class="params">(ipaddr)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> codecs.open(<span class="string">'/tmp/&#123;0&#125;.txt'</span>.format(ipaddr), <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">"&#123;0&#125; ansible_ssh_pass=123456"</span>.format(ipaddr))</span><br><span class="line">    resultBean = dict()</span><br><span class="line">    cmd = <span class="string">"ansible -i /tmp/&#123;0&#125;.txt all -m script -a '/srv/salt/_shell/installpub.sh'"</span>.format(ipaddr)</span><br><span class="line">    status, output = commands.getstatusoutput(cmd)</span><br><span class="line">    <span class="keyword">if</span> status == <span class="number">0</span>:</span><br><span class="line">        resultBean[<span class="string">'code'</span>] = <span class="number">0</span></span><br><span class="line">        resultBean[<span class="string">'message'</span>] = <span class="string">'success'</span></span><br><span class="line">        resultBean[<span class="string">'data'</span>] = output</span><br><span class="line">        <span class="keyword">return</span> json.dumps(resultBean)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">installMinionid</span><span class="params">(ipaddr)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> codecs.open(<span class="string">'/tmp/&#123;0&#125;.txt'</span>.format(ipaddr), <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">"&#123;0&#125; ansible_ssh_pass=123456"</span>.format(ipaddr))</span><br><span class="line">    resultBean = dict()</span><br><span class="line">    cmd = <span class="string">"ansible -i /tmp/&#123;0&#125;.txt all -m script -a '/srv/salt/_shell/minionid.sh'"</span>.format(ipaddr)</span><br><span class="line">    status, output = commands.getstatusoutput(cmd)</span><br><span class="line">    <span class="keyword">if</span> status == <span class="number">0</span>:</span><br><span class="line">        resultBean[<span class="string">'code'</span>] = <span class="number">0</span></span><br><span class="line">        resultBean[<span class="string">'message'</span>] = <span class="string">'success'</span></span><br><span class="line">        resultBean[<span class="string">'data'</span>] = output</span><br><span class="line">        <span class="keyword">return</span> json.dumps(resultBean)</span><br></pre></td></tr></table></figure></li></ol><p>最后在客户端调用测试<br><code>test.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> saltstack_api.util.saltapi <span class="keyword">import</span> SaltServer</span><br><span class="line"></span><br><span class="line">saltServer = SaltServer()</span><br><span class="line">result1 = saltServer.runRunner(<span class="string">'masterApp.publicKey'</span>, ipaddr=<span class="string">'192.168.48.133'</span>)</span><br><span class="line">print(result1)</span><br><span class="line">result2 = saltServer.runRunner(<span class="string">'masterApp.installMinionid'</span>, ipaddr=<span class="string">'192.168.48.133'</span>)</span><br><span class="line">print(result2)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过&lt;code&gt;saltstack&lt;/code&gt;模块调用，结合&lt;code&gt;ansible&lt;/code&gt;实现2台服务器之间免密钥登录，同时安装&lt;code&gt;minion&lt;/code&gt;端。&lt;br&gt;适用场景：已存在安装&lt;code&gt;saltstack&lt;/code&gt;的&lt;code&gt;master&lt;/code&gt;端，新上线服务器，需安装&lt;code&gt;minion&lt;/code&gt;端加入至&lt;code&gt;master&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="ansible" scheme="https://rosinelan.github.io/tags/ansible/"/>
    
      <category term="saltstack" scheme="https://rosinelan.github.io/tags/saltstack/"/>
    
      <category term="minion" scheme="https://rosinelan.github.io/tags/minion/"/>
    
  </entry>
  
  <entry>
    <title>html基础</title>
    <link href="https://rosinelan.github.io/2018/07/11/html%E5%9F%BA%E7%A1%80/"/>
    <id>https://rosinelan.github.io/2018/07/11/html基础/</id>
    <published>2018-07-11T10:20:28.000Z</published>
    <updated>2018-07-11T11:18:01.758Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h3><p>HTML 是用来描述网页的一种语言。<br>HTML 指的是超文本标记语言 (Hyper Text Markup Language)。<br>HTML 不是一种编程语言，而是一种标记语言 (markup language)，标记语言是一套标记标签 (markup tag)。<br><a id="more"></a><br>HTML 使用标记标签来描述网页。  </p><ul><li>HTML 标签<br>HTML 标记标签通常被称为 HTML 标签 (HTML tag)。<br>HTML 标签是由尖括号包围的关键词，比如 <html>。<br>HTML 标签通常是成对出现的，比如 <b> 和 </b>。<br>标签对中的第一个标签是开始标签，第二个标签是结束标签。开始和结束标签也被称为开放标签和闭合标签。  </html></li><li>HTML文档<br>HTML 文档描述网页。<br>HTML 文档包含 HTML 标签和纯文本。<br>HTML 文档也被称为网页。<br>Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容。  </li><li>常用的HTML编辑器<br>notepad<br>editplus<br>sublimit<br>webstrom  </li><li>HTML注释<br><code>&lt;!--此处写注释--&gt;</code><h3 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h3></li><li><p>标题  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>段落  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加粗  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>回车  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>字体<br><code>&lt;font&gt;</code>规定文本的字体，尺寸，颜色。<br>size: 12,13<br>color：red, blue, green, yellow,orange<br>face:   黑体,宋体，微软黑体  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">"字体大小"</span> <span class="attr">color</span> = <span class="string">"字体颜色"</span> <span class="attr">face</span> = <span class="string">"字体类型"</span>&gt;</span>要设置的文字 <span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>行内在一行显示,段落里面可以用过多个标签。<br>span在样式中的时候才能现实其作用。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>行内<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>行内<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>超链接  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">"链接地址"</span> <span class="attr">target</span> = <span class="string">"_blank"</span>&gt;</span>连接标志<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>a标签支持http协议。<br>标签target属性规定在何处打开链接文档。<br>target =”_self”  默认是连接到本页；_blank 浏览器总在一个新打开，未命名的窗口中载入目标文档。  </p><p>链接到本页面  </p><ol><li>首先创建一个锚链接的锚记点：<code>&lt;a  href=“#锚记点名称”&gt;主题名称&lt;/a&gt;</code></li><li>然后在具体要链接到的地方设置name:<code>&lt;a  name=“锚记点名称”&gt;&lt;/a&gt;</code>（锚记点前面要加上#号）  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id = "xiang"</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">"#xiang"</span>&gt;</span>连接到本页的锚记点<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>图像<br>图像标签（<code>&lt;img&gt;</code>）和源属性（Src）。<br>在 HTML 中，图像由<code>&lt;img&gt;</code> 标签定义。<code>&lt;img&gt;</code> 是空标签，意思是说，它只包含属性，并且没有闭合标签。<br>要在页面上显示图像，你需要使用源属性（src）。src 指 “source”。源属性的值是图像的 URL 地址。<br>alt 属性用来为图像定义一串预备的可替换的文本。替换文本属性的值是用户定义的。<br>src  = “url”  图片地址或者本地路径<br>alt =  “美女”  当图片不显示时，显示的字<br>height = “400” 高<br>width = “400”  宽  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">"image/mv1.jpg"</span> <span class="attr">alt</span> = <span class="string">"美女"</span> <span class="attr">height</span> = <span class="string">"1000"</span> <span class="attr">width</span> = <span class="string">"400"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>特殊字符  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">空格：  &amp;nbsp;</span><br><span class="line">大于号： &amp;gt;</span><br><span class="line">小于号： &amp;lt;</span><br><span class="line">引号： &amp;quot;</span><br><span class="line">&amp;符号：&amp;amp;</span><br><span class="line">版本号： &amp;copy;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTML简介&quot;&gt;&lt;a href=&quot;#HTML简介&quot; class=&quot;headerlink&quot; title=&quot;HTML简介&quot;&gt;&lt;/a&gt;HTML简介&lt;/h3&gt;&lt;p&gt;HTML 是用来描述网页的一种语言。&lt;br&gt;HTML 指的是超文本标记语言 (Hyper Text Markup Language)。&lt;br&gt;HTML 不是一种编程语言，而是一种标记语言 (markup language)，标记语言是一套标记标签 (markup tag)。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="web" scheme="https://rosinelan.github.io/categories/program/web/"/>
    
    
      <category term="html" scheme="https://rosinelan.github.io/tags/html/"/>
    
      <category term="css" scheme="https://rosinelan.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>ansible</title>
    <link href="https://rosinelan.github.io/2018/07/06/ansible/"/>
    <id>https://rosinelan.github.io/2018/07/06/ansible/</id>
    <published>2018-07-06T02:57:00.000Z</published>
    <updated>2018-07-06T15:48:17.673Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ansible是自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。github地址为<a href="https://github.com/ansible/ansible" target="_blank" rel="noopener">https://github.com/ansible/ansible</a>。<br><a id="more"></a><br>ansible是基于模块工作的，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。  </p><h4 id="框架组成部分"><a href="#框架组成部分" class="headerlink" title="框架组成部分"></a>框架组成部分</h4><p>ansible框架主要包括：  </p><ol><li>连接插件connection plugins：负责和被监控端实现通信；</li><li>host inventory：指定操作的主机，是一个配置文件里面定义监控的主机；</li><li>各种模块核心模块、command模块、自定义模块；</li><li>借助于插件完成记录日志邮件等功能；</li><li>playbook：剧本执行多个任务时，非必需可以让节点一次性运行多个任务。<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4></li><li>no agents：不需要在被管控主机上安装任何客户端；</li><li>no server：无服务器端，使用时直接运行命令即可；</li><li>modules in any languages：基于模块工作，可使用任意语言开发模块；</li><li>yaml，not code：使用yaml语言定制剧本playbook；</li><li>ssh by default：基于SSH工作；</li><li>strong multi-tier solution：可实现多级指挥。<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4></li><li>轻量级，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可；</li><li>批量任务执行可以写成脚本，而且不用分发到远程就可以执行；</li><li>使用python编写，维护更简单，ruby语法过于复杂；</li><li>支持sudo。<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3>ansible安装比较简单，配置<code>epel</code>源，然后直接通过<code>yum</code>即可安装。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y ansible</span><br></pre></td></tr></table></figure></li></ol><p>当然，也可以通过<code>pip</code>方式安装，<code>pip install ansible</code>。<br>需要注意的是此时的安装的<code>ansible</code>文件位于<code>/usr/local/python/bin</code>目录下。  </p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="ansible-cfg文件"><a href="#ansible-cfg文件" class="headerlink" title="ansible.cfg文件"></a>ansible.cfg文件</h4><p>ansible读取配置文件的顺序如下  </p><ol><li>ansible.cfg(位于当前位置)</li><li>ANSIBLE_CONFIG          一个环境变量</li><li>.ansible.cfg                    位于家目录下</li><li>/etc/ansible/ansible.cfg  </li></ol><p>一般情况下使用配置文件为<code>/etc/ansible/ansible.cfg</code>。<br>配置文件中主要参数如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inventory = /etc/ansible/hosts <span class="comment">#指定inventory配置文件</span></span><br><span class="line">forks = 5 <span class="comment">#子进程数量，推荐设置为cpu核心数</span></span><br><span class="line">sudo_user = root <span class="comment">#sudo用户</span></span><br><span class="line">remote_port = 22 <span class="comment">#远程端口</span></span><br></pre></td></tr></table></figure></p><h4 id="hosts文件"><a href="#hosts文件" class="headerlink" title="hosts文件"></a>hosts文件</h4><p>ansible默认配置文件路径为<code>/etc/ansible/hosts</code>，也可以自定义配置文件路径。  </p><ol><li>常用配置如下<br>中括号nginx代表nginx主机组，nginx_127、nginx_219代表主机，属于nginx主机组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">nginx_127 ansible_ssh_port=22   ansible_ssh_host=127.0.0.1 ansible_ssh_pass=&apos;password&apos;</span><br><span class="line">nginx_219 ansible_ssh_port=22   ansible_ssh_host=192.168.145.219 ansible_ssh_pass=&apos;password&apos;</span><br></pre></td></tr></table></figure></li></ol><p>注意：需要安装sshpass这个软件才能使用密码去操作服务器,安装方式<code>yum install -y sshpass</code>。  </p><ol><li>简化配置<br>如果使用密钥实现了无密码登录，可以使用下面简化配置  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">nginx_127 ansible_ssh_port=22   ansible_ssh_host=127.0.0.1</span><br><span class="line">nginx_219 ansible_ssh_port=22   ansible_ssh_host=192.168.145.219</span><br></pre></td></tr></table></figure></li></ol><p>或者使用更简单的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">127.0.0.1</span><br><span class="line">192.168.145.219</span><br></pre></td></tr></table></figure></p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>ansible使用比较简单，其中-i可以指定配置文件的路径，不指定默认为/etc/ansible/hosts。<br>ansible -i /etc/ansible/hosts 指定主机组或者主机 -m 指定模块 -a 指定模块的参数</p><h4 id="ping模块"><a href="#ping模块" class="headerlink" title="ping模块"></a>ping模块</h4><p>ping模块用来查看服务器是否连接正常，ping模块不需要-a指定参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m ping</span><br></pre></td></tr></table></figure></p><p>主机和主机组注意事项：<br>all     代表所有主机<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ansible -i /etc/ansible/hosts 192.168.145.219:127.0.0.1 -m ping <span class="comment">#自己指定多台主机去操作</span></span><br><span class="line">ansible -i /etc/ansible/hosts all:\!127.0.0.1 -m ping  <span class="comment">#不操作127.0.0.1的主机,!需要转义</span></span><br></pre></td></tr></table></figure></p><h4 id="command模块"><a href="#command模块" class="headerlink" title="command模块"></a>command模块</h4><p>command模块不支持使用管道，不建议使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m command -a <span class="string">"pwd"</span></span><br><span class="line">ansible all -m command -a <span class="string">"df -h|grep sda1"</span></span><br><span class="line">ansible all -m command -a <span class="string">"df -h &gt;&gt;/tmp/xiaohuihu"</span></span><br></pre></td></tr></table></figure></p><h4 id="shell模块"><a href="#shell模块" class="headerlink" title="shell模块"></a>shell模块</h4><p>shell模块支持管道<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m shell -a <span class="string">"df -h|grep sda1"</span>    <span class="comment">#支持管道</span></span><br><span class="line">ansible all -m shell -a <span class="string">"df -h &gt;&gt;/tmp/xiaohuihui"</span>   <span class="comment">#支持重定向</span></span><br><span class="line">ansible all -m shell -a <span class="string">"cat /etc/passwd|awk -F':' '&#123;print \$1&#125;'"</span> <span class="comment">#得进行转义</span></span><br></pre></td></tr></table></figure></p><h4 id="raw模块"><a href="#raw模块" class="headerlink" title="raw模块"></a>raw模块</h4><p>raw模块使用原始的ssh方式运行命令<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m raw -a <span class="string">"yum install python-simplejson -y"</span></span><br><span class="line">ansible all -m raw -a <span class="string">"yum install libselinux-python -y"</span></span><br></pre></td></tr></table></figure></p><h4 id="copy模块"><a href="#copy模块" class="headerlink" title="copy模块"></a>copy模块</h4><p>copy模块使用格式为<code>ansible 主机组 -m copy -a &#39;&#39;</code><br>可用参数如下  </p><ul><li>src: 指定源文件或目录</li><li>dest: 指定目标服务器的文件或目录</li><li>backup: 是否要备份</li><li>owner: 拷贝到目标服务器后，文件或目录的所属用户</li><li>group: 拷贝到目标服务器后，文件或目录的所属群组</li><li>mode: 文件或目录的权限</li></ul><p>下发文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m copy -a <span class="string">"src=/tmp/xiaohuihui/xiaohuihui.txt dest=/usr/local/src/"</span></span><br></pre></td></tr></table></figure></p><p>下发文件夹<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m copy -a <span class="string">"src=/tmp/xiaohuihui/ dest=/usr/local/src/"</span> <span class="comment">#xiaohuihui目录不会拷贝</span></span><br><span class="line">ansible all -m copy -a <span class="string">"src=/tmp/xiaohuihui dest=/usr/local/src/"</span>  <span class="comment">#xiaohuihui目录会拷贝</span></span><br></pre></td></tr></table></figure></p><p>自动备份，备份文件位于<code>dest</code>目录下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m copy -a <span class="string">"src=/tmp/xiaohuihui/xiaohuihui.txt dest=/usr/local/src/ backup=yes"</span></span><br></pre></td></tr></table></figure></p><p>控制所属的用户和指定权限<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m copy -a <span class="string">"src=/tmp/xiaohuihui/xiaohuihui.txt dest=/usr/local/src/ backup=yes owner=oracle group=oinstall mode=0640"</span></span><br></pre></td></tr></table></figure></p><h4 id="script模块"><a href="#script模块" class="headerlink" title="script模块"></a>script模块</h4><p>script模块能够实现远程服务器批量运行本地的shell脚本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m script -a <span class="string">"/usr/local/src/script"</span></span><br></pre></td></tr></table></figure></p><p>相当于<code>scp+shell</code>命令的组合。<br>当然，ansible还包括其他一些模块，更多的可以通过帮助问题查看。<br>使用方式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/python/bin/ansible-doc -l    <span class="comment">#查看总帮助</span></span><br><span class="line">/usr/local/python/bin/ansible-doc -s shell  <span class="comment">#查看shell模块的帮助</span></span><br><span class="line">/usr/local/python/bin/ansible-doc -s raw</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;ansible是自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。github地址为&lt;a href=&quot;https://github.com/ansible/ansible&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ansible/ansible&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="ansible" scheme="https://rosinelan.github.io/tags/ansible/"/>
    
      <category term="ping" scheme="https://rosinelan.github.io/tags/ping/"/>
    
      <category term="shell" scheme="https://rosinelan.github.io/tags/shell/"/>
    
      <category term="copy" scheme="https://rosinelan.github.io/tags/copy/"/>
    
  </entry>
  
  <entry>
    <title>saltstack实例</title>
    <link href="https://rosinelan.github.io/2018/07/04/saltstack%E5%AE%9E%E4%BE%8B/"/>
    <id>https://rosinelan.github.io/2018/07/04/saltstack实例/</id>
    <published>2018-07-04T09:16:43.000Z</published>
    <updated>2018-07-06T02:57:50.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="saltstack实例"><a href="#saltstack实例" class="headerlink" title="saltstack实例"></a>saltstack实例</h3><p>实现功能：通过http调用模块和runner。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaltServer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.session = requests.session()</span><br><span class="line">        self.token = self.gettoken()</span><br><span class="line">        print(self.token)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gettoken</span><span class="params">(self)</span>:</span></span><br><span class="line">        url = <span class="string">"http://192.168.145.129:8000/login"</span></span><br><span class="line">        header = &#123;<span class="string">"Accept"</span>: <span class="string">"application/json"</span>&#125;</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">"username"</span>: <span class="string">"saltapi"</span>,</span><br><span class="line">            <span class="string">"password"</span>: <span class="string">"saltapi"</span>,</span><br><span class="line">            <span class="string">"eauth"</span>: <span class="string">"pam"</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = self.session.post(url=url, headers=header, data=data)</span><br><span class="line">        text = res.text</span><br><span class="line">        result = json.loads(text)</span><br><span class="line">        token = result.get(<span class="string">"return"</span>)[<span class="number">0</span>].get(<span class="string">"token"</span>)</span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runmodules</span><span class="params">(self, minionid, func, args=None)</span>:</span></span><br><span class="line">        url = <span class="string">"http://192.168.145.129:8000"</span></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">"tgt"</span>: minionid,</span><br><span class="line">            <span class="string">"client"</span>: <span class="string">"local"</span>,</span><br><span class="line">            <span class="string">"fun"</span>: func,</span><br><span class="line">            <span class="string">"arg"</span>: args</span><br><span class="line">        &#125;</span><br><span class="line">        resultBean = dict()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = self.session.post(url=url, data=data)</span><br><span class="line">            text = res.text</span><br><span class="line">            data = json.loads(text).get(<span class="string">"return"</span>)</span><br><span class="line">            resultBean[<span class="string">'code'</span>] = <span class="number">0</span></span><br><span class="line">            resultBean[<span class="string">'message'</span>] = <span class="string">'success'</span></span><br><span class="line">            resultBean[<span class="string">'data'</span>] = data</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            resultBean[<span class="string">'code'</span>] = <span class="number">1</span></span><br><span class="line">            resultBean[<span class="string">'message'</span>] = <span class="string">'failed'</span></span><br><span class="line">            resultBean[<span class="string">'data'</span>] = e</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">return</span> resultBean</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runrunner</span><span class="params">(self, func, args=None)</span>:</span></span><br><span class="line">        url = <span class="string">"http://192.168.145.129:8000"</span></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">"client"</span>: <span class="string">"runner"</span>,</span><br><span class="line">            <span class="string">"fun"</span>: func,</span><br><span class="line">            <span class="string">"arg"</span>: args</span><br><span class="line">        &#125;</span><br><span class="line">        resultBean = dict()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = self.session.post(url=url, data=data)</span><br><span class="line">            text = res.text</span><br><span class="line">            data = json.loads(text).get(<span class="string">"return"</span>)</span><br><span class="line">            resultBean[<span class="string">'code'</span>] = <span class="number">0</span></span><br><span class="line">            resultBean[<span class="string">'message'</span>] = <span class="string">'success'</span></span><br><span class="line">            resultBean[<span class="string">'data'</span>] = data</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            resultBean[<span class="string">'code'</span>] = <span class="number">1</span></span><br><span class="line">            resultBean[<span class="string">'message'</span>] = <span class="string">'failed'</span></span><br><span class="line">            resultBean[<span class="string">'data'</span>] = e</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">return</span> resultBean</span><br></pre></td></tr></table></figure></p><p>通过<code>test.py</code>调用查看结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> saltstack_api.util.saltapi <span class="keyword">import</span> SaltServer</span><br><span class="line"></span><br><span class="line">saltServer = SaltServer()</span><br><span class="line">data = saltServer.runmodules(<span class="string">"slave"</span>, <span class="string">"test.ping"</span>)</span><br><span class="line">print(data)</span><br><span class="line">data1 = saltServer.runrunner(<span class="string">"manage.status"</span>)</span><br><span class="line">print(data1)</span><br></pre></td></tr></table></figure></p><p>注意：需要有安装saltstack的服务器存在且服务已启用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;saltstack实例&quot;&gt;&lt;a href=&quot;#saltstack实例&quot; class=&quot;headerlink&quot; title=&quot;saltstack实例&quot;&gt;&lt;/a&gt;saltstack实例&lt;/h3&gt;&lt;p&gt;实现功能：通过http调用模块和runner。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="saltstack" scheme="https://rosinelan.github.io/tags/saltstack/"/>
    
      <category term="API" scheme="https://rosinelan.github.io/tags/API/"/>
    
      <category term="http调用" scheme="https://rosinelan.github.io/tags/http%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>saltstack(二)</title>
    <link href="https://rosinelan.github.io/2018/07/02/saltstack-%E4%BA%8C/"/>
    <id>https://rosinelan.github.io/2018/07/02/saltstack-二/</id>
    <published>2018-07-02T07:24:35.000Z</published>
    <updated>2018-07-03T12:04:18.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="saltstack-api"><a href="#saltstack-api" class="headerlink" title="saltstack-api"></a>saltstack-api</h3><p><code>salt-api</code>使用有2种方式，一种是函数形式，也就是通过python代码直接调用已经定义好的函数，第二种是封装好的http协议，启动一个服务端直接通过http访问。<br><a id="more"></a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>yum install -y salt-api</code></p><h4 id="函数形式调用"><a href="#函数形式调用" class="headerlink" title="函数形式调用"></a>函数形式调用</h4><p>使用<code>salt &#39;*&#39; sys.list_modules</code>可以查看所有可用的模块。  </p><h5 id="加载master配置文件"><a href="#加载master配置文件" class="headerlink" title="加载master配置文件"></a>加载master配置文件</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  salt.config</span><br><span class="line">master_opts = salt.config.client_config(‘/etc/salt/master’)</span><br><span class="line">print(master_opts)</span><br></pre></td></tr></table></figure><h5 id="加载minion配置文件"><a href="#加载minion配置文件" class="headerlink" title="加载minion配置文件"></a>加载minion配置文件</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> salt.config</span><br><span class="line">minion_opts = salt.config.minion_config(‘/etc/salt/minion’)</span><br><span class="line">print(minion_opts)</span><br></pre></td></tr></table></figure><h5 id="master执行模块"><a href="#master执行模块" class="headerlink" title="master执行模块"></a>master执行模块</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> salt.client</span><br><span class="line">client = salt.client.LocalClient()</span><br><span class="line">ret = client.cmd(<span class="string">'*'</span>, <span class="string">'test.ping'</span>)</span><br><span class="line"><span class="keyword">print</span> ret    <span class="comment">#输出结果：&#123;'slave': True&#125;</span></span><br></pre></td></tr></table></figure><p>cmd中命令格式<code>&#39;&lt;操作目标&gt;&#39;,&#39;&lt;模块&gt;&#39;,&#39;[参数]&#39;。  例：&#39;*&#39;,&#39;cmd.run&#39;,[&#39;df -h&#39;]</code><br>对于其他模块的API调用，只需要改变cmd命令即可。</p><ul><li>cmd模块<br><code>client.cmd(&#39;*&#39;, &#39;cmd.run&#39;, [&#39;free -m&#39;])</code><br>也可以一次执行多个模块或者传递多个参数<br><code>client.cmd(&#39;*&#39;, [&#39;cmd.run&#39;],[[&#39;df -h&#39;], [&#39;whoami&#39;]])</code><br><code>client.cmd(&#39;*&#39;, [&#39;test.ping&#39;, &#39;cmd.run&#39;],[[], [&#39;whoami&#39;]])</code>  </li><li>cp模块<br><code>client.cmd(&#39;*&#39;,&#39;cp.get_file&#39;,[&#39;salt://script/test.py&#39;,&#39;/minion/test.py&#39;])</code></li><li>cron模块<br><code>client.cmd(&#39;slave&#39;,&#39;cron.set_job&#39;,[&#39;root&#39;,&#39;*&#39;,&#39;*&#39;,&#39;*&#39;,&#39;*&#39;,1,&#39;/usr/local/weekly&#39;])</code></li><li>dnsutil模块<br><code>clietn.cmd(&#39;slave&#39;,&#39;dnsutil.hosts_append&#39;,[&#39;/etc/hosts&#39;,&#39;127.0.0.1&#39;,&#39;slave&#39;,&#39;slave2&#39;])</code></li><li>file模块<br><code>client.cmd(&#39;*&#39;,&#39;file.remove&#39;,[&#39;/tmp/foo&#39;])</code>  </li><li>iptables模块<br><code>client.cmd(&#39;*&#39;,&#39;iptables.append&#39;,[&#39;filter&#39;,&#39;INPUT&#39;,&#39;rule=\&#39;-p tcp --sport 80 -j ACCEPT\&#39;&#39;])</code></li><li>network模块<br><code>client.cmd(&#39;slave&#39;,&#39;network.ip_addrs&#39;)</code></li><li>pkg模块<br><code>client.cmd(&#39;*&#39;,&#39;pkg.remove&#39;,[&#39;php&#39;])</code></li><li>service模块<br><code>client.cmd(&#39;*&#39;,&#39;service.stop&#39;,[&#39;nginx&#39;])</code><h5 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h5>对于执行时间过长，没法直接返回的，可以通过异步执行的形式进行返回。<br>使用<code>cmd_async</code>和<code>get_cache_returns(jid)</code>实现。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> salt.client</span><br><span class="line">local = salt.client.LocalClient(<span class="string">'/etc/salt/master'</span>)</span><br><span class="line">jid = local.cmd_async(<span class="string">'*'</span>, <span class="string">'network.ip_addrs'</span>)</span><br><span class="line">local.get_cache_returns(jid)    <span class="comment">#输出结果：&#123;'slave': &#123;'ret': ['192.168.145.130']&#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="minion端执行salt命令"><a href="#minion端执行salt命令" class="headerlink" title="minion端执行salt命令"></a>minion端执行salt命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import salt.client</span><br><span class="line">caller = salt.client.Caller()</span><br><span class="line">caller.cmd(&apos;test.ping&apos;)</span><br></pre></td></tr></table></figure><p>其执行类似于sal-call，可以在minion端执行命令。  </p><h5 id="salt-runner使用"><a href="#salt-runner使用" class="headerlink" title="salt.runner使用"></a>salt.runner使用</h5><p>在master端<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> salt.runner</span><br><span class="line"><span class="keyword">import</span> salt.config</span><br><span class="line">__opts__ = salt.config.client_config(<span class="string">'/etc/salt/master'</span>)</span><br><span class="line">runnermaster = salt.runner.RunnerClient(__opts__)</span><br><span class="line">runnermaster.cmd(<span class="string">'manage.status'</span>)</span><br></pre></td></tr></table></figure></p><h5 id="grains"><a href="#grains" class="headerlink" title="grains"></a>grains</h5><p>在master端<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> salt.config</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> salt.loader</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__opts__ = salt.config.minion_config(<span class="string">"/etc/salt/minion"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__grains__ = salt.loader.grains(__opts__)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__grains__[<span class="string">'id'</span>]</span><br><span class="line"><span class="string">'master'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__grains__[<span class="string">'server_id'</span>]</span><br><span class="line"><span class="number">685245236</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> salt.config</span><br><span class="line"><span class="keyword">import</span> salt.loader</span><br><span class="line"></span><br><span class="line">__opts__ = salt.config.minion_config(<span class="string">'/etc/salt/minion'</span>)</span><br><span class="line">__grains__ = salt.loader.grains(__opts__)</span><br><span class="line">__opts__[<span class="string">'grains'</span>] = __grains__</span><br><span class="line">__utils__ = salt.loader.utils(__opts__)</span><br><span class="line">__salt__ = salt.loader.minion_mods(__opts__, utils=__utils__)  <span class="comment">#交互模式无法使用，原因见下面</span></span><br><span class="line">__salt__[<span class="string">'test.ping'</span>]()</span><br></pre></td></tr></table></figure><h5 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h5><p>在python交互环境中，下面这些内置变量是不生效，只要在自定义的模块中使用才生效。<br><code>__opts__</code>  配置文件<br><code>__salt__</code>  执行modules<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__salt__[<span class="string">'cmd.run'</span>](<span class="string">'fdisk -l'</span>)        <span class="comment">##__salt__[模块](参数)</span></span><br><span class="line">__salt__[<span class="string">'network.ip_addrs'</span>]()</span><br></pre></td></tr></table></figure></p><p>说明：<strong>salt</strong>是个字典，它里面装了minion上所有的modules，<strong>salt</strong>的key是一个个的模块名称，value则是模块里面的一个个函数<br><code>__pillar__</code> pillar<br><code>__grains__</code> grains<br><code>__context__</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="string">'cp.fileclient'</span> <span class="keyword">in</span> __context__:</span><br><span class="line">    __context__[<span class="string">'cp.fileclient'</span>] = salt.fileclient.get_file_client(__opts__)</span><br></pre></td></tr></table></figure></p><h4 id="http-api"><a href="#http-api" class="headerlink" title="http api"></a>http api</h4><p>salt-api使用cherrypy框架和salt接口实现的。  </p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p><code>yum -y install salt-api</code></p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>创建用于salt-api的用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -M -s /sbin/nologin/ saltapi</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"saltapi"</span> | passwd saltapi --stdin</span><br></pre></td></tr></table></figure></p><p>master配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/salt/master +12</span><br><span class="line">default_include: master.d/*.conf  <span class="comment">#注释取消</span></span><br></pre></td></tr></table></figure></p><p>创建配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/salt/master.d/</span><br><span class="line">touch api.conf eauth.conf</span><br></pre></td></tr></table></figure></p><p>更新配置文件内容<br>cat /etc/salt/master.d/api.conf<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rest_cherrypy:</span><br><span class="line">  port: 8000</span><br><span class="line">  disable_ssl: True</span><br><span class="line">  <span class="comment">#ssl_crt: /etc/salt/keycrt/cert.pem</span></span><br><span class="line">  <span class="comment">#ssl_key: /etc/salt/keycrt/key.pem</span></span><br></pre></td></tr></table></figure></p><p>cat /etc/salt/master.d/eauth.conf<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">external_auth:</span><br><span class="line">  pam:</span><br><span class="line">    saltapi:    <span class="comment">#此处为前面创建的用户</span></span><br><span class="line">      - .*</span><br><span class="line">      - <span class="string">'@wheel'</span></span><br><span class="line">      - <span class="string">'@runner'</span></span><br></pre></td></tr></table></figure></p><p>启动salt-api<br><code>systemctl start salt-api</code><br>启动之后可以看到8000端口已经在监听状态，且salt-api服务已启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@master master.d]<span class="comment"># netstat -lntp|grep 8000</span></span><br><span class="line">tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      24008/python        </span><br><span class="line">[root@master master.d]<span class="comment"># ps aux|grep salt-api</span></span><br><span class="line">root      23998  0.0  2.8 295044 28012 ?        Ss   19:22   0:00 /usr/bin/python /usr/bin/salt-api</span><br><span class="line">root      24008  0.3  3.1 1673212 31092 ?       Sl   19:22   0:01 /usr/bin/python /usr/bin/salt-api</span><br><span class="line">root      24231  0.0  0.0 112664   972 pts/0    R+   19:28   0:00 grep --color=auto salt-api</span><br></pre></td></tr></table></figure></p><p>上面配置文件使用的是http协议，若要使用https协议，则需要生成证书<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/salt</span><br><span class="line">mkdir keycrt</span><br><span class="line"><span class="built_in">cd</span> keycrt</span><br><span class="line">openssl genrsa –out key.pem 4096</span><br><span class="line">openssl req –new –x 509 –key key.pem –out cert.pem –days 1826</span><br></pre></td></tr></table></figure></p><p>同时更新<code>/etc/salt/master.d/api.conf</code>内容即可。<br>cat /etc/salt/master.d/api.conf<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rest_cherrypy:</span><br><span class="line">  port: 8000</span><br><span class="line">  <span class="comment">#disable_ssl: True</span></span><br><span class="line">  ssl_crt: /etc/salt/keycrt/cert.pem</span><br><span class="line">  ssl_key: /etc/salt/keycrt/key.pem</span><br></pre></td></tr></table></figure></p><h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><p>登录，获取token<br>说明：saltapi重启token会发生变化，不重启则不会变化。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -k http://192.168.145.129:8000/login -H <span class="string">"Accept: application/x-yaml"</span>  -d username=<span class="string">'saltapi'</span>  -d password=<span class="string">'saltapi'</span> -d eauth=<span class="string">'pam'</span></span><br></pre></td></tr></table></figure></p><p>执行结果如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>:</span><br><span class="line">- eauth: pam</span><br><span class="line">  expire: <span class="number">1530662531.464414</span></span><br><span class="line">  perms:</span><br><span class="line">  - .*</span><br><span class="line">  - <span class="string">'@wheel'</span></span><br><span class="line">  - <span class="string">'@runner'</span></span><br><span class="line">  start: <span class="number">1530619331.464413</span></span><br><span class="line">  token: <span class="number">25</span>a29f8fd30c611f399370ab1be8a0b4f83d1e06</span><br><span class="line">  user: saltapi</span><br></pre></td></tr></table></figure></p><p>使用获取的token查询硬盘使用情况<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -k http://192.168.145.129:8000 \</span><br><span class="line">        -H <span class="string">"Accept: application/x-yaml"</span> \</span><br><span class="line">        -H <span class="string">"X-Auth-Token: 25a29f8fd30c611f399370ab1be8a0b4f83d1e06"</span> \</span><br><span class="line">        -d client=<span class="built_in">local</span> \</span><br><span class="line">        -d tgt=<span class="string">'*'</span> \</span><br><span class="line">        -d fun=<span class="string">'status.diskusage'</span></span><br></pre></td></tr></table></figure></p><p>模块调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -k http://192.168.145.129:8000 \</span><br><span class="line">        -H <span class="string">"Accept: application/x-yaml"</span> \</span><br><span class="line">        -H <span class="string">"X-Auth-Token: 25a29f8fd30c611f399370ab1be8a0b4f83d1e06"</span> \</span><br><span class="line">        -d client=<span class="built_in">local</span> \</span><br><span class="line">        -d tgt=<span class="string">'*'</span> \</span><br><span class="line">        -d fun=<span class="string">'cmd.run'</span> \</span><br><span class="line">        -d arg=<span class="string">"free -m"</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;saltstack-api&quot;&gt;&lt;a href=&quot;#saltstack-api&quot; class=&quot;headerlink&quot; title=&quot;saltstack-api&quot;&gt;&lt;/a&gt;saltstack-api&lt;/h3&gt;&lt;p&gt;&lt;code&gt;salt-api&lt;/code&gt;使用有2种方式，一种是函数形式，也就是通过python代码直接调用已经定义好的函数，第二种是封装好的http协议，启动一个服务端直接通过http访问。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="saltstack" scheme="https://rosinelan.github.io/tags/saltstack/"/>
    
      <category term="API" scheme="https://rosinelan.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>saltstack</title>
    <link href="https://rosinelan.github.io/2018/06/27/saltstack/"/>
    <id>https://rosinelan.github.io/2018/06/27/saltstack/</id>
    <published>2018-06-27T02:00:09.000Z</published>
    <updated>2018-07-03T08:41:54.568Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>saltstack是一个新的基础平台管理工具，只需要花费几分钟即可运行起来，可以支撑管理上万台服务器的规模，数秒钟即可完成数据的传递。<br><a id="more"></a><br>saltstack能够维护预定义状态的远程节点，也可以在远程节点执行命令和查询数据；开发的目的是为远程执行提供孔的解决方案，并使远程执行变得更好、更快、更简单。<br>saltstack使用python开发，同时也支持restAPI，方便二次开发以及和其它普通集成，同时官方也发布了一个web管理界面halite。  </p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>速度快，saltstack使用消息队列zeroMQ传输数据，比ansible快大约40倍。  </li><li>C/S架构，执行信息比较稳定，不同意丢失信息或出现主机失联的情况。  </li><li>python开发，方便理解和自定义模块。  <h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4>saltstack中服务端叫做<code>master</code>，客户端叫做<code>minion</code>，都是以demon模式运行，一直监听配置文件中定义的<code>ret_port</code>(saltstack客户端与服务端通信的端口，负责接收客户端发送过来的结果，默认4506端口)和<code>publish_port</code>(saltstack的消息发布系统，默认4505端口)的端口。当minion运行时会自动连接到配置文件中定义的master地址ret_port端口进行连接认证。<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3>以<code>centos7.3.1611</code>为例，使用yum安装。也可以通过源码编译、pip、salt-bootstrap等方式安装。    <h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure></li></ol><h4 id="epel源配置"><a href="#epel源配置" class="headerlink" title="epel源配置"></a>epel源配置</h4><p>yum安装salstack使用epel源。<br><code>yum install epel-release</code>  </p><h4 id="安装master"><a href="#安装master" class="headerlink" title="安装master"></a>安装master</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install salt-master</span><br></pre></td></tr></table></figure><h4 id="安装minion"><a href="#安装minion" class="headerlink" title="安装minion"></a>安装minion</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install salt-minion</span><br></pre></td></tr></table></figure><p>客户端中配置master地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/salt/minion +16</span><br><span class="line">master: 192.168.145.129</span><br></pre></td></tr></table></figure></p><p>也可以使用sed命令实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &apos;s@#manster:.*@manster: 192.168.145.219@&apos; /etc/salt/minion</span><br></pre></td></tr></table></figure></p><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><p>master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable salt-master</span><br><span class="line">systemctl start salt-master</span><br></pre></td></tr></table></figure></p><p>minion<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable salt-minion</span><br><span class="line">systemctl start salt-minion</span><br></pre></td></tr></table></figure></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>启动服务之后，客户端的/etc/salt下面产生一个<code>minion_id</code>文件(minion配置文件中id，不配置默认为主机名)同时还会产生一个pki文件，里面存放minion的公钥和私钥。<br>master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# tree -L 3 /etc/salt</span><br><span class="line">/etc/salt</span><br><span class="line">├── master</span><br><span class="line">└── pki</span><br><span class="line">    └── master</span><br><span class="line">        ├── master.pem</span><br><span class="line">        ├── master.pub</span><br><span class="line">        ├── minions</span><br><span class="line">        ├── minions_autosign</span><br><span class="line">        ├── minions_denied</span><br><span class="line">        ├── minions_pre</span><br><span class="line">        └── minions_rejected</span><br></pre></td></tr></table></figure></p><p>minion<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@slave ~]# tree -L 3 /etc/salt</span><br><span class="line">/etc/salt</span><br><span class="line">├── minion</span><br><span class="line">├── minion.d</span><br><span class="line">├── minion_id</span><br><span class="line">└── pki</span><br><span class="line">    └── minion</span><br><span class="line">        ├── minion.pem</span><br><span class="line">        └── minion.pub</span><br></pre></td></tr></table></figure></p><h4 id="master与minion认证"><a href="#master与minion认证" class="headerlink" title="master与minion认证"></a>master与minion认证</h4><p>minion在第一次启动时，会在/etc/salt/pki/minion/（该路径在/etc/salt/minion里面设置）下自动生成minion.pem（private key）和 minion.pub（public key），然后将 minion.pub发送给master。master在接收到minion的public key后，通过salt-key命令accept minion public key，这样在master的/etc/salt/pki/master/minions下的将会存放以minion id命名的 public key，然后master就能对minion发送指令了。<br>认证命令使用<code>salt-key --help</code>可以看到详细使用方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># salt-key -L  #查看当前证书签证情况</span></span><br><span class="line">Accepted Keys:</span><br><span class="line">Denied Keys:</span><br><span class="line">Unaccepted Keys:</span><br><span class="line">slave</span><br><span class="line">Rejected Keys:</span><br><span class="line">[root@master ~]<span class="comment"># salt-key -A -y #接受所有证书</span></span><br><span class="line">The following keys are going to be accepted:</span><br><span class="line">Unaccepted Keys:</span><br><span class="line">slave</span><br><span class="line">Key <span class="keyword">for</span> minion slave accepted.</span><br><span class="line">[root@master ~]<span class="comment"># salt-key -L</span></span><br><span class="line">Accepted Keys:</span><br><span class="line">slave</span><br><span class="line">Denied Keys:</span><br><span class="line">Unaccepted Keys:</span><br><span class="line">Rejected Keys:</span><br></pre></td></tr></table></figure></p><p>其他用法<br><code>salt-key -D</code> 删除所有认证主机证书<br><code>salt-key -d id -y</code> 删除指定id的证书<br><code>salt-key -a id</code> 接受指定id的证书</p><h4 id="远程执行"><a href="#远程执行" class="headerlink" title="远程执行"></a>远程执行</h4><ol><li>-E， –pcre，通过正则表达式进行匹配<br><code>salt -E &#39;web(9|10)*&#39; test.ping -t 1</code></li><li>-L, –list, 主机id进行过滤<br><code>salt -L &quot;*app*&quot; cmd.run &quot;df -h&quot;</code></li><li>-G, –grain, 根据被控主机的grains信息进行过滤<br><code>salt -G &#39;role:nginx&#39; cmd.run &quot;ls /export&quot;</code></li><li>-I, –pillar， 根据被控主机的pillar信息进行过滤<br><code>salt -I &#39;myname:xiang&#39; test.ping -t 5</code></li><li>-S, –ipcidr, 根据minion的ip地址进行匹配<br><code>salt -S 192.168.1.1 test.ping</code><br><code>salt -S 192.168.1.0/24 test.ping</code><br><code>salt -S 192.168.0.0/16 test.ping</code><br><code>salt -S 192.0.0.0/8 test.ping</code></li><li>检查客户端是否挂掉<br><code>salt-run manage.status |head</code><br><code>salt-run manage.down</code><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3>master和minion配置文件分别为<code>/etc/salt/master</code>和<code>/etc/salt/minion</code>，内容基本一致，主要配置项说明。  </li></ol><ul><li>interface<br>默认是0.0.0.0(所有网络接口都可以访问)。<br>绑定本地接口<br><code>interface: 192.168.0.1</code></li><li>publish_port<br>默认4505，提供服务的端口。<br><code>publish_port: 4505</code></li><li>user<br>默认是root<br><code>user: root</code></li><li>ret_port<br>默认是4506，返回服务器使用的端口。<br>返回服务器指salt接收执行返回结果和命令执行状况的服务器。<br><code>ret_port: 4506</code>  </li><li>auto_accept<br>默认是False。设置为<code>True</code>之后master将会自动接收所有来自minion端的公钥请求。<br><code>auto_accept: False</code><h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3></li><li>Runner模块<br>在master端执行<code>salt-run</code>。<br>使用案例<br>检测各minion端是否在线 <code>salt-run manage.status</code></li><li>Module模块<br>通过master同步到minion端，在minion端执行<code>salt-call saltutil.sync_modules</code>。<br><code>salt-call saltutil.sync_all</code>：包括beacons\clouds\engines\grains\log_handler\modiles\output\proxymodules\renderers\returners\sdb\states\utils。</li><li>cmd模块<br>功能：实现远程的命令行调用执行（默认具备root操作权限）<br>示例：<br><code>salt &#39;*&#39; cmd.run &quot;df -h&quot;</code></li><li>ping模块<br><code>salt &#39;*&#39; test.ping -t 5</code></li><li>cp模块<br>功能：实现远程文件、目录的复制，以及下载URL文件等操作<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_roots:  </span><br><span class="line">    base:  </span><br><span class="line">    - /export/salt/root</span><br></pre></td></tr></table></figure></li></ul><p>salt根目录：在master中file_roots定义的路径，salt://test.txt相当于/export/salt/root/test.txt<br><code>salt &#39;wms5test1.app.172.17.23.176&#39; cp.get_file salt://nscd.conf /tmp/aaa.txt</code>  </p><ul><li><p>cron模块<br>功能：实现minion端主机的crontab操作<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">salt &apos;*&apos; cron.raw_cron root     （查看定时任务）</span><br><span class="line">salt &apos;*&apos; cron.set_job root &apos;*&apos; &apos;*&apos; &apos;*&apos; &apos;*&apos; 1 /export/scripts/rm_log.sh </span><br><span class="line">salt &apos;*&apos; cron.rm_job root /export/scripts/rm_log.sh</span><br></pre></td></tr></table></figure></li><li><p>dnsutil模块<br>功能：实现minion端主机通用的DNS操作<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salt &apos;*&apos; dnsutil.hosts_append /etc/hosts 127.0.0.1 aaa.com</span><br><span class="line">salt &apos;*&apos; dnsutil.hosts_remove /etc/hosts aaa.com</span><br></pre></td></tr></table></figure></li><li><p>file模块<br>功能：实现minion端主机常见的文件操作，包括文件读写、权限、查找、校验<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">salt &apos;*&apos; file.chown /etc/passwd root root</span><br><span class="line">salt &apos;*&apos; file.copy /path/to/src /path/to/dst</span><br><span class="line">salt &apos;*&apos; file.file_exists /etc/hosts</span><br><span class="line">salt &apos;*&apos; file.directory_exists /etc/</span><br><span class="line">salt &apos;*&apos; file.get_mod /etc/passwd</span><br><span class="line">salt &apos;*&apos; file.set_mod /etc/passwd 0644</span><br><span class="line">salt &apos;*&apos; file.mkdir /tmp/test</span><br><span class="line">salt &apos;*&apos; file.sed /export/servers/nginx/conf/nginx.conf &apos;debug&apos; &apos;warn&apos;</span><br><span class="line">salt &apos;*&apos; file.append /tmp/test.txt &quot;welcome xiang&quot;</span><br><span class="line">salt &apos;*&apos; file.remove /tmp/1.txt</span><br></pre></td></tr></table></figure></li><li><p>network模块<br>功能：实现minion端主机网络信息查看<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">salt &apos;*&apos; network.dig www.qq.com</span><br><span class="line">salt &apos;*&apos; network.ping www.qq.com</span><br><span class="line">salt &apos;*&apos; network.ip_addrs</span><br></pre></td></tr></table></figure></li><li><p>pkg包管理模块<br>功能：实现minion端主机程序包管理，如：yum等<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">salt &apos;*&apos; pkg.install php</span><br><span class="line">salt &apos;*&apos; pkg.remove php</span><br><span class="line">salt &apos;*&apos; pkg.upgrade    （升级所有的软件包）</span><br></pre></td></tr></table></figure></li><li><p>service模块<br>功能：实现minion端主机服务管理<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">salt &apos;*&apos; service.enable nginx</span><br><span class="line">salt &apos;*&apos; service.disable nginx</span><br><span class="line">salt &apos;*&apos; service.restart nginx</span><br></pre></td></tr></table></figure></li><li><p>Grains模块<br><code>Grains</code>在minion上定义的。<br>它是在minion启动时搜集一些信息，如操作系统类型，网卡，内核版本，cpu架构等。<br><code>salt &quot;*&quot; grains.ls</code>    列出所有grains项目名字<br><code>salt &quot;*app.*&quot; grains.items</code>  列出所有grains项目以及值<br>grains的信息并不是动态的，并不会实时变化，它只是在minion启动时收集到的。<br>我们可以根据grains收集到的一些信息，做一些配置管理工作<br>在minion上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/salt/grains</span><br><span class="line">role: nginx</span><br><span class="line">env: test</span><br></pre></td></tr></table></figure></li></ul><p>重启service<br><code>systemctl restart salt-minion</code><br>获取grians：<br><code>salt &quot;*&quot; grains.item role env</code><br>或者：<br><code>salt -G &quot;*&quot; role:nginx cmd.run &quot;hostname“</code><br><code>salt ‘*’grains.items</code><br>上面使用的是在minion端进行配置，但是机器多了配置起来比较麻烦。<br>下面在master端进行配置，然后分发给minion端。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mkdir /srv/salt/_grains</span><br><span class="line">cd /srv/salt/_grains/</span><br><span class="line">vi mytest.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># _*_ coding:utf-8 _*_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_test</span><span class="params">()</span>:</span></span><br><span class="line">    grains = &#123;&#125;</span><br><span class="line">    grains[<span class="string">'say'</span>] = <span class="string">'hello world'</span></span><br><span class="line">    <span class="keyword">return</span> grains</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_test1</span><span class="params">()</span>:</span></span><br><span class="line">    grains = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> os.popen(<span class="string">'free -m'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        grains[<span class="string">'mem_usage'</span>] = f.read()</span><br><span class="line">    <span class="keyword">return</span> grains</span><br></pre></td></tr></table></figure></p><p>同步至客户端<br><code>salt &#39;*&#39; saltutil.sync_all</code><br>master端刷新模块<br><code>salt &#39;*&#39; sys.reload_modules</code><br>master查看客户端自定义的监控项<br><code>salt &quot;*&quot; grains.item say</code><br><code>salt &quot;*&quot; grains.item mem_usage</code></p><ul><li>Pillar模块<br>pillar 和 grains 不一样，是在 master 上定义的，并且是针对 minion 定义的一些信息。像一些比较重要的数据（密码）可以存在 pillar 里，还可以定义变量等。<br>首先我们查看master端pillars组件是否在开启状态<br>查看/etc/salt/master pillar_ops: True 就代表pillars在开启状态，否则我们手动修改。<br>新的版本默认已经开启。<br>查看minion端的pillar信息  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master minions]# salt &apos;*&apos; pillar.items</span><br><span class="line">slave:</span><br><span class="line">    ----------</span><br></pre></td></tr></table></figure></li></ul><p>master端自定义配置pillar<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# vi /etc/salt/master +529    // 找到如下内容，去掉#号</span><br><span class="line">pillar_roots:</span><br><span class="line">  base:</span><br><span class="line">    - /srv/pillar</span><br><span class="line">[root@master ~]#  mkdir /srv/pillar</span><br><span class="line">[root@master ~]# vi /srv/pillar/test.sls    // 自定义配置文件，内容如下</span><br><span class="line">conf: /etc/mum.conf</span><br><span class="line">myname: primum est</span><br><span class="line">[root@master ~]# vi /srv/pillar/top.sls    // 总入口文件，内容如下</span><br><span class="line">base:</span><br><span class="line">  &apos;client1&apos;:</span><br><span class="line">    - test</span><br></pre></td></tr></table></figure></p><p>重启master<br><code>systemctl restart salt-master</code><br>注意：当更改完 pillar 配置文件后，我们可以通过刷新 pillar 配置来获取新的 pillar 状态。<br><code>salt &#39;*&#39; saltutil.refresh_pillar</code><br>验证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master pillar]# salt &apos;slave&apos; pillar.items</span><br><span class="line">slave:</span><br><span class="line">    ----------</span><br><span class="line">    conf:</span><br><span class="line">        /etc/mum.conf</span><br><span class="line">    myname:</span><br><span class="line">        primum est</span><br></pre></td></tr></table></figure></p><p>上述简单介绍了一部分模块的内容，更多更详细可以点击<a href="https://docs.saltstack.com/en/latest/contents.html" target="_blank" rel="noopener">SALTSTACK</a>查看官方文档介绍。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;saltstack是一个新的基础平台管理工具，只需要花费几分钟即可运行起来，可以支撑管理上万台服务器的规模，数秒钟即可完成数据的传递。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="saltstack" scheme="https://rosinelan.github.io/tags/saltstack/"/>
    
      <category term="master" scheme="https://rosinelan.github.io/tags/master/"/>
    
      <category term="grains" scheme="https://rosinelan.github.io/tags/grains/"/>
    
      <category term="pillar" scheme="https://rosinelan.github.io/tags/pillar/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫(三)</title>
    <link href="https://rosinelan.github.io/2018/06/25/python%E7%88%AC%E8%99%AB-%E4%B8%89/"/>
    <id>https://rosinelan.github.io/2018/06/25/python爬虫-三/</id>
    <published>2018-06-25T01:13:08.000Z</published>
    <updated>2018-06-25T14:18:53.254Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>Beautiful Soup</code>是python的一个库，主要功能是从网页抓取数据。<br>它是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间。<br>通过使用该库，可以不编写正则就可以方便的实现网页信息的抓取。<br><a id="more"></a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="Beautiful-Soup安装"><a href="#Beautiful-Soup安装" class="headerlink" title="Beautiful Soup安装"></a>Beautiful Soup安装</h5><p><code>Beautiful Soup</code>安装很简单，直接<code>pip install beautifulsoup4</code>即可安装。  </p><h5 id="解析器安装"><a href="#解析器安装" class="headerlink" title="解析器安装"></a>解析器安装</h5><p>Beautiful Soup支持Python标准库中的HTML解析器,还支持一些第三方的解析器，如果我们不安装它，则 Python 会使用 Python默认的解析器，lxml 解析器更加强大，速度更快，推荐安装。  </p><table><thead><tr><th>解析器</th><th style="text-align:left">使用方法</th><th style="text-align:left">优势</th><th style="text-align:left">劣势</th></tr></thead><tbody><tr><td>Python标准库</td><td style="text-align:left"><code>BeautifulSoup(markup, &quot;html.parser&quot;)</code></td><td style="text-align:left">ython的内置标准库<br>执行速度适中<br>文档容错能力强</td><td style="text-align:left">ython 2.7.3 or 3.2.2)前 的版本中文档容错能力差</td></tr><tr><td>lxml HTML 解析器</td><td style="text-align:left"><code>BeautifulSoup(markup, &quot;lxml&quot;)</code></td><td style="text-align:left">速度快<br>文档容错能力强</td><td style="text-align:left">需要安装C语言库</td></tr><tr><td>lxml XML 解析器</td><td style="text-align:left"><code>BeautifulSoup(markup, [&quot;lxml&quot;, &quot;xml&quot;])</code> <code>BeautifulSoup(markup, &quot;xml&quot;)</code></td><td style="text-align:left">速度快<br>唯一支持XML的解析器</td><td style="text-align:left">需要安装C语言库</td></tr><tr><td>html5lib</td><td style="text-align:left"><code>BeautifulSoup(markup, &quot;html5lib&quot;)</code></td><td style="text-align:left">最好的容错性<br>以浏览器的方式解析文档<br>生成HTML5格式的文档</td><td style="text-align:left">速度慢<br>不依赖外部扩展</td></tr></tbody></table><p>lxml安装<code>pip install lxml</code><br>html5lib安装<code>pip install html5lib</code>  </p><h4 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">print(soup.prettify())</span><br><span class="line">print(soup.title)</span><br><span class="line">print(soup.title.name)</span><br><span class="line">print(soup.title.string)</span><br><span class="line">print(soup.title.parent.name)</span><br><span class="line">print(soup.p)</span><br><span class="line">print(soup.p[<span class="string">"class"</span>])</span><br><span class="line">print(soup.a)</span><br><span class="line">print(soup.find_all(<span class="string">'a'</span>))</span><br><span class="line">print(soup.find(id=<span class="string">'link3'</span>))</span><br></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;title&gt;</span><br><span class="line">   The Dormouse<span class="string">'s story</span></span><br><span class="line"><span class="string">  &lt;/title&gt;</span></span><br><span class="line"><span class="string"> &lt;/head&gt;</span></span><br><span class="line"><span class="string"> &lt;body&gt;</span></span><br><span class="line"><span class="string">  &lt;p class="title"&gt;</span></span><br><span class="line"><span class="string">   &lt;b&gt;</span></span><br><span class="line"><span class="string">    The Dormouse'</span>s story</span><br><span class="line">   &lt;/b&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class="story"&gt;</span><br><span class="line">   Once upon a time there were three little sisters; <span class="keyword">and</span> their names were</span><br><span class="line">   &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;</span><br><span class="line">    Elsie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ,</span><br><span class="line">   &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;</span><br><span class="line">    Lacie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   <span class="keyword">and</span></span><br><span class="line">   &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;</span><br><span class="line">    Tillie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ;</span><br><span class="line"><span class="keyword">and</span> they lived at the bottom of a well.</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class="story"&gt;</span><br><span class="line">   ...</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;title&gt;The Dormouse<span class="string">'s story&lt;/title&gt;</span></span><br><span class="line"><span class="string">title</span></span><br><span class="line"><span class="string">The Dormouse'</span>s story</span><br><span class="line">head</span><br><span class="line">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span><br><span class="line">[<span class="string">'title'</span>]</span><br><span class="line">&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span><br><span class="line">[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span><br><span class="line">&lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>注意，此处使用解析器为<code>lxml</code>，需要提前安装。<br>使用BeautifulSoup解析这段代码,能够得到一个 BeautifulSoup 的对象,并能按照标准的缩进格式的结构输出。<br>同时我们通过下面代码可以分别获取所有的链接，以及文字内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> soup.find_all(<span class="string">'a'</span>):</span><br><span class="line">    print(link.get(<span class="string">'href'</span>))</span><br><span class="line"></span><br><span class="line">print(soup.get_text())</span><br></pre></td></tr></table></figure></p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ul><li>标签选择器<br>在上面的代码中有<code>soup.title</code> <code>soup.head</code> <code>soup.p</code>。<br>通过<code>soup.标签名</code>可以得到标签的内容。当文旦中有多个这样的标签，返回第一个标签的内容。  </li><li>获取名称<br>通过<code>soup.title.name</code>可以得到title标签的名称。  </li><li>获取属性<br>获取p标签的name属性方式<br><code>soup.p.attrs[&#39;name&#39;]</code><br><code>soup.p[&#39;name&#39;]</code>  </li><li>获取内容<br><code>soup.p.string</code>可以得到第一个p标签的内容。  </li><li>嵌套选择<br><code>soup.head.title.string</code>  </li><li><p>子节点和子孙节点<br><strong>contents</strong><br><code>soup.p.contents</code> 将p标签下的所有子标签存到一个列表中<br><strong>children</strong><br><code>soup.p.children</code> 将p标签下的所有子标签放到一个可迭代对象<br>此处content和children得到的结果相同，只是一个为列表，一个是可迭代对象，需要通过循环读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,child <span class="keyword">in</span> enumerate(soup.p.children):</span><br><span class="line">    print(i,child)</span><br></pre></td></tr></table></figure></li><li><p>父节点<br><code>soup.a.parent</code> 获取父节点信息<br>通过list(enumerate(soup.a.parents))可以获取祖先节点，这个方法返回的结果是一个列表，会分别将a标签的父节点的信息存放到列表中，以及父节点的父节点也放到列表中，并且最后还会讲整个文档放到列表中，所有列表的最后一个元素以及倒数第二个元素都是存的整个文档的信息  </p><h4 id="标准选择器"><a href="#标准选择器" class="headerlink" title="标准选择器"></a>标准选择器</h4></li><li>fina_all<br>find_all(name,attrs,recursive,text,<strong>kwargs)<br>可以根据标签名，属性，内容查找文档</strong>name<strong><br><code>soup.find_all(&#39;ul&#39;)</code> 返回列表</strong>attrs**<br>attrs可以传入字典的方式来查找标签，但是这里有个特殊的就是class,因为class在python中是特殊的字段，所以如果想要查找class相关的可以更改attrs={‘class_’:’element’}或者soup.find_all(‘’,{“class”:”element})，特殊的标签属性可以不写attrs，例如id  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(attrs=&#123;<span class="string">'id'</span>: <span class="string">'list-1'</span>&#125;)</span><br><span class="line">soup.find_all(attrs=&#123;<span class="string">'name'</span>: <span class="string">'elements'</span>&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>text</strong><br><code>soup.find_all(text=&#39;Foo&#39;)</code><br>结果返回的是列表形式的查到的所有的text=’Foo’的文本  </p><ul><li>find<br>find(name,attrs,recursive,text,**kwargs)<br>find返回的匹配结果的第一个元素<br>还有其他一些方法<br>find_parents()返回所有祖先节点，find_parent()返回直接父节点<br>find_next_siblings()返回后面所有兄弟节点，find_next_sibling()返回后面第一个兄弟节点<br>find_previous_siblings()返回前面所有兄弟节点，find_previous_sibling()返回前面第一个兄弟节点<br>find_all_next()返回节点后所有符合条件的节点, find_next()返回第一个符合条件的节点<br>find_all_previous()返回节点后所有符合条件的节点, find_previous()返回第一个符合条件的节点  <h4 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h4>通过select()直接传入CSS选择器就可以完成选择<br><code>.</code>表示class<br><code>#</code>表示id<br><code>标签1，标签2</code>找到所有的标签1和标签2<br><code>标签1 标签2</code> 找到标签1内部的所有的标签2<br><code>[atrr=value]</code> 找到具有某个属性的所有标签  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">'.panel .panel-heading'</span>)</span><br><span class="line">soup.select(<span class="string">'ul li'</span>)</span><br><span class="line">soup.select(<span class="string">'#list-2 .element'</span>)</span><br></pre></td></tr></table></figure></li></ul><p><strong>获取内容</strong><br>通过<code>get_text()</code>获取文本内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> soup.select(<span class="string">'li'</span>):</span><br><span class="line">    print(li.get_text())</span><br></pre></td></tr></table></figure></p><p><strong>获取属性</strong><br>通过[属性名]或者attrs[属性名]获取属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ul <span class="keyword">in</span> soup.select(<span class="string">'ul'</span>):</span><br><span class="line">    print(ul[<span class="string">'id'</span>])</span><br><span class="line">    print(ul.attrs[<span class="string">'id'</span>])</span><br></pre></td></tr></table></figure></p><p>更多关于<code>Beautiful Soup</code>内容可以点击<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" target="_blank" rel="noopener">Beautiful Soup 4.2.0 文档</a>查看官方文档介绍。<br>点击<a href="https://cuiqingcai.com/1319.html" target="_blank" rel="noopener">Python爬虫利器二之Beautiful Soup的用法</a>查看更多总结。<br>点击<a href="http://www.cnblogs.com/zhaof/" target="_blank" rel="noopener"> python修行路</a>查看更多内容。  </p><h3 id="webdriver"><a href="#webdriver" class="headerlink" title="webdriver"></a>webdriver</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Selenium 是自动化测试工具。它支持各种浏览器，包括 Chrome，Safari，Firefox 等主流界面式浏览器，如果你在这些浏览器里面安装一个 Selenium 的插件，那么便可以方便地实现Web界面的测试。换句话说叫 Selenium 支持这些浏览器驱动。<br>Selenium 2，又名 WebDriver，它的主要新功能是集成了 Selenium 1.0 以及 WebDriver（WebDriver 曾经是 Selenium 的竞争对手）。也就是说 Selenium 2 是 Selenium 和 WebDriver 两个项目的合并，即 Selenium 2 兼容 Selenium，它既支持 Selenium API 也支持 WebDriver API。  </p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p><code>pip install selenium</code>  </p><p>还需要安装驱动，根据不同浏览器需要选择不同的驱动，下面地址是chrome驱动。<br>链接：<a href="https://pan.baidu.com/s/1qZ2LfmW" target="_blank" rel="noopener">https://pan.baidu.com/s/1qZ2LfmW</a> 密码：qixa<br>下载以后，并把chromdriver放在chrome.exe同级目录下面，我的windows下面地址为<code>C:\Program Files (x86)\Google\Chrome\Application</code>。<br>也可以将对应地址添加在环境变量中。<br>下面代码实现了在chrome中打开百度首页，然后自动关闭的功能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">chromedriver = <span class="string">"C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe"</span></span><br><span class="line">browser = webdriver.Chrome(chromedriver)</span><br><span class="line">url = <span class="string">"https://www.baidu.com"</span></span><br><span class="line">browser.get(url=url)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure></p><h4 id="元素查找"><a href="#元素查找" class="headerlink" title="元素查找"></a>元素查找</h4><h5 id="单个元素查找"><a href="#单个元素查找" class="headerlink" title="单个元素查找"></a>单个元素查找</h5><p>查找元素有下面几种<br><code>find_element_by_name</code><br><code>find_element_by_id</code><br><code>find_element_by_xpath</code><br><code>find_element_by_link_text</code><br><code>find_element_by_partial_link_text</code><br><code>find_element_by_tag_name</code><br><code>find_element_by_class_name</code><br><code>find_element_by_css_selector</code><br>示例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">chromedriver = <span class="string">"C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe"</span></span><br><span class="line">browser = webdriver.Chrome(chromedriver)</span><br><span class="line">url = <span class="string">"http://www.taobao.com"</span></span><br><span class="line">browser.get(url=url)</span><br><span class="line">input_first = browser.find_element_by_id(<span class="string">"q"</span>)  <span class="comment">#通过id</span></span><br><span class="line">input_second = browser.find_element_by_css_selector(<span class="string">"#q"</span>) <span class="comment">#通过css选择器</span></span><br><span class="line">input_third = browser.find_element_by_xpath(<span class="string">'//*[@id="q"]'</span>) <span class="comment">#通过xpath选择器</span></span><br><span class="line">print(input_first)</span><br><span class="line">print(input_second)</span><br><span class="line">print(input_third)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class="string">"7341f32aea4238856409f236325848fc"</span>, element=<span class="string">"0.4317776711082031-1"</span>)&gt;</span><br><span class="line">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class="string">"7341f32aea4238856409f236325848fc"</span>, element=<span class="string">"0.4317776711082031-1"</span>)&gt;</span><br><span class="line">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class="string">"7341f32aea4238856409f236325848fc"</span>, element=<span class="string">"0.4317776711082031-1"</span>)&gt;</span><br></pre></td></tr></table></figure></p><p>还可以通过导入By模块方式使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line">input_first = browser.find_element(By.ID, <span class="string">"q"</span>)</span><br></pre></td></tr></table></figure></p><p>该方法和其他类似，<code>By.ID</code>中ID也可以替换成name等。  </p><h5 id="多个元素查找"><a href="#多个元素查找" class="headerlink" title="多个元素查找"></a>多个元素查找</h5><p>多个元素查找就是使用<code>find_elements</code>，单个使用<code>find_element</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">chromedriver = <span class="string">"C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe"</span></span><br><span class="line">browser = webdriver.Chrome(chromedriver)</span><br><span class="line">browser.get(<span class="string">"http://www.taobao.com"</span>)</span><br><span class="line">lis = browser.find_elements_by_css_selector(<span class="string">'.service-bd li'</span>)</span><br><span class="line">print(lis)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure></p><p>此时得到的结果是列表。<br><strong>xpath说明</strong><br>XPath是XML Path的简称，由于HTML文档本身就是一个标准的XML页面，所以我们可以使用XPath的语法来定位页面元素。<br>绝对路径<br><code>根元素开始用/</code><br>相对路劲<br><code>任意符合条件的元素 //</code><br>查找页面上所有的input元素<br><code>//input</code><br>查找页面上第一个form元素内的直接子input元素(即只包括form元素的下一级input元素，使用绝对路径表示，单/号)<br><code>//form[1]/input</code><br>查找页面上第一个form元素内的所有子input元素(只要在form元素内的input都算，不管还嵌套了多少个其他标签，使用相对路径表示，双//号)<br><code>//form[1]//input</code><br>查找页面上第一个form元素<br><code>//form[1]</code><br>查找页面上id为loginForm的form元素<br><code>//form[@id=&#39;loginForm&#39;]</code><br>查找页面上具有name属性为username的input元素<br><code>//input[@name=&#39;username&#39;]</code><br>查找页面上id为loginForm的form元素下的第一个input元素<br><code>//form[@id=&#39;loginForm&#39;]/input[1]</code><br>查找页面具有name属性为contiune并且type属性为button的input元素<br><code>//input[@name=&#39;continue&#39;][@type=&#39;button&#39;]</code><br>查找页面上id为loginForm的form元素下第4个input元素<br><code>//form[@id=&#39;loginForm&#39;]/input[4]</code>  </p><h4 id="控件交互"><a href="#控件交互" class="headerlink" title="控件交互"></a>控件交互</h4><p>清空输入框数据<br><code>element.clear()</code><br>发送数据<br><code>element.sendkeys(“username”)</code><br>获取文本的值<br><code>element.text</code><br>点击按钮<br><code>element.click()</code><br>表单提交<br><code>element.submit()</code><br>单选和多选框<br><code>element.clear()</code><br><code>element = browser.find_elements_by_id(&#39;checkbox&#39;)</code>  </p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>获取cookies<br><code>browser.get_cookies()</code><br>获取浏览器头名字<br><code>browser.title</code><br>关闭浏览器<br><code>browser.close()</code><br>前进<br><code>browser.forward()</code><br>后退<br><code>browser.back()</code><br>刷新<br><code>browser.refresh()</code><br>返回当前页面url<br><code>browser.current_url</code>  </p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>下面是利用driver实现自动登录京东网站并获取到cookie的操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://passport.jd.com/new/login.aspx?ReturnUrl=https%3A%2F%2Fwww.jd.com%2F'</span></span><br><span class="line">chromedriver = <span class="string">"C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe"</span></span><br><span class="line">driver = webdriver.Chrome(chromedriver)</span><br><span class="line">driver.get(url)</span><br><span class="line">time.sleep(random.uniform(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">driver.find_elements_by_xpath(<span class="string">'//a[@clstag="pageclick|keycount|login_pc_201804112|10"]'</span>)[<span class="number">0</span>].click() <span class="comment">#默认为二维码扫描登录，此处为切换到用户账户登录</span></span><br><span class="line">time.sleep(random.uniform(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">driver.find_element_by_id(<span class="string">'loginname'</span>).clear() <span class="comment">#清空默认用户名</span></span><br><span class="line">time.sleep(random.uniform(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">driver.find_element_by_id(<span class="string">'loginname'</span>).send_keys(<span class="string">"xxxxx"</span>) <span class="comment">#输入用户名</span></span><br><span class="line">time.sleep(random.uniform(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">driver.find_element_by_id(<span class="string">'nloginpwd'</span>).send_keys(<span class="string">"xxxxx"</span>) <span class="comment">#输入密码</span></span><br><span class="line">time.sleep(random.uniform(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">driver.find_element_by_id(<span class="string">'loginsubmit'</span>).click() <span class="comment">#点击登录按钮</span></span><br><span class="line">time.sleep(random.uniform(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">print(driver.get_cookies())</span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure></p><p><code>time.sleep(random.uniform(1, 3))</code>是当前操作之后随机暂停，模拟人的操作，防止被封。  </p><p>更多关于<code>webdriver</code>内容可以点击<a href="http://selenium-python.readthedocs.io/index.html" target="_blank" rel="noopener">Selenium with Python</a>查看官方文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Beautiful-Soup&quot;&gt;&lt;a href=&quot;#Beautiful-Soup&quot; class=&quot;headerlink&quot; title=&quot;Beautiful Soup&quot;&gt;&lt;/a&gt;Beautiful Soup&lt;/h3&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Beautiful Soup&lt;/code&gt;是python的一个库，主要功能是从网页抓取数据。&lt;br&gt;它是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间。&lt;br&gt;通过使用该库，可以不编写正则就可以方便的实现网页信息的抓取。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="webdriver" scheme="https://rosinelan.github.io/tags/webdriver/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫(二)</title>
    <link href="https://rosinelan.github.io/2018/06/19/python%E7%88%AC%E8%99%AB-%E4%BA%8C/"/>
    <id>https://rosinelan.github.io/2018/06/19/python爬虫-二/</id>
    <published>2018-06-19T07:34:06.000Z</published>
    <updated>2018-06-19T12:51:06.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="urllib模块"><a href="#urllib模块" class="headerlink" title="urllib模块"></a>urllib模块</h3><p>python2中有<code>urllib</code>和<code>urllib2</code>2个模块，虽然<code>urllib2</code>是升级版，但是依然不能替代<code>urllib</code>，各有所长。<br>python3中全部封装成一个<code>urllib</code>。  </p><h4 id="python2中的ubllib和urllib2"><a href="#python2中的ubllib和urllib2" class="headerlink" title="python2中的ubllib和urllib2"></a>python2中的ubllib和urllib2</h4><p>urllib 和urllib2都是接受URL请求的相关模块，但是urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，urllib不可以伪装你的User Agent字符串等。<br>urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。<br><a id="more"></a></p><h4 id="python3和python2使用差异"><a href="#python3和python2使用差异" class="headerlink" title="python3和python2使用差异"></a>python3和python2使用差异</h4><p>使用urllib中的request发送数据，无法直接传入字典类的参数，需要进行数据转换。<br>python2中为<code>data = urlib.urlencode(data) urllib2.Request(url, data)</code>，示例如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib, urllib2</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36"</span>,</span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"www.baidu.com"</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;<span class="string">"k1"</span>: <span class="string">"v1"</span>, <span class="string">"k2"</span>: <span class="string">"v2"</span>&#125;</span><br><span class="line">data = urllib.urlencode(data)</span><br><span class="line">print(data)    <span class="comment">#输出结果：k2=v2&amp;k1=v1</span></span><br><span class="line">response = urllib2.Request(url=url, headers=headers, data=data)</span><br></pre></td></tr></table></figure></p><p>python3中<code>data = urllib.parse.urlencode(data) urllib.request.Request(url, data)</code>，示例如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> Request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36"</span>,</span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"www.baidu.com"</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;<span class="string">"k1"</span>: <span class="string">"v1"</span>, <span class="string">"k2"</span>: <span class="string">"v2"</span>&#125;</span><br><span class="line">data = parse.urlencode(data)</span><br><span class="line">print(data)    <span class="comment">#输出结果：k2=v2&amp;k1=v1</span></span><br><span class="line">response = Request(url=url, headers=headers, data=data)</span><br></pre></td></tr></table></figure></p><ul><li>urllib下载</li></ul><ol><li><p>使用urllib中的<code>request.urlretrieve</code>方法  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://inews.gtimg.com/newsapp_match/0/3967692951/0"</span></span><br><span class="line">request.urlretrieve(url, <span class="string">'qq.jpg'</span>)</span><br></pre></td></tr></table></figure></li><li><p>使用<code>urlopen</code>得到response信息，然后读取  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://inews.gtimg.com/newsapp_match/0/2711870562/0"</span></span><br><span class="line">req = request.Request(url)</span><br><span class="line">res = request.urlopen(req)</span><br><span class="line">text = res.read()</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"2.jpg"</span>, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(text)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;urllib模块&quot;&gt;&lt;a href=&quot;#urllib模块&quot; class=&quot;headerlink&quot; title=&quot;urllib模块&quot;&gt;&lt;/a&gt;urllib模块&lt;/h3&gt;&lt;p&gt;python2中有&lt;code&gt;urllib&lt;/code&gt;和&lt;code&gt;urllib2&lt;/code&gt;2个模块，虽然&lt;code&gt;urllib2&lt;/code&gt;是升级版，但是依然不能替代&lt;code&gt;urllib&lt;/code&gt;，各有所长。&lt;br&gt;python3中全部封装成一个&lt;code&gt;urllib&lt;/code&gt;。  &lt;/p&gt;
&lt;h4 id=&quot;python2中的ubllib和urllib2&quot;&gt;&lt;a href=&quot;#python2中的ubllib和urllib2&quot; class=&quot;headerlink&quot; title=&quot;python2中的ubllib和urllib2&quot;&gt;&lt;/a&gt;python2中的ubllib和urllib2&lt;/h4&gt;&lt;p&gt;urllib 和urllib2都是接受URL请求的相关模块，但是urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，urllib不可以伪装你的User Agent字符串等。&lt;br&gt;urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="爬虫" scheme="https://rosinelan.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="urllib" scheme="https://rosinelan.github.io/tags/urllib/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫</title>
    <link href="https://rosinelan.github.io/2018/06/13/python%E7%88%AC%E8%99%AB/"/>
    <id>https://rosinelan.github.io/2018/06/13/python爬虫/</id>
    <published>2018-06-13T10:02:18.000Z</published>
    <updated>2018-06-19T12:37:13.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="爬虫介绍"><a href="#爬虫介绍" class="headerlink" title="爬虫介绍"></a>爬虫介绍</h3><h4 id="爬虫定义"><a href="#爬虫定义" class="headerlink" title="爬虫定义"></a>爬虫定义</h4><p>爬虫是请求网站并提取自己所需要数据的过程。通过我们的程序，可以代替我们向服务器发送请求，然后进行批量的数据下载。  </p><h4 id="爬虫基本流程"><a href="#爬虫基本流程" class="headerlink" title="爬虫基本流程"></a>爬虫基本流程</h4><ol><li>发起请求<br>通过url向服务器发送requests请求，请求可以包含额外的header信息。<a id="more"></a></li><li>获取响应内容<br>如果服务器正常响应，那么将受到一个response，response即为我们所请求的网页内容，可能包含html\json\二进制数据(图片、视频)等。</li><li>解析内容<br>如果是html代码则可以使用网页解析器进行解析；如果是json数据则可以转换成json对象进行解析；如果是二进制数据则可以保存到文件进行进一步的处理。</li><li>保存数据<br>可以保存到本地文件，也可以保存到数据库(mysql\redis\mongodb等)。<h4 id="requests请求"><a href="#requests请求" class="headerlink" title="requests请求"></a>requests请求</h4>当我们通过浏览器向服务器发送requests请求时，这个request包含什么内容？可以通过chrome浏览器的开发人员工具(F12)查看。  </li><li>请求方式<br>最常用的请求方式包括get请求和post请求。<br>post请求在开发中最常见的是通过表单进行提交，从用户角度来讲最常见的就是登陆验证。当你需要输入一些信息进行登陆的时候，这次请求就是post请求。<br>get请求最常见的就是搜索回车之后，信息将以?间隔添加在url后面。类似于<code>https://www.baidu.com/s?wd=python3%20requests</code>。而且get请求是用来获取数据，是幂等的。<br>其他还包括put请求(向服务端发送信息从而改变内容)和delete请求(删除资源)。<br>对于资源的操作，其实都可以通过post/get完成，不需要用到put/delete，实际中put/delete也很少用。    </li><li>uri统一资源定位符<br>一个网址、一个视频、一个图片都可以用uri去定义</li><li>requests headers<br>请求头，包括这次请求的类型，cookie信息以及浏览器类型等。<br>请求头在我们进行网页抓取的时候，服务器会通过解析请求头来进行信息的审核，判断请求是否为合法请求。所以当我们通过程序伪装浏览器进行请求的时候可以设置请求头的信息。  </li><li>请求体<br>post请求会把用户信息包装在form-data里面进行提交，因此相比于get请求，post请求的Headers标签的内容会多出Form Data这个信息包。<h4 id="response"><a href="#response" class="headerlink" title="response"></a>response</h4></li><li>响应状态<br>通过Headers中的General可以看到<code>status code</code>，使用数字代码表示对于状态，200表示成功，301跳转，404找不到网页，502服务器错误等。</li><li>响应头<br>包括内容的类型，cookie信息等。</li><li>响应体<br>请求的目的就是为了得到响应体，包括html代码，json及二进制数据等。<h3 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h3>安装使用<code>pip install requests</code>即可。  </li></ol><ul><li>通过requests进行网页请求<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line">response = requests.get(<span class="string">'https://www.baidu.com'</span>)  </span><br><span class="line">print(response.text)  <span class="comment">#输出结果为html，中文乱码</span></span><br><span class="line">response.encoding = <span class="string">'utf-8'</span>  <span class="comment">#修改编码</span></span><br><span class="line">print(response.text)  <span class="comment">#输出中文正常</span></span><br><span class="line">print(response.status_code) <span class="comment">#输出状态码，200</span></span><br></pre></td></tr></table></figure></li></ul><p>返回的response为文本时通过<code>response.text</code>读取；图片和视频等二进制文件通过<code>response.content</code>读取。</p><ul><li>通过添加请求头信息<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.75 Safari/537.36'</span>&#125;</span><br><span class="line"> response1 = requests.get(<span class="string">'https://www.baidu.com'</span>, headers=headers)</span><br></pre></td></tr></table></figure></li></ul><p>可以通过定义一个列表，然后通过random模块随机取一个header信息进行访问，防止一些反爬虫的操作。  </p><ul><li><p>获取cookie信息<br>cookie的五要素包括<code>name</code>、<code>value</code>、<code>domain</code>、<code>path</code>和<code>expires</code>。我们可以使用requests模块通过会话信息获取这些信息。<br><code>domain</code><br>代表cookie所在的域，默认情况下就是请求的域名，例如请求<a href="http://www.server1.com/files/hello" target="_blank" rel="noopener">http://www.server1.com/files/hello</a>, 那么响应中的set-Cookie默认会使用www.server1.com作为cookie的domain，在浏览器中也是按照domain来组织cookie的。 我们可以在响应中设置cookie的domain为其他域，但是浏览器并不会去保存这些domain为其他域的cookie。<br><code>path</code> 路径<br>path能够进一步的控制cookie的访问，当path=/，当前域的所有请求都可以访问到这个cookie。如果path设为其他值，比如path=/test,那么只有/test下面的请求可以访问到这个cookie。<br><code>expires</code> 过期时间<br><code>name</code> 对应的key值<br><code>value</code>  key对应的value值  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://www.hao123.com/"</span></span><br><span class="line">session = requests.session()</span><br><span class="line">response = session.get(url=url).text</span><br><span class="line">cookies = session.cookies</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookies:</span><br><span class="line">    print(cookie.name)</span><br><span class="line">    print(cookie.value)</span><br><span class="line">    print(cookie.domain)</span><br><span class="line">    print(cookie.path)</span><br><span class="line">    print(cookie.expires)</span><br></pre></td></tr></table></figure></li><li><p>使用已知的cookie信息访问网站</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cookie = dict(_ga=<span class="string">"GA1.2.208618761.1528809975"</span>, _gid=<span class="string">"GA1.2.604525626.1528979734"</span>, PHPSESSID=<span class="string">"ait0b8c22ofqpo630cekpc33b6"</span>, _gat=<span class="string">"1"</span>, Hm_lvt_0936ebcc9fa24aa610a0079314fec2d3=<span class="string">"1528809975,1528809984,1528979734,1528980228"</span>, Hm_lpvt_0936ebcc9fa24aa610a0079314fec2d3=<span class="string">"1528980228"</span>, ape__Session=<span class="string">"ait0b8c22ofqpo630cekpc33b6"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://httpbin.org/cookies"</span></span><br><span class="line">session = requests.session()</span><br><span class="line">res = session.get(url=url, cookies=cookie)</span><br><span class="line">res.encoding = res.apparent_encoding</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure></li><li><p>使用代理访问网站<br>采集信息时为避免IP地址被封，可以使用代理方式访问，可以通过requests模块的proxies属性。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://2018.ip138.com/ic.asp"</span></span><br><span class="line">proxy = &#123;<span class="string">"http"</span>: <span class="string">"http://221.228.17.172:8181"</span>&#125;</span><br><span class="line">res1 = requests.get(url=url, proxies=proxy)</span><br><span class="line">res2 = requests.get(url=url)</span><br><span class="line">res1.encoding = res1.apparent_encoding</span><br><span class="line">res2.encoding = res2.apparent_encoding</span><br><span class="line">print(res1.text)    <span class="comment">#输出结果为代理IP信息</span></span><br><span class="line">print(<span class="string">"###"</span>*<span class="number">10</span>)</span><br><span class="line">print(res2.text)    <span class="comment">#输出结果为本机IP信息</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>总结</strong><br>requests模块提供的接口，在传输数据的时候，都可以以<code>key:value</code>的形式进行传输，方便数据处理。<br>关于requests中文乱码的问题，可以参考<a href="http://xiaorui.cc/2016/02/19/%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90python-requests%E5%BA%93%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">Python requests库中文编码问题</a><br>更多关于<code>Requests</code>模块的介绍可以点击<a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">Requests快速上手</a>查看介绍</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;爬虫介绍&quot;&gt;&lt;a href=&quot;#爬虫介绍&quot; class=&quot;headerlink&quot; title=&quot;爬虫介绍&quot;&gt;&lt;/a&gt;爬虫介绍&lt;/h3&gt;&lt;h4 id=&quot;爬虫定义&quot;&gt;&lt;a href=&quot;#爬虫定义&quot; class=&quot;headerlink&quot; title=&quot;爬虫定义&quot;&gt;&lt;/a&gt;爬虫定义&lt;/h4&gt;&lt;p&gt;爬虫是请求网站并提取自己所需要数据的过程。通过我们的程序，可以代替我们向服务器发送请求，然后进行批量的数据下载。  &lt;/p&gt;
&lt;h4 id=&quot;爬虫基本流程&quot;&gt;&lt;a href=&quot;#爬虫基本流程&quot; class=&quot;headerlink&quot; title=&quot;爬虫基本流程&quot;&gt;&lt;/a&gt;爬虫基本流程&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;发起请求&lt;br&gt;通过url向服务器发送requests请求，请求可以包含额外的header信息。
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="爬虫" scheme="https://rosinelan.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="requests" scheme="https://rosinelan.github.io/tags/requests/"/>
    
  </entry>
  
  <entry>
    <title>python数据处理(二)</title>
    <link href="https://rosinelan.github.io/2018/06/11/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E4%BA%8C/"/>
    <id>https://rosinelan.github.io/2018/06/11/python数据处理-二/</id>
    <published>2018-06-11T15:19:55.000Z</published>
    <updated>2018-06-12T11:15:54.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pdf处理"><a href="#pdf处理" class="headerlink" title="pdf处理"></a>pdf处理</h3><p>pdf是二进制文件，使用<code>PyPDF2</code>模块进行处理，安装方法<code>pip install PyPDF2</code>。  </p><h4 id="提取文本"><a href="#提取文本" class="headerlink" title="提取文本"></a>提取文本</h4><ol><li>导入PyPDF2模块，然后以读二进制模式打开pdf文件，并将其保存到对象pdfFileObj。</li><li>调用pdfFileReader()并传入pdfFileObj，将PdfFileReader对象保存到pdfReader。</li><li>获取pdf文件总页数调用PdfFileReader对象的<code>numPages</code>属性。</li><li>从某页中提取文本，首先通过PdfFileReader对象的<code>getPage()</code>方法得到Page对象，然后调用Page对象的<code>extractText()</code>方法得到文本字符串。<a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PyPDF2</span><br><span class="line"></span><br><span class="line">pdfFileObj = open(<span class="string">"test.pdf"</span>, <span class="string">'rb'</span>)</span><br><span class="line">pdfReader = PyPDF2.PdfFileReader(pdfFileObj)</span><br><span class="line">print(pdfReader.numPages) <span class="comment">#文件总页数</span></span><br><span class="line">pageObj = pdfReader.getPage(<span class="number">0</span>) <span class="comment">#下标从0开始</span></span><br><span class="line">pageObj.extractText()</span><br></pre></td></tr></table></figure></li></ol><h4 id="解密pdf"><a href="#解密pdf" class="headerlink" title="解密pdf"></a>解密pdf</h4><p>当pdf文件加密时，需要传入密码才能正常打开，此时使用<code>decrypt()</code>函数传入密码即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PyPDF2</span><br><span class="line"></span><br><span class="line">pdfFileObj = open(<span class="string">"test.pdf"</span>, <span class="string">'rb'</span>)</span><br><span class="line">pdfReader = PyPDF2.PdfFileReader(pdfFileObj)</span><br><span class="line">print(pdfReader.isEncrypted)    <span class="comment">#是否加密，是返回True，否则返回False</span></span><br><span class="line">pdfReader.decrypt(<span class="string">"123456"</span>)</span><br><span class="line">pageObj = pdfReader.getPage(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><h4 id="创建pdf"><a href="#创建pdf" class="headerlink" title="创建pdf"></a>创建pdf</h4><p>创建pdf使用<code>PdfFileWriter</code>对象。但是该模块不允许直接编辑pdf文件，一般都是从其他pdf拷贝页面。    </p><ol><li>打开一个或多个pdf文件，得到PdfFileReader对象。</li><li>创建一个新的PdfFileWriter对象。</li><li>将页面从PdfFileReader对象拷贝到PdfFileWriter对象。</li><li>利用PdfFileWriter对象写入输出到pdf。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pdf1File = open(<span class="string">"test1.pdf"</span>, <span class="string">"rb"</span>)</span><br><span class="line">pdf2File = open(<span class="string">"test2.pdf"</span>, <span class="string">"rb"</span>)</span><br><span class="line">pdf1Reader = PyPDF2.PdfFileReader(pdf1File)</span><br><span class="line">pdf2Reader = PyPDF2.PdfFileReader(pdf2File)</span><br><span class="line">pdfWriter = PyPDF2.PdfFileWriter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pageNum <span class="keyword">in</span> range(pdf1Reader.numPages):</span><br><span class="line">    pageobj = pdf1Reader.getPage(pageNum)</span><br><span class="line">    pdfWriter.addPage(pageobj)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> pageNum <span class="keyword">in</span> range(pdf2Reader.numPages):</span><br><span class="line">    pageobj = pdf2Reader.getPage(pageNum)</span><br><span class="line">    pdfWriter.addPage(pageobj)</span><br><span class="line"></span><br><span class="line">pdfOutputFile = open(<span class="string">"tst_com.pdf"</span>, <span class="string">"wb"</span>)</span><br><span class="line">pdfWriter.write(pdfOutputFile)</span><br><span class="line">pdfOutputFile.close()</span><br><span class="line">pdf1File.close()</span><br><span class="line">pdf2File.close()</span><br></pre></td></tr></table></figure></li></ol><p>注意：此处<code>addPage()</code>方法只能在末尾添加页面，PyPDF2不支持在中间插入页面。</p><h3 id="pdf转换"><a href="#pdf转换" class="headerlink" title="pdf转换"></a>pdf转换</h3><p>pdf转换使用<code>pdfkit</code>模块，安装方法<code>pip install pdfkit</code>。<br>由于pdfkit模块是wkhtmltopdf工具的封装，所以需要安装该工具，点击<a href="https://wkhtmltopdf.org/downloads.html" target="_blank" rel="noopener">wkhtmltopdf</a>至官方下载地址，根据操作系统版本选择下载安装即可。安装之后将bin执行文件路径添加到PATH变量中。  </p><ul><li><p>网页转换为pdf</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdfkit</span><br><span class="line"></span><br><span class="line">pdfkit.from_url(<span class="string">"12345"</span>, <span class="string">"output1.pdf"</span>)</span><br></pre></td></tr></table></figure></li><li><p>html转换为pdf</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdfkit</span><br><span class="line"></span><br><span class="line">pdfkit.from_file(<span class="string">"12345.html"</span>, <span class="string">"output2.pdf"</span>)</span><br></pre></td></tr></table></figure></li><li><p>字符转换成pdf</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdfkit</span><br><span class="line"></span><br><span class="line">pdfkit.from_string(<span class="string">"12345"</span>, <span class="string">"output3.pdf"</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol><li><p>抓取linux教程然后制作成pdf文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pdfkit</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">'http://www.apelearn.com/study_v2/'</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">"aming"</span>):</span><br><span class="line">    os.mkdir(<span class="string">"aming"</span>)</span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">"aming"</span>)</span><br><span class="line">s = requests.session()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">27</span>):</span><br><span class="line">    url = base_url + <span class="string">'chapter'</span> + str(i) + <span class="string">'.html'</span>  <span class="comment">#拼接网页url</span></span><br><span class="line">    file = str(i) + <span class="string">'.pdf'</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pdfkit.from_url(url, file)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure></li><li><p>将生成的多个pdf文件合并成1个pdf。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> PyPDF2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">files = list()</span><br><span class="line"><span class="keyword">for</span> fileName <span class="keyword">in</span> os.listdir(<span class="string">"aming"</span>):</span><br><span class="line">    <span class="keyword">if</span> fileName.endswith(<span class="string">".pdf"</span>):</span><br><span class="line">        files.append(fileName)</span><br><span class="line"></span><br><span class="line">newFiles = sorted(files, key=<span class="keyword">lambda</span> d: int(d.split(<span class="string">".pdf"</span>)[<span class="number">0</span>])) <span class="comment">#按照章节进行排序，默认为ASCII码排序</span></span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">"aming"</span>)</span><br><span class="line">pdfWriter = PyPDF2.PdfFileWriter() <span class="comment">#生成一个空白的pdf</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> newFiles:</span><br><span class="line">    pdfReader = PyPDF2.PdfFileReader(open(item, <span class="string">"rb"</span>))</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> range(pdfReader.numPages):</span><br><span class="line">        pdfWriter.addPage(pdfReader.getPage(page))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> codecs.open(<span class="string">"aminglinux.pdf"</span>, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pdfWriter.write(f)</span><br></pre></td></tr></table></figure></li></ol><h3 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h3><p>python3中使用<code>pillow</code>模块，安装方法<code>pip install pillow</code>，使用的时候导入方法<code>from PIL import Iamge</code>。  </p><h4 id="image的属性"><a href="#image的属性" class="headerlink" title="image的属性"></a>image的属性</h4><ul><li>format<br>识别图像的源格式，如果该文件不是从文件读取，则置为None。</li><li>size<br>返回一个元组，包含2个元素，值为像素意义上的宽和高。</li><li>mode<br>包括RGB(true color image)/L(luminance)/CMTK(pre-press image)。<h4 id="image的方法"><a href="#image的方法" class="headerlink" title="image的方法"></a>image的方法</h4></li><li>image.show()<br>显示最近加载的图像</li><li>image.open(file)<br>打开文件</li><li>image.save(outputfile)<br>保存文件</li><li>image.crop(left, upper, right, lower)<br>从图像中提取某个矩形大小的图像。它接受一个四元素的元组作为参数，坐标系统的原点(0,0)是左上角。<br>Image的几何处理：</li><li>im.resize((128, 128))<br>调整图片大小</li><li>im.rotate(45)<br>逆时针旋转 45 度角。</li><li>im.transpose(Image.FLIP_LEFT_RIGHT)<br>左右对换。</li><li>im.transpose(Image.FLIP_TOP_BOTTOM)<br>上下对换。</li><li>im.transpose(Image.ROTATE_90)<br>旋转 90 度角。</li><li>im.transpose(Image.ROTATE_180)<br>旋转 180 度角。</li><li>im.transpose(Image.ROTATE_270)<br>旋转 270 度角。<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4></li></ul><ol><li><p>显示图片信息并查看图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.open(<span class="string">"test.jpg"</span>)</span><br><span class="line">print(image.format, image.size, image.mode)</span><br><span class="line">image.show()</span><br></pre></td></tr></table></figure></li><li><p>抠图<br>将图片指定区域进行裁剪并保存在cutting.jpg中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.open(<span class="string">"test..jpg"</span>)</span><br><span class="line">print(image.format, image.size, image.mode)</span><br><span class="line">box = (<span class="number">600</span>, <span class="number">300</span>, <span class="number">1050</span>, <span class="number">660</span>)</span><br><span class="line">region = image.crop(box)</span><br><span class="line">region.save(<span class="string">"cutting.jpg"</span>)</span><br></pre></td></tr></table></figure></li><li><p>图片拼合<br>将指定区域的图片截取出来并旋转180度，然后拼接在一起</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.open(<span class="string">"test..jpg"</span>)</span><br><span class="line">print(image.format, image.size, image.mode)</span><br><span class="line">box = (<span class="number">600</span>, <span class="number">300</span>, <span class="number">1050</span>, <span class="number">660</span>)</span><br><span class="line">egion = image.crop(box)</span><br><span class="line"><span class="comment">#egion.save("cutting.jpg")</span></span><br><span class="line">region = egion.transpose(Image.ROTATE_180)</span><br><span class="line">image.paste(region, box)</span><br><span class="line">image.show()</span><br></pre></td></tr></table></figure></li><li><p>图片缩放</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">infile = <span class="string">"test.jpg"</span></span><br><span class="line">outfile = <span class="string">"newtest.jpg"</span></span><br><span class="line">image = Image.open(infile)</span><br><span class="line">(x, y) = image.size</span><br><span class="line">newx = <span class="number">300</span></span><br><span class="line">newy = int(y*newx/x)</span><br><span class="line">out = image.resize((newx, newy), Image.ANTIALIAS)</span><br><span class="line">out.show()</span><br></pre></td></tr></table></figure></li><li><p>验证码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFont, ImageDraw, ImageFilter</span><br><span class="line"></span><br><span class="line">font_path = <span class="string">"msyh.ttf"</span></span><br><span class="line">number = <span class="number">4</span></span><br><span class="line">size = (<span class="number">100</span>, <span class="number">30</span>)</span><br><span class="line">bgcolor = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line">fontcolor = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">linecolor = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">draw_line = <span class="keyword">True</span></span><br><span class="line"><span class="comment"># 加入干扰线条数的上下限</span></span><br><span class="line">line_number = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成一个随机字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNumber</span><span class="params">()</span>:</span></span><br><span class="line">    source = list(string.ascii_letters) + list(string.digits)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(random.sample(source, number))</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制干扰线</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLine</span><span class="params">(draw, width, height)</span>:</span></span><br><span class="line">    begin = random.randint(<span class="number">0</span>, width), random.randint(<span class="number">0</span>, height)</span><br><span class="line">    end  = random.randint(<span class="number">0</span>, width), random.randint(<span class="number">0</span>, height)</span><br><span class="line">    draw.line([begin, end], fill=linecolor)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCode</span><span class="params">()</span>:</span></span><br><span class="line">    width, height = size</span><br><span class="line">    image = Image.new(<span class="string">"RGBA"</span>, size, bgcolor)</span><br><span class="line">    font = ImageFont.truetype(font_path, <span class="number">25</span>)</span><br><span class="line">    draw = ImageDraw.Draw(image)</span><br><span class="line">    text = getNumber()</span><br><span class="line">    font_width, font_height = font.getsize(text)</span><br><span class="line">    draw.text(((width - font_width) / <span class="number">2</span>, (height - font_height) / <span class="number">2</span>), text, font=font, fill=fontcolor)  <span class="comment"># 填充字符串</span></span><br><span class="line">    <span class="keyword">if</span> draw_line:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(line_number):</span><br><span class="line">            getLine(draw, width, height)</span><br><span class="line"></span><br><span class="line">    image = image.filter(ImageFilter.EDGE_ENHANCE_MORE)  <span class="comment"># 滤镜，边界加强</span></span><br><span class="line">    image.save(<span class="string">'idencode.png'</span>)  <span class="comment"># 保存验证码图片</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    getCode()</span><br></pre></td></tr></table></figure></li></ol><p>关于<code>pillow</code>模块的更多介绍，可以点击<a href="http://pillow.readthedocs.io/en/latest/" target="_blank" rel="noopener">Pillow</a>查看官方文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;pdf处理&quot;&gt;&lt;a href=&quot;#pdf处理&quot; class=&quot;headerlink&quot; title=&quot;pdf处理&quot;&gt;&lt;/a&gt;pdf处理&lt;/h3&gt;&lt;p&gt;pdf是二进制文件，使用&lt;code&gt;PyPDF2&lt;/code&gt;模块进行处理，安装方法&lt;code&gt;pip install PyPDF2&lt;/code&gt;。  &lt;/p&gt;
&lt;h4 id=&quot;提取文本&quot;&gt;&lt;a href=&quot;#提取文本&quot; class=&quot;headerlink&quot; title=&quot;提取文本&quot;&gt;&lt;/a&gt;提取文本&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;导入PyPDF2模块，然后以读二进制模式打开pdf文件，并将其保存到对象pdfFileObj。&lt;/li&gt;
&lt;li&gt;调用pdfFileReader()并传入pdfFileObj，将PdfFileReader对象保存到pdfReader。&lt;/li&gt;
&lt;li&gt;获取pdf文件总页数调用PdfFileReader对象的&lt;code&gt;numPages&lt;/code&gt;属性。&lt;/li&gt;
&lt;li&gt;从某页中提取文本，首先通过PdfFileReader对象的&lt;code&gt;getPage()&lt;/code&gt;方法得到Page对象，然后调用Page对象的&lt;code&gt;extractText()&lt;/code&gt;方法得到文本字符串。
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="pdf" scheme="https://rosinelan.github.io/tags/pdf/"/>
    
      <category term="pdfkit" scheme="https://rosinelan.github.io/tags/pdfkit/"/>
    
      <category term="图片" scheme="https://rosinelan.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="image" scheme="https://rosinelan.github.io/tags/image/"/>
    
  </entry>
  
  <entry>
    <title>python数据处理</title>
    <link href="https://rosinelan.github.io/2018/06/08/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://rosinelan.github.io/2018/06/08/python数据处理/</id>
    <published>2018-06-08T13:42:44.000Z</published>
    <updated>2018-06-12T09:36:16.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="csv数据处理"><a href="#csv数据处理" class="headerlink" title="csv数据处理"></a>csv数据处理</h3><p>csv表示”Comma-Separated Values(逗号分隔的值)”，csv文件时简化的电子表格，保存为纯文本文件。<br>python中解析csv文件可以使用csv模块。<br>注意：csv是文本文件，通过打开文件的操作，将其内容读入一个字符串，然后通过字符串的<code>split()</code>方法处理每行文本取得值。需要注意csv文件中也有自己的转义字符，允许逗号或者其他字符作为值的一部分，<code>split()</code>方法无法处理这部分转义字符。所以处理csv文件时为避免这些潜在的问题，建议使用csv模块处理csv文件。<br><a id="more"></a></p><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p>使用csv模块从csv文件中读取数据，需要创建一个<code>Reader</code>对象，可以通过Reader对象迭代遍历csv文件中的每一行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"example.csv"</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> dataObject:</span><br><span class="line">    dataReader = csv.reader(dataObject)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> dataReader:</span><br><span class="line">        print(<span class="string">"第&#123;0&#125;行:&#123;1&#125;"</span>.format(dataReader.line_num, row))</span><br></pre></td></tr></table></figure></p><p>Reader对象的<code>line_num</code>变量是当前的行号。<br>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">1</span>行:[<span class="string">'2018/06/09'</span>, <span class="string">'Apples'</span>, <span class="string">'73'</span>]</span><br><span class="line">第<span class="number">2</span>行:[<span class="string">'2018/06/10'</span>, <span class="string">'Cherries'</span>, <span class="string">'85'</span>]</span><br><span class="line">第<span class="number">3</span>行:[<span class="string">'2018/06/11'</span>, <span class="string">'Pears'</span>, <span class="string">'14'</span>]</span><br></pre></td></tr></table></figure></p><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p>Write对象可以将数据写入到csv文件中。<br>首先调用<code>open()</code>并传入<code>w</code>，以写模式打开一个文件。这时会创建一个对象。<br>然后将创建的对象传递给<code>csv.writer()</code>，创建一个Writer对象。<br>接下来调用Writer对象的<code>writerow()</code>方法写入文件。该方法接受参数为列表，返回值为写入文件这一行中的字符数(包括换行符)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"test.csv"</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> outputFile:</span><br><span class="line">    dataWriter = csv.writer(outputFile)</span><br><span class="line">    dataWriter.writerow([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">    dataWriter.writerow([<span class="string">'啊'</span>, <span class="string">'吧'</span>, <span class="string">'次'</span>])</span><br><span class="line">    dataWriter.writerow([<span class="string">'A'</span>, <span class="string">'Hello,World!'</span>, <span class="string">'C'</span>])</span><br></pre></td></tr></table></figure></p><p>最后输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a,b,c</span><br><span class="line">啊,吧,次</span><br><span class="line">A,&quot;Hello,World!&quot;,C</span><br></pre></td></tr></table></figure></p><p>此处的<code>Hello,Wrold!</code>中的逗号自动转义，使用双引号处理了。<br>在windows中<code>open()</code>需加上<code>newline=&#39;&#39;</code>参数，否则将出现2倍行距的情况。<br>写入的文件必须已经存在。  </p><ul><li>delimiter 指定分隔符，默认为逗号</li><li>lineterminator 行距，默认为单倍行距<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataWriter = csv.writer(outputFile, delimiter=<span class="string">'\t'</span>, lineterminator=<span class="string">'\n\n'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>上面表示使用制表符作为分隔符，两倍行距(也就是行之间字符变为2个换行符)。  </p><h3 id="excel数据处理"><a href="#excel数据处理" class="headerlink" title="excel数据处理"></a>excel数据处理</h3><p>excel的操作都是通过第三方库来进行。常用的有<code>xlrd</code>、<code>xlwt</code>、<code>xluntils</code>、<code>pyExcelerator</code>、<code>openpyxl</code>。<br>安装类似与其它第三方模块，使用<code>pip install module_name</code>即可。  </p><ul><li>xlrd只能进行读取excel文件，没法进行写入文件。</li><li>xlwt可以写入文件，但是不能在已有的excel的文件上进行修改。  </li><li>xluntils可以对文件进行复制和修改，该模块功能实现依赖于<code>xlrd</code>和<code>xlwt</code>。  </li><li>pyExcelerator模块与xlwt类似，也可以用来生成excel文件，同时支持单元格合并、冻结等操作。  </li><li>openpyxl也支持文件的读取、写入、创建和删除工作表、设置字体格式、单元格合并、冻结等操作。  </li></ul><h4 id="xlrd"><a href="#xlrd" class="headerlink" title="xlrd"></a>xlrd</h4><p><code>xlrd</code>主要用于excel文件读取。<br>excel名称为<code>test.xlsx</code>，内容如下<br><img src="http://cdn.rosinelan.com/blog/program/python_data_xlrd.png" alt="python_data_xlrd" title="python_data_xlrd"></p><ul><li><p>打开excel文件并获取所有的sheet。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line">workbook = xlrd.open_workbook(<span class="string">"test.xlsx"</span>)</span><br><span class="line">worksheets = workbook.sheet_names()</span><br><span class="line">print(worksheets)    <span class="comment">#输出结果：['物理机', '虚拟机']</span></span><br></pre></td></tr></table></figure></li><li><p>根据下标获取sheet名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worksheet1 = workbook.sheet_names()[<span class="number">0</span>]</span><br><span class="line">print(worksheet1)    <span class="comment">#输出结果：物理机</span></span><br><span class="line">worksheet2 = workbook.sheet_names()[<span class="number">1</span>]</span><br><span class="line">print(worksheet2)    <span class="comment">#输出结果：虚拟机</span></span><br></pre></td></tr></table></figure></li><li><p>根据sheet索引或名称获取sheet内容，同时获取sheet名称、行数、列数  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sheet1 = workbook.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">print(sheet1.name, sheet1.nrows, sheet1.ncols)    <span class="comment">#输出结果：物理机 16 6</span></span><br><span class="line">sheet2 = workbook.sheet_by_name(<span class="string">"虚拟机"</span>)</span><br><span class="line">print(sheet2.name, sheet2.nrows, sheet2.ncols)    <span class="comment">#输出结果：虚拟机 13 6</span></span><br></pre></td></tr></table></figure></li></ul><p>索引从<code>0</code>开始；<code>nrows</code>表示所有行；<code>ncols</code>表示所有列。</p><ul><li><p>根据sheet名称获取整行和整列的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sheet1 = workbook.sheet_by_name(<span class="string">"物理机"</span>)</span><br><span class="line">rows = sheet1.row_values(<span class="number">0</span>)    <span class="comment">#第一行内容</span></span><br><span class="line">print(rows)    <span class="comment">#输出结果：['IP地址', '设备用途', '型号', '主要配置', '操作系统', '区域']</span></span><br><span class="line">cols = sheet1.col_values(<span class="number">0</span>)    <span class="comment">#第一列的内容</span></span><br><span class="line">print(cols)    <span class="comment">#输出结果：['IP地址', '192.168.0.1', '192.168.0.2',... '192.168.0.15']</span></span><br></pre></td></tr></table></figure></li><li><p>获取指定单元格的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sheet1 = workbook.sheet_by_name(<span class="string">"物理机"</span>)</span><br><span class="line">print(sheet1.cell(<span class="number">1</span>, <span class="number">2</span>).value)     <span class="comment">#输出结果：Lenovo R680g7</span></span><br><span class="line">print(sheet1.cell_value(<span class="number">1</span>, <span class="number">2</span>))    <span class="comment">#输出结果：Lenovo R680g7</span></span><br><span class="line">print(sheet1.row(<span class="number">1</span>)[<span class="number">2</span>].value)    <span class="comment">#输出结果：Lenovo R680g7</span></span><br></pre></td></tr></table></figure></li><li><p>获取单元格内容的数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sheet1 = workbook.sheet_by_name(<span class="string">"物理机"</span>)</span><br><span class="line">print(sheet1.cell(<span class="number">1</span>, <span class="number">2</span>).ctype)    <span class="comment">#输出结果：1</span></span><br><span class="line">print(sheet1.cell(<span class="number">1</span>, <span class="number">6</span>).ctype)    <span class="comment">#输出结果：3</span></span><br></pre></td></tr></table></figure></li></ul><p><code>ctype</code>共有5种，<code>0 empty</code>,<code>1 string</code>, <code>2 number</code>, <code>3 date</code>, <code>4 boolean</code>, <code>5 error</code>。</p><ul><li>日期类型的特殊处理<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sheet1 = workbook.sheet_by_name(<span class="string">"物理机"</span>)</span><br><span class="line">print(sheet1.cell(<span class="number">1</span>, <span class="number">6</span>).value)    <span class="comment">#输出结果：43252.0</span></span><br></pre></td></tr></table></figure></li></ul><p>日期类型输出结果为number，可以使用<code>xldate_as_tuple</code>或<code>xldate_as_datetime</code>进行处理。</p><ul><li><p><code>xldate_as_tuple</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"></span><br><span class="line">sheet1 = workbook.sheet_by_name(<span class="string">"物理机"</span>)</span><br><span class="line">date_value = xlrd.xldate_as_tuple(sheet1.cell(<span class="number">1</span>, <span class="number">6</span>).value, workbook.datemode)</span><br><span class="line">print(date_value)    <span class="comment">#输出结果：(2018, 6, 1, 0, 0, 0)</span></span><br><span class="line">print(date_value[:<span class="number">3</span>])    <span class="comment">#输出结果：(2018, 6, 1)</span></span><br><span class="line">print(*date_value[:<span class="number">3</span>])    <span class="comment">#输出结果：2018 6 1</span></span><br><span class="line">print(date(*date_value[:<span class="number">3</span>]))    <span class="comment">#输出结果：2018-06-01</span></span><br></pre></td></tr></table></figure></li><li><p><code>xldate_as_datetime</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sheet1 = workbook.sheet_by_name(<span class="string">"物理机"</span>)</span><br><span class="line">date_time = xlrd.xldate_as_datetime(sheet1.cell(<span class="number">1</span>, <span class="number">6</span>).value, workbook.datemode)</span><br><span class="line">print(date_time.strftime(<span class="string">'%Y-%m-%d'</span>))    <span class="comment">#输出结果：2018-06-01</span></span><br></pre></td></tr></table></figure></li></ul><p>在脚本中需要获取并显示单元格中的日期类型时，可以先判断数据类型是否为日期类型，如果是则进行处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sheet1.cell(<span class="number">1</span>, <span class="number">6</span>).ctype == <span class="number">3</span>):</span><br><span class="line">    date_time = xlrd.xldate_as_datetime(sheet1.cell(<span class="number">1</span>, <span class="number">6</span>).value, workbook.datemode)</span><br><span class="line">    print(date_time.strftime(<span class="string">'%Y-%m-%d'</span>))</span><br></pre></td></tr></table></figure></p><p>关于<code>xlrd</code>模块更多介绍，可以点击<a href="http://xlrd.readthedocs.io/en/latest/" target="_blank" rel="noopener">xlrd documentation</a>查看官方文档介绍。  </p><h4 id="xlwt"><a href="#xlwt" class="headerlink" title="xlwt"></a>xlwt</h4><ul><li><p>创建workbook和sheet对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line">workbook = xlwt.Workbook()</span><br><span class="line">sheet1 = workbook.add_sheet(<span class="string">"sheet1"</span>, cell_overwrite_ok=<span class="keyword">True</span>)</span><br><span class="line">sheet2 = workbook.add_sheet(<span class="string">"sheet2"</span>, cell_overwrite_ok=<span class="keyword">True</span>)</span><br><span class="line">sheet3 = workbook.add_sheet(<span class="string">"表3"</span>, cell_overwrite_ok=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></li><li><p>sheet页中写入数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sheet1.write(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"姓名"</span>)</span><br><span class="line">sheet2.write(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"HOW"</span>)</span><br></pre></td></tr></table></figure></li><li><p>write方法参数列表<br><code>write(r, c, label=&quot;&quot;, style=Style.default_style)</code><br><code>r</code>表示行，<code>c</code>表示列，<code>label</code>表示写入的内容，<code>style</code>表示单元格格式。  </p></li><li><p>使用样式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">style = xlwt.XFStyle()</span><br><span class="line">font = style.font</span><br><span class="line">font.name = <span class="string">"Times New Roman"</span></span><br><span class="line">font.bold = <span class="keyword">True</span></span><br><span class="line">sheet3.write(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"WHAT"</span>, style)</span><br></pre></td></tr></table></figure></li><li><p>保存文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workbook.save(<span class="string">"test1.xls"</span>)    <span class="comment">#此处保存为xls格式，xlsx格式无法打开</span></span><br></pre></td></tr></table></figure></li></ul><p>关于<code>xlwt</code>模块更多介绍，可以点击<a href="http://xlwt.readthedocs.io/en/latest/" target="_blank" rel="noopener">xlwt documentation</a>查看官方文档介绍。 </p><h4 id="openpyxl"><a href="#openpyxl" class="headerlink" title="openpyxl"></a>openpyxl</h4><p>继续以上面的excel为例进行示例操作。  </p><h5 id="worksheet操作"><a href="#worksheet操作" class="headerlink" title="worksheet操作"></a>worksheet操作</h5><ul><li>加载工作表并打印当前所有sheet<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook, load_workbook</span><br><span class="line"></span><br><span class="line">wb1 = load_workbook(<span class="string">'test.xlsx'</span>)</span><br><span class="line">print(wb1.sheetnames) <span class="comment">#输出结果：['物理机', '虚拟机']</span></span><br><span class="line">print(wb1.active)    <span class="comment">#输出结果：&lt;Worksheet "物理机"&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><code>active</code>调用的是<code>_active_sheet_index</code>属性，默认情况为0.所以得到的都是第一个worksheet。</p><ul><li>创建sheet页<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ws1 = wb1.create_sheet(<span class="string">"sheet1"</span>)</span><br><span class="line">ws2 = wb1.create_sheet(<span class="string">"sheet2"</span>, <span class="number">0</span>)</span><br><span class="line">print(wb1.sheetnames) <span class="comment">#输出结果：['sheet2', '物理机', '虚拟机', 'sheet1']</span></span><br><span class="line">print(wb1.active) <span class="comment">#输出结果：&lt;Worksheet "sheet2"&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><code>create_sheet()</code>默认情况下插入在最后，当传入index参数时，插入至指定位置，例如0表示插入至最前面。  </p><ul><li>sheet页属性修改<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws1.title = <span class="string">"new sheet"</span> <span class="comment">#修改标题</span></span><br><span class="line">ws1.sheet_properties.tabColor = <span class="string">"1072BA"</span> <span class="comment">#修改工作表标签颜色</span></span><br><span class="line">print(wb1.sheetnames) <span class="comment">#输出结果：['sheet2', '物理机', '虚拟机', 'new sheet']</span></span><br></pre></td></tr></table></figure></li></ul><p>也可以通过循环的方式得到所有sheet页名称<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> sheet <span class="keyword">in</span> wb1:</span><br><span class="line">    print(sheet.title, end=<span class="string">' '</span>) <span class="comment">#输出结果：sheet2 物理机 虚拟机 new sheet</span></span><br></pre></td></tr></table></figure></p><ul><li>sheet页复制<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source = wb1.active</span><br><span class="line">target = wb1.copy_worksheet(source)</span><br><span class="line">print(wb1.sheetnames) <span class="comment">#输出结果：['sheet2', '物理机', '虚拟机', 'new sheet', 'sheet2 Copy']</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="cell操作"><a href="#cell操作" class="headerlink" title="cell操作"></a>cell操作</h5><ul><li>获取及修改指定cell内容<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ws4 = wb1[<span class="string">"物理机"</span>]</span><br><span class="line">print(ws4[<span class="string">"A4"</span>].value) <span class="comment">#输出结果：192.168.0.3</span></span><br><span class="line">print(ws4[<span class="string">"G4"</span>].value) <span class="comment">#输出结果：2018-06-03 00:00:00</span></span><br><span class="line">ws4[<span class="string">'A4'</span>] = <span class="number">4</span> <span class="comment">#可直接修改指定单元格内容</span></span><br><span class="line">print(ws4[<span class="string">"A4"</span>].value) <span class="comment">#输出结果：4</span></span><br></pre></td></tr></table></figure></li></ul><p>对于日期格式可直接正确输出。<br>修改指定单元格的内容也可以使用<code>cell()</code>方法传入行、列和值的方式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = ws4.cell(column=<span class="number">1</span>, row=<span class="number">4</span>, value=<span class="number">10</span>)</span><br><span class="line">print(ws4[<span class="string">"A4"</span>].value) <span class="comment">#输出结果：10</span></span><br></pre></td></tr></table></figure></p><p>当一个sheet页被创建时无单元格。单元格在首次被访问的时候创建，无论是否有值。<br>对于下面的操作,将会在内存中创建100*100的单元格，即使未分配值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line"><span class="meta">... </span>           ws.cell(row=i, column=j)</span><br></pre></td></tr></table></figure></p><ul><li>访问多个单元格或行或列<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cell_range = ws4[<span class="string">'A1'</span>:<span class="string">'B2'</span>] <span class="comment">#多个单元格</span></span><br><span class="line">print(cell_range)</span><br></pre></td></tr></table></figure></li></ul><p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((&lt;Cell <span class="string">'物理机'</span>.A1&gt;, &lt;Cell <span class="string">'物理机'</span>.B1&gt;), (&lt;Cell <span class="string">'物理机'</span>.A2&gt;, &lt;Cell <span class="string">'物理机'</span>.B2&gt;))</span><br></pre></td></tr></table></figure></p><p>输出结果为包含<code>2个元组的元组</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colC = ws4[<span class="string">'C'</span>] <span class="comment">#指定单行</span></span><br><span class="line">print(colC)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;Cell <span class="string">'物理机'</span>.C1&gt;... &lt;Cell <span class="string">'物理机'</span>.C15&gt;, &lt;Cell <span class="string">'物理机'</span>.C16&gt;)</span><br></pre></td></tr></table></figure></p><p>输出结果为<code>元组</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">col_range = ws4[<span class="string">'C:D'</span>] <span class="comment">#指定多行</span></span><br><span class="line">print(col_range)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((&lt;Cell <span class="string">'物理机'</span>.C1&gt;, ... &lt;Cell <span class="string">'物理机'</span>.C16&gt;), (&lt;Cell <span class="string">'物理机'</span>.D1&gt;,... &lt;Cell <span class="string">'物理机'</span>.D16&gt;))</span><br></pre></td></tr></table></figure></p><p>输出结果为包含<code>2个元组的元组</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">row10 = ws4[<span class="number">10</span>] <span class="comment">#指定单列</span></span><br><span class="line">print(row10)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;Cell <span class="string">'物理机'</span>.A10&gt;, &lt;Cell <span class="string">'物理机'</span>.B10&gt;,...&lt;Cell <span class="string">'物理机'</span>.L10&gt;)</span><br></pre></td></tr></table></figure></p><p>输出结果为<code>元组</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">row_range = ws4[<span class="number">5</span>:<span class="number">6</span>] <span class="comment">#指定多列</span></span><br><span class="line">print(row_range)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((&lt;Cell <span class="string">'物理机'</span>.A5&gt;, &lt;Cell <span class="string">'物理机'</span>.B5&gt;,... &lt;Cell <span class="string">'物理机'</span>.L5&gt;), (&lt;Cell <span class="string">'物理机'</span>.A6&gt;, &lt;Cell <span class="string">'物理机'</span>.B6&gt;,... &lt;Cell <span class="string">'物理机'</span>.L6&gt;))</span><br></pre></td></tr></table></figure></p><p>输出结果为包含<code>2个元组的元组</code><br>也可以通过<code>iter_rows()</code>、<code>iter_cols()</code>、<code>rows()</code>、<code>columns()</code>方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iter_rows()</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws4.iter_rows(min_row=<span class="number">1</span>, max_col=<span class="number">3</span>, max_row=<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">        print(cell)</span><br><span class="line"><span class="comment"># iter_cols()</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> ws4.iter_cols(min_row=<span class="number">1</span>, max_col=<span class="number">3</span>, max_row=<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> col:</span><br><span class="line">        print(cell)</span><br><span class="line"><span class="comment"># rows()</span></span><br><span class="line">print(tuple(ws4.rows))</span><br><span class="line"><span class="comment"># columns()</span></span><br><span class="line">print(tuple(ws4.columns))</span><br></pre></td></tr></table></figure></p><ul><li>数据存储</li></ul><p>直接赋值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line">wb1 = load_workbook(<span class="string">'test.xlsx'</span>)</span><br><span class="line">ws = wb1[<span class="string">"sheet2"</span>]</span><br><span class="line">c = ws[<span class="string">"A1"</span>]</span><br><span class="line">c.value = <span class="string">"hello, world"</span></span><br><span class="line">print(c.value) <span class="comment">#输出结果：hello, world</span></span><br><span class="line">d = ws[<span class="string">"B1"</span>]</span><br><span class="line">d.value = <span class="number">3.14</span></span><br><span class="line">print(d.value) <span class="comment">#输出结果：3.14</span></span><br></pre></td></tr></table></figure></p><p>启用格式和类型推断<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wb = load_workbook(<span class="string">'test.xlsx'</span>, guess_types=<span class="keyword">True</span>)</span><br><span class="line">ws = wb.create_sheet(<span class="string">"sheet2"</span>)</span><br><span class="line">c = ws[<span class="string">"B1"</span>]</span><br><span class="line">c.value = <span class="string">'12%'</span></span><br><span class="line">print(c.value)    <span class="comment">#输出结果：0.12</span></span><br><span class="line">d = ws[<span class="string">"B2"</span>]</span><br><span class="line">d.value = datetime.now()</span><br><span class="line">print(d.value)    <span class="comment">#输出结果：2018-06-12 17:19:10.700439</span></span><br></pre></td></tr></table></figure></p><ul><li>文件保存<br>直接调用<code>save()</code>方法即可。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.save(<span class="string">"test.xlsx"</span>)</span><br></pre></td></tr></table></figure></li></ul><p>注意</p><ol><li>当文件存在时会直接覆盖，不会给出提示或警告信息。  </li><li>当在操作系统中打开excel文件时调用保存方法，会出现<code>PermissionError</code>的错误，关闭即可。  </li><li><code>save()</code>提供另一个文件名，相当于另存为操作，不会影响原文件的内容。  <h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5>使用<code>openpyxl</code>进行excel的操作，主要是<code>Workbook</code>(excel文件)、<code>sheet</code>(excel中的sheet页)、<code>cell</code>(一个单元格)进行操作。<br>读写操作主要步骤：打开Workbook，定位sheet，操作cell。<br>关于<code>openpyxl</code>模块的更多介绍，可以点击<a href="https://openpyxl.readthedocs.io/en/stable/" target="_blank" rel="noopener">openpyxl - A Python library to read/write Excel 2010 xlsx/xlsm files</a>查看官方文档。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;csv数据处理&quot;&gt;&lt;a href=&quot;#csv数据处理&quot; class=&quot;headerlink&quot; title=&quot;csv数据处理&quot;&gt;&lt;/a&gt;csv数据处理&lt;/h3&gt;&lt;p&gt;csv表示”Comma-Separated Values(逗号分隔的值)”，csv文件时简化的电子表格，保存为纯文本文件。&lt;br&gt;python中解析csv文件可以使用csv模块。&lt;br&gt;注意：csv是文本文件，通过打开文件的操作，将其内容读入一个字符串，然后通过字符串的&lt;code&gt;split()&lt;/code&gt;方法处理每行文本取得值。需要注意csv文件中也有自己的转义字符，允许逗号或者其他字符作为值的一部分，&lt;code&gt;split()&lt;/code&gt;方法无法处理这部分转义字符。所以处理csv文件时为避免这些潜在的问题，建议使用csv模块处理csv文件。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="excel" scheme="https://rosinelan.github.io/tags/excel/"/>
    
      <category term="csv" scheme="https://rosinelan.github.io/tags/csv/"/>
    
  </entry>
  
  <entry>
    <title>python邮件发送</title>
    <link href="https://rosinelan.github.io/2018/06/06/python%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
    <id>https://rosinelan.github.io/2018/06/06/python邮件发送/</id>
    <published>2018-06-06T01:12:47.000Z</published>
    <updated>2018-06-08T13:42:24.735Z</updated>
    
    <content type="html"><![CDATA[<p>python中邮件发送可以使用<code>smtplib</code>模块，也可以使用第三方的<code>yagmail</code>模块。</p><h3 id="邮件收发简介"><a href="#邮件收发简介" class="headerlink" title="邮件收发简介"></a>邮件收发简介</h3><p>假如从<code>xx@126.com</code>发送一份邮件至<code>xx@sina.com</code>。首先使用<code>Foxmail</code>等软件写好邮件发送，这些软件称为<strong>MUA</strong>(Mail User Agent，邮件用户代理)。<br>邮件从MUA发出去之后，先发到<strong>MTA</strong>(Mail Transfer Agent，邮件传输代理)，也就是邮件服务提供商。我们的邮件是从<code>126.com</code>发送的，所以先被投递到网易提供的MTA，再由网易的MTA发到对方服务商，也就是新浪的MTA。<br>邮件到达新浪的MTA后，由于对方使用的是新浪的邮箱，因此新浪的MTA会将邮件投递至最终的目的地<strong>MDA</strong>(Mail Delivery Agent，邮件投递代理)。<br>邮件到达MDA之后就会存放在某个服务器，我们将这个长期保存邮件的地方称为电子邮箱。<br>编写程序发送邮件本质就是编写MUA把邮件发送到MTA；收取邮件就是编写MUA从MDA收邮件。<br><a id="more"></a><br>发邮件时，MUA和MTA使用额协议就是<code>SMTP</code>(Simple Mail Transfer Protocol),后面的MTA到另一个MTA也是使用SMTP协议。<br>收邮件时，MUA和MDA使用的协议有两种，<code>POP</code>(Post Office Protocol)，目前版本是3，称为<code>POP3</code>。<code>IMAP</code>(Internet Message Access Protocol)目前版本是4，优点是不但能收取邮件，还可以直接操作MDA上存储的邮件，比如从收件箱移动到垃圾箱等。<br>另外使用python发送邮件时需要注意：</p><ol><li>大多数邮件服务商需要手动打开SMTP发信和POP收信功能。否则只能网页登录。    </li><li>邮件客户端大多数要求使用客户端授权密码，而不是邮箱密码。需要网页登录设置。</li></ol><h3 id="smtplib"><a href="#smtplib" class="headerlink" title="smtplib"></a>smtplib</h3><p>python对SMTP支持的有<code>smtplib</code>和<code>email</code>2个模块，其中<code>email</code>负责构造邮件，<code>smtplib</code>负责发送邮件。  </p><h4 id="email构造邮件"><a href="#email构造邮件" class="headerlink" title="email构造邮件"></a>email构造邮件</h4><p>邮件构造主要使用<code>email.mime</code>。</p><ul><li>纯文本邮件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email <span class="keyword">import</span> encoders</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr, formataddr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_format_addr</span><span class="params">(s)</span>:</span></span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr((Header(name, <span class="string">'utf-8'</span>).encode(), addr))</span><br><span class="line"></span><br><span class="line">msg_from=<span class="string">'XXXXX@163.com'</span>                                 </span><br><span class="line">passwd=<span class="string">'XXXXX'</span>                                  </span><br><span class="line">msg_to=<span class="string">'XXXXX@qq.com'</span></span><br><span class="line">receivers = [<span class="string">'XXXXX@qq.com'</span>]                                                            </span><br><span class="line">subject=<span class="string">"python邮件测试"</span>                                       </span><br><span class="line">content=<span class="string">"hello, send by Python..."</span></span><br><span class="line"></span><br><span class="line">msg = MIMEText(content,<span class="string">'plain'</span>,<span class="string">'utf-8'</span>)</span><br><span class="line">msg[<span class="string">'Subject'</span>] = Header(subject,<span class="string">'utf-8'</span>).encode()</span><br><span class="line">msg[<span class="string">'From'</span>] = _format_addr(<span class="string">'xiaohh &lt;%s&gt;'</span> %msg_from)  <span class="comment">#此处xiaohh表示发件人的昵称</span></span><br><span class="line">msg[<span class="string">'To'</span>] = msg_to</span><br><span class="line"></span><br><span class="line">msg = MIMEText(content, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure></li></ul><p><code>_format_addr()</code>用于格式化邮件地址。如果包含中文，需要通过<code>Header</code>对象进行编码<br>构造<code>MIMEText</code>对象时，第一个参数是邮件正文，第二个参数是MIME的subtype，传入<code>plain</code>表示文本，最终的MIME就是<code>text/plain</code>，最后使用<code>utf-8</code>编码。<br><code>msg[&#39;T0&#39;]</code>接受的是字符串而不是列表，若有多个地址可使用<code>,</code>分隔。</p><ul><li><p>HTML邮件<br>在构造<code>MIMEText</code>对象时，把html字符串传进去，再把第二个参数由<code>plain</code>变为<code>html</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">content = ''&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;' +</span><br><span class="line">    <span class="string">'&lt;p&gt;send by &lt;a href="http://www.python.org"&gt;Python&lt;/a&gt;...&lt;/p&gt;'</span> +</span><br><span class="line">    <span class="string">'&lt;/body&gt;&lt;/html&gt;'</span><span class="string">'</span></span><br><span class="line"><span class="string">msg = MIMEText(content, '</span>plain<span class="string">', '</span>utf<span class="number">-8</span><span class="string">')</span></span><br></pre></td></tr></table></figure></li><li><p>发送附件<br>带附件的邮件可以看做包含若干部分的邮件：文本和各个附件本身，可以构造一个<code>MIMEMultipart</code>对象代表邮件本身，然后往里面添加<code>MIMEText</code>作为邮件正文，再继续往里面加上表示附件的<code>MIMEBase</code>对象即可。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg.attach(MIMEText(<span class="string">'send with file...'</span>, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)) <span class="comment">#邮件正文</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/Users/michael/Downloads/test.png'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    mime = MIMEBase(<span class="string">'image'</span>, <span class="string">'png'</span>, filename=<span class="string">'test.png'</span>) <span class="comment"># 设置附件的MIME和文件名，这里是png类型</span></span><br><span class="line">    mime.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=<span class="string">'test.png'</span>) <span class="comment"># 加上必要的头信息</span></span><br><span class="line">    mime.add_header(<span class="string">'Content-ID'</span>, <span class="string">'&lt;0&gt;'</span>)</span><br><span class="line">    mime.add_header(<span class="string">'X-Attachment-Id'</span>, <span class="string">'0'</span>)</span><br><span class="line">    mime.set_payload(f.read()) <span class="comment"># 把附件的内容读进来</span></span><br><span class="line">    encoders.encode_base64(mime) <span class="comment"># 用Base64编码</span></span><br><span class="line">    msg.attach(mime) <span class="comment"># 添加到MIMEMultipart</span></span><br></pre></td></tr></table></figure></li><li><p>发送图片<br>要想把图片嵌入到邮件正文中，直接在HTML邮件中链接图片地址是不可行的，因为邮件服务商无法确定链接是否指向恶意网站。<br>要把图片嵌入到正文中，需要按照发送附件的方式，先把图片作为附件添加进去，然后在HTML中通过引用<code>src=&quot;cid:0&quot;</code>就可以把附件作为图片嵌入。如果有多个图片，给它们依次编号，然后引用不同的<code>cid:x</code>即可。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg.attach(MIMEText(<span class="string">'&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;'</span> +</span><br><span class="line">    <span class="string">'&lt;p&gt;&lt;img src="cid:0"&gt;&lt;/p&gt;'</span> +</span><br><span class="line">    <span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>, <span class="string">'html'</span>, <span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure></li></ul><p>关于<code>email.mime</code>更多的说明可以点击<a href="https://docs.python.org/3/library/email.mime.html" target="_blank" rel="noopener">email.mime: Creating email and MIME objects from scratch</a>查看官方介绍。<br>关于<code>email</code>邮件构造和解析更多的说明可以点击<a href="https://docs.python.org/3/library/email.html" target="_blank" rel="noopener">email — An email and MIME handling package</a>查看官方介绍。</p><h4 id="smtplib发送邮件"><a href="#smtplib发送邮件" class="headerlink" title="smtplib发送邮件"></a>smtplib发送邮件</h4><p><code>smtplib</code>发送邮件，实例化<code>SMTP()</code>，指定smtp_server地址和端口号；<br>调用<code>logine()</code>方法登录SMTP服务器；<br>调用<code>sendmail()</code>方法发邮件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">25</span>) <span class="comment"># SMTP协议默认端口是25</span></span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure></p><p>由于邮件正文是<code>str</code>，所以<code>msg.as_string()</code>是将<code>MIMEText</code>对象变成<code>str</code>。  </p><ul><li>加密SMTP<br>使用25端口连接SMTP服务器时使用的是明文传输，要更安全的发送邮件，可以加密SMTP会话。  </li></ul><p><code>starttls()</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server = smtplib.SMTP(<span class="string">'smtp.gmail.com'</span>, <span class="number">587</span>) <span class="comment"># gmail加密传输端口是587</span></span><br><span class="line">server.starttls() <span class="comment">#创建安全连接</span></span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure></p><p>调用<code>starttls()</code>方式创建安全连接，其余代码和前面相同。<br><code>smtp_ssl()</code><br>在连接建立的时候就需要SSL并且不适合使用<code>starttls()</code>的情况下可以选择使用<code>smtp_ssl()</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server = smtplib.SMTP_SSL(smtp_server, <span class="number">465</span>) <span class="comment">#使用smtp_ssl()方法</span></span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure></p><p>备注：<code>starttls()</code>使用TLS，默认端口587；<code>smtp_ssl()</code>使用SSL，默认端口为465。此处需要根据邮件服务商提供的加密方式选择。<br>关于<code>smtplib</code>更多的说明可以点击<a href="https://docs.python.org/3/library/smtplib.html" target="_blank" rel="noopener">smtplib — SMTP protocol client</a>查看官方介绍。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email <span class="keyword">import</span> encoders</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr, formataddr</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_format_addr</span><span class="params">(s)</span>:</span></span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr((Header(name, <span class="string">'utf-8'</span>).encode(), addr))</span><br><span class="line"></span><br><span class="line">msg_from=<span class="string">'XXXXX@163.com'</span>                                 </span><br><span class="line">passwd=<span class="string">'XXXXX'</span>                                  </span><br><span class="line">msg_to=<span class="string">'XXXXX@qq.com'</span></span><br><span class="line">receivers = [<span class="string">'XXXXX@qq.com'</span>]                                                            </span><br><span class="line">subject=<span class="string">"python邮件测试"</span>                                       </span><br><span class="line">content=<span class="string">"hello, send by Python..."</span></span><br><span class="line"></span><br><span class="line">msg = MIMEText(content,<span class="string">'plain'</span>,<span class="string">'utf-8'</span>)</span><br><span class="line">msg[<span class="string">'Subject'</span>] = Header(subject,<span class="string">'utf-8'</span>).encode()</span><br><span class="line">msg[<span class="string">'From'</span>] = _format_addr(<span class="string">'xiaohh &lt;%s&gt;'</span> %msg_from)  <span class="comment">#此处xiaohh表示发件人的昵称</span></span><br><span class="line">msg[<span class="string">'To'</span>] = msg_to</span><br><span class="line"></span><br><span class="line">msg = MIMEText(content, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">25</span>)</span><br><span class="line">server.set_debuglevel(<span class="number">1</span>)</span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure><h3 id="yagmail"><a href="#yagmail" class="headerlink" title="yagmail"></a>yagmail</h3><p><code>yagmail</code>是一个第三方模块，点击<a href="https://github.com/kootenpv/yagmail" target="_blank" rel="noopener">yagmail</a>可以在github查看该项目使用说明及源码。<br>使用<code>yagmail</code>发送邮件简单方便，免去了构建邮件内容的繁琐步骤。  </p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>python2和python3的安装如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install yagmail</span><br><span class="line">pip3 install yagmail</span><br></pre></td></tr></table></figure></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>实例化<code>SMTP()</code>类，然后调用send()方法即可。<br>更多使用可以参考github项目主页说明。  </p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yagmail</span><br><span class="line"></span><br><span class="line">args = &#123;</span><br><span class="line">    <span class="string">"user"</span>: <span class="string">"xxxx@163.com"</span>,</span><br><span class="line">    <span class="string">"password"</span>: <span class="string">"xxxx"</span>,</span><br><span class="line">    <span class="string">"host"</span>: <span class="string">"smtp.163.com"</span>,</span><br><span class="line">    <span class="string">"port"</span>: <span class="string">"465"</span></span><br><span class="line">&#125;</span><br><span class="line">emailList = [<span class="string">'xxx@qq.com'</span>]</span><br><span class="line">yag = yagmail.SMTP(**args)</span><br><span class="line">yag.send(to=emailList, subject=<span class="string">"python邮件"</span>, contents=<span class="string">"Thanks for your python email!"</span>, attachments=<span class="string">"__init__.py"</span>)</span><br></pre></td></tr></table></figure><p><code>to</code>：收件人，多个收件人可以通过列表方式传递。<br><code>subject</code>：邮件主题。<br><code>contents</code>：邮件正文。<br><code>attachments</code>：附件，可以使用绝对路径。此处表示该文件夹和代码在同一目录。<br>另外，此处的<code>contents</code>可以传递列表，它可以自动识别文件格式。例如：<br>上面发送修改为如下格式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yag.send(to=emailList, subject=<span class="string">"python邮件"</span>, contents=[<span class="string">"Thanks for your python email!"</span>,<span class="string">"__init__.py"</span>])</span><br></pre></td></tr></table></figure></p><p>最后收到邮件效果和上面的代码一致。可自动将<code>__init__.py</code>识别为附件并添加。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python中邮件发送可以使用&lt;code&gt;smtplib&lt;/code&gt;模块，也可以使用第三方的&lt;code&gt;yagmail&lt;/code&gt;模块。&lt;/p&gt;
&lt;h3 id=&quot;邮件收发简介&quot;&gt;&lt;a href=&quot;#邮件收发简介&quot; class=&quot;headerlink&quot; title=&quot;邮件收发简介&quot;&gt;&lt;/a&gt;邮件收发简介&lt;/h3&gt;&lt;p&gt;假如从&lt;code&gt;xx@126.com&lt;/code&gt;发送一份邮件至&lt;code&gt;xx@sina.com&lt;/code&gt;。首先使用&lt;code&gt;Foxmail&lt;/code&gt;等软件写好邮件发送，这些软件称为&lt;strong&gt;MUA&lt;/strong&gt;(Mail User Agent，邮件用户代理)。&lt;br&gt;邮件从MUA发出去之后，先发到&lt;strong&gt;MTA&lt;/strong&gt;(Mail Transfer Agent，邮件传输代理)，也就是邮件服务提供商。我们的邮件是从&lt;code&gt;126.com&lt;/code&gt;发送的，所以先被投递到网易提供的MTA，再由网易的MTA发到对方服务商，也就是新浪的MTA。&lt;br&gt;邮件到达新浪的MTA后，由于对方使用的是新浪的邮箱，因此新浪的MTA会将邮件投递至最终的目的地&lt;strong&gt;MDA&lt;/strong&gt;(Mail Delivery Agent，邮件投递代理)。&lt;br&gt;邮件到达MDA之后就会存放在某个服务器，我们将这个长期保存邮件的地方称为电子邮箱。&lt;br&gt;编写程序发送邮件本质就是编写MUA把邮件发送到MTA；收取邮件就是编写MUA从MDA收邮件。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="email" scheme="https://rosinelan.github.io/tags/email/"/>
    
      <category term="yagmail" scheme="https://rosinelan.github.io/tags/yagmail/"/>
    
      <category term="mime" scheme="https://rosinelan.github.io/tags/mime/"/>
    
      <category term="smtp" scheme="https://rosinelan.github.io/tags/smtp/"/>
    
  </entry>
  
  <entry>
    <title>python网络编程之socketserver</title>
    <link href="https://rosinelan.github.io/2018/06/05/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocketserver/"/>
    <id>https://rosinelan.github.io/2018/06/05/python网络编程之socketserver/</id>
    <published>2018-06-05T01:23:34.000Z</published>
    <updated>2018-06-06T02:20:30.506Z</updated>
    
    <content type="html"><![CDATA[<p>关于socket的基础介绍可以点击<a href="https://rosinelan.coding.me/2018/06/01/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocket/" target="_blank" rel="noopener">python网络编程之socket</a>查看。  </p><h3 id="socketserver"><a href="#socketserver" class="headerlink" title="socketserver"></a>socketserver</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>socket并不能多并发，只能支持一个用户。socketserver则实现了并发处理。当有多个客户端连接时，socketserver都会在服务器上创建一个线程或进程来处理该客户端的请求，一个客户端对应一个服务端的进程或线程，这样增加系统的利用率。<br>socketserver是socket的封装，简化了编写网络服务程序的任务。python2中为<code>SocketServer</code>，python3中取消了首字母大写，改为<code>socketserver</code>。<br><a id="more"></a><br>socketserver中包含了两种类，一种为服务类(server class)，一种为请求处理类(request handle class)。前者提供了许多方法，像绑定、监听、运行(建立连接的过程)，后者则专注于如何处理用户所发送的数据(事务逻辑)。一般情况下，所有的服务都是先建立连接(也就是建立服务类的实例)，然后开始处理用户请求(也就是建立请求处理类的实例)。<br>socketserver有4个类，分别是<code>TCPServer</code>、<code>UDPServer</code>、<code>UnixStreamServer</code>和<code>UnixDatagramServer</code>。  </p><ol><li><code>class socketserver.TCPServer(server_address, RequestHandlerClass, bind_and_activate=True)</code><br>TCP协议</li><li><code>class socketserver.UDPServer(server_address, RequestHandlerClass, bind_and_activate=True)</code><br>UDP协议，传输过程中可能会造成数据丢失等情况。</li><li><code>class socketserver.UnixStreamServer(server_address, RequestHandlerClass, bind_and_activate=True)</code><br>tcp协议，用于unix机器的进程间通信，不可用于windows主机。</li><li><code>class socketserver.UnixDatagramServer(server_address, RequestHandlerClass, bind_and_activate=True)</code><br>udp协议，用于unix机器的进程间通信，不可用于windows主机。</li></ol><ul><li>继承关系  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------------+</span><br><span class="line">| BaseServer |</span><br><span class="line">+------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----------+        +------------------+</span><br><span class="line">| TCPServer |-------&gt;| UnixStreamServer |</span><br><span class="line">+-----------+        +------------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----------+        +--------------------+</span><br><span class="line">| UDPServer |-------&gt;| UnixDatagramServer |</span><br><span class="line">+-----------+        +--------------------+</span><br></pre></td></tr></table></figure></li></ul><p>上述的4个类用于处理同步的请求，也就是当前请求必须处理完成才能开始下一个请求。不适用于单个请求处理时间很长的情况。<br>单个请求处理需要很长时间的情况，可以创建一个单独的线程或进程去处理每个请求，<code>ForkingMixIn</code>和<code>ThreadingMixIn</code>类支持异步请求。<br>当从<code>ThreadingMixIn</code>继承线程连接时，应该明确声明线程意外关闭时的行为。<code>ThreadingMixIn</code>类中定义了一个属性<code>daemon_threads</code>，它用来标识服务器是否等待线程终止。如果希望线程自动执行，应该明确设置标识，默认情况下是<code>False</code>，也就是python将会在<code>ThreadingMixIn</code>创建的所有线程都退出之后才退出。<br>不论采用何种协议，服务类(server class)的外部方法和属性都是相同的。</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ol><li>创建一个请求处理类，并且这个类要继承<code>BaseRequsetHandler</code>类，重写父类的<code>handle()</code>方法。  </li><li>实例化一个服务类，并给它传递服务端IP地址和上面的请求处理类。推荐在server使用with语句。    </li><li>调用服务对象的<code>handle_request()</code>或者<code>serve_forever()</code>方法，前者用于处理一个请求，后者用于处理多个请求。  </li><li>调用<code>server_close()</code>关闭socket(使用with语句则不需要)。  </li></ol><h4 id="Server-创建说明"><a href="#Server-创建说明" class="headerlink" title="Server 创建说明"></a>Server 创建说明</h4><p><code>class socketserver.ForkingMixIn</code><br><code>class socketserver.ThreadingMixIn</code><br>创建forking和threading类型的服务端可以使用上面的mix-in类。例如，ThreadingUDPServer创建方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadingUDPServer</span><span class="params">(ThreadingMixIn, UDPServer)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>先写mix-in类是因为它重写了UDPServer中定义的一个方法。设置各种属性也会改变底层服务机制的运行。<br>下面提到的ForkingMixIn和Forking类只能在支持fork()的POSIX平台使用。<br><code>class socketserver.ForkingTCPServer</code><br><code>class socketserver.ForkingUDPServer</code><br><code>class socketserver.ThreadingTCPServer</code><br><code>class socketserver.ThreadingUDPServer</code><br>上面的几个类都是在<code>mix-in</code>类中预定义好的。<br>要实现服务，定义的类必须继承自BaseRequestHandler，并且要重新定义<code>handle()</code>方法。接下来将其中的server类和request handler类结合起来，就可以跑不同的服务。<code>datagram</code>和<code>stream</code>服务对应的request handler类不能相同。这个可以通过使用<code>handler</code>的子类<code>StreamRequestHandler</code>或<code>DatagramRequestHandler</code>隐式实现。<br>对于何时应该选用何种方式的服务，还是需要根据实际情况分析。  </p><h4 id="Server-对象"><a href="#Server-对象" class="headerlink" title="Server 对象"></a>Server 对象</h4><p><code>class socketserver.BaseServer(server_address, RequestHandlerClass)</code><br>BaseServer是所有Server对象的超类，它定义了下面的这些接口，但大多数都未实现，在子类中细化。  </p><ul><li>fileno()<br>返回server监听socket的文件描述符，整数。通常用来传递给select.select()以允许一个进程监视多个服务器。  </li><li>handle_request()<br>处理单个请求。该函数依次调用<code>get_request()</code>、<code>verify_request()</code>、<code>process_request()</code>方法。假如用户提提供的<code>handle()</code>方法抛出异常，将会调用服务端的<code>handle_error()</code>方法。如果在timeout时间(单位：s)内未接到用户请求，将会调用<code>handle_timeout()</code>并返回<code>handle_request()</code>。</li><li>serve_forever(poll_interval=0.5)<br>处理请求，直接收到一个明确的<code>shutdown()</code>请求。每隔pool_interval时间轮询一次shutdown。忽略timeout属性。  </li><li>server_actions()<br>在<code>serve_forever()</code>循环中调用。该方法可以在子类中重写，为指定的服务执行指定的动作。  </li><li>shutdown()<br>告诉<code>serve_forever()</code>循环停止并等待其停止。  </li><li>server_close()<br>清理服务。可以被重写。  </li><li>address_family()<br>server socket所属的协议簇。例如<code>socket.AF_INET</code>和<code>socket.AF_UNIX</code>。</li><li>RequestHandlerClass<br>用户提供的请求处理类。这个类为每个请求创建实例。  </li><li>server_address<br>server监听的地址。地址的格式由协议决定。对于<code>Internet protocols</code>，就是一个元组，包括字符串类型的地址和整型的端口号。  <h4 id="Request-Handler-对象"><a href="#Request-Handler-对象" class="headerlink" title="Request Handler 对象"></a>Request Handler 对象</h4><code>class socketserver.BaseRequestHandler</code><br>这是所有<code>request handler</code>对象的超类。它定义了下面的接口。一个具体的<code>request handler</code>子类必须定义一个新的<code>handle()</code>方法，并且可以重写任何其他的方法。会为每一个请求创建子类的实例。  </li><li>setup()<br>在<code>hanlde()</code>方法自行任何初始化动作之前被调用。默认什么也不做。  </li><li>handle()<br>该函数处理服务请求的所有工作。默认什么也不做。可用的几个实例的属性：<code>self.request</code>、<code>self.client_address</code>、<code>self.server</code>。<br>对于<code>stream</code>服务，<code>self.request</code>返回一个socket对象。对于<code>datagram</code>服务，<code>self.request</code>返回<code>string和socket</code>。</li><li>finsh()<br>在<code>handle()</code>方法之后被调用，执行一些清理动作。默认什么也不做。假如<code>setup()</code>出现异常，这个函数将不会被调用。<br><code>class socketserver.StreamRequestHandler</code><br><code>class socketserver.DatagramRequestHandler</code><br>上面的2个<code>BaseRequestHandler</code>的子类重写了<code>setup()</code>和<code>finsh()</code>方法，同时提供<code>self.rfile</code>和<code>self.wfile</code>属性。<code>self.rfile</code>和<code>self.wfile</code>可以读取或写入，以获得请求数据或将数据返回到客户端。  <h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><code>服务端</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTcpHandler</span><span class="params">(socketserver.BaseRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.data = self.request.recv(<span class="number">1024</span>).strip()</span><br><span class="line">                print(<span class="string">"&#123;&#125; wrote:"</span>.format(self.client_address[<span class="number">0</span>]), end=<span class="string">" "</span>)</span><br><span class="line">                print(self.data)</span><br><span class="line">                self.request.sendall(self.data.upper())</span><br><span class="line">            <span class="keyword">except</span> ConnectionResetError <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">"err "</span>, e)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    HOST, PORT = <span class="string">"localhost"</span>, <span class="number">9999</span></span><br><span class="line">    <span class="keyword">with</span> socketserver.ThreadingTCPServer((HOST, PORT), MyTcpHandler) <span class="keyword">as</span> server:</span><br><span class="line">        server.serve_forever()</span><br></pre></td></tr></table></figure></li></ul><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><code>客户端</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client = socket.socket()</span><br><span class="line">client.connect((<span class="string">'localhost'</span>, <span class="number">9999</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    msg = input(<span class="string">"&gt;&gt;&gt;"</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> len(msg) ==<span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    client.send(msg.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">"recv:&gt;"</span>,data.decode())</span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure><p>实现效果<br>在客户端输入内容，服务端可看到输入内容；<br>多个客户端可同时连接，服务端可分别显示不同客户端显示的内容。<br>更多关于socketserver的内容点击<a href="https://docs.python.org/3/library/socketserver.html" target="_blank" rel="noopener">socketserver — A framework for network servers</a>查看官方介绍。</p><h3 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select/poll/epoll"></a>select/poll/epoll</h3><p><code>select/poll/epoll</code>也是IO multiplexing(I/O多路复用)，有时候也称这种I/O方式为event driven IO。它的好处在于单个process就可以同时处理多个网络连接的I/O。<br>基本原理是<code>select/poll/epoll</code>函数会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>通过一个<code>select()</code>系统调用来监视多个文件描述符的数组，当<code>select()</code>返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。<br>selecet目前几乎所有的平台都支持。<br>一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。<br>另外，<code>select()</code>所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用<code>select()</code>会对所有的socket进行一次线性扫描，所以这也浪费了一定的开销。  </p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。<br>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。<br>另外，<code>select()</code>和<code>poll()</code>将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。  </p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。<br>epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。<br>另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</p><p>更多关于select模块的内容点击<a href="https://docs.python.org/3/library/select.html" target="_blank" rel="noopener">select — Waiting for I/O completion</a>查看官方介绍。<br>网络编程更多的关于<code>事件驱动模型</code>、<code>异步I/O</code>、<code>I/O多路复用</code>的内容可以参考<a href="http://www.cnblogs.com/bigberg/category/1097785.html" target="_blank" rel="noopener">网络编程基础</a>。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于socket的基础介绍可以点击&lt;a href=&quot;https://rosinelan.coding.me/2018/06/01/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocket/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;python网络编程之socket&lt;/a&gt;查看。  &lt;/p&gt;
&lt;h3 id=&quot;socketserver&quot;&gt;&lt;a href=&quot;#socketserver&quot; class=&quot;headerlink&quot; title=&quot;socketserver&quot;&gt;&lt;/a&gt;socketserver&lt;/h3&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;socket并不能多并发，只能支持一个用户。socketserver则实现了并发处理。当有多个客户端连接时，socketserver都会在服务器上创建一个线程或进程来处理该客户端的请求，一个客户端对应一个服务端的进程或线程，这样增加系统的利用率。&lt;br&gt;socketserver是socket的封装，简化了编写网络服务程序的任务。python2中为&lt;code&gt;SocketServer&lt;/code&gt;，python3中取消了首字母大写，改为&lt;code&gt;socketserver&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="socketserver" scheme="https://rosinelan.github.io/tags/socketserver/"/>
    
      <category term="handle" scheme="https://rosinelan.github.io/tags/handle/"/>
    
      <category term="TCPServer" scheme="https://rosinelan.github.io/tags/TCPServer/"/>
    
      <category term="UDPServer" scheme="https://rosinelan.github.io/tags/UDPServer/"/>
    
  </entry>
  
</feed>
