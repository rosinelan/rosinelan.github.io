<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>持续不断</title>
  
  <subtitle>要松懈的时候再坚持一下</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rosinelan.github.io/"/>
  <updated>2018-06-25T14:18:53.254Z</updated>
  <id>https://rosinelan.github.io/</id>
  
  <author>
    <name>小灰灰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python爬虫(三)</title>
    <link href="https://rosinelan.github.io/2018/06/25/python%E7%88%AC%E8%99%AB-%E4%B8%89/"/>
    <id>https://rosinelan.github.io/2018/06/25/python爬虫-三/</id>
    <published>2018-06-25T01:13:08.000Z</published>
    <updated>2018-06-25T14:18:53.254Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>Beautiful Soup</code>是python的一个库，主要功能是从网页抓取数据。<br>它是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间。<br>通过使用该库，可以不编写正则就可以方便的实现网页信息的抓取。<br><a id="more"></a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="Beautiful-Soup安装"><a href="#Beautiful-Soup安装" class="headerlink" title="Beautiful Soup安装"></a>Beautiful Soup安装</h5><p><code>Beautiful Soup</code>安装很简单，直接<code>pip install beautifulsoup4</code>即可安装。  </p><h5 id="解析器安装"><a href="#解析器安装" class="headerlink" title="解析器安装"></a>解析器安装</h5><p>Beautiful Soup支持Python标准库中的HTML解析器,还支持一些第三方的解析器，如果我们不安装它，则 Python 会使用 Python默认的解析器，lxml 解析器更加强大，速度更快，推荐安装。  </p><table><thead><tr><th>解析器</th><th style="text-align:left">使用方法</th><th style="text-align:left">优势</th><th style="text-align:left">劣势</th></tr></thead><tbody><tr><td>Python标准库</td><td style="text-align:left"><code>BeautifulSoup(markup, &quot;html.parser&quot;)</code></td><td style="text-align:left">ython的内置标准库<br>执行速度适中<br>文档容错能力强</td><td style="text-align:left">ython 2.7.3 or 3.2.2)前 的版本中文档容错能力差</td></tr><tr><td>lxml HTML 解析器</td><td style="text-align:left"><code>BeautifulSoup(markup, &quot;lxml&quot;)</code></td><td style="text-align:left">速度快<br>文档容错能力强</td><td style="text-align:left">需要安装C语言库</td></tr><tr><td>lxml XML 解析器</td><td style="text-align:left"><code>BeautifulSoup(markup, [&quot;lxml&quot;, &quot;xml&quot;])</code> <code>BeautifulSoup(markup, &quot;xml&quot;)</code></td><td style="text-align:left">速度快<br>唯一支持XML的解析器</td><td style="text-align:left">需要安装C语言库</td></tr><tr><td>html5lib</td><td style="text-align:left"><code>BeautifulSoup(markup, &quot;html5lib&quot;)</code></td><td style="text-align:left">最好的容错性<br>以浏览器的方式解析文档<br>生成HTML5格式的文档</td><td style="text-align:left">速度慢<br>不依赖外部扩展</td></tr></tbody></table><p>lxml安装<code>pip install lxml</code><br>html5lib安装<code>pip install html5lib</code>  </p><h4 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string">&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line">print(soup.prettify())</span><br><span class="line">print(soup.title)</span><br><span class="line">print(soup.title.name)</span><br><span class="line">print(soup.title.string)</span><br><span class="line">print(soup.title.parent.name)</span><br><span class="line">print(soup.p)</span><br><span class="line">print(soup.p[<span class="string">"class"</span>])</span><br><span class="line">print(soup.a)</span><br><span class="line">print(soup.find_all(<span class="string">'a'</span>))</span><br><span class="line">print(soup.find(id=<span class="string">'link3'</span>))</span><br></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;title&gt;</span><br><span class="line">   The Dormouse<span class="string">'s story</span></span><br><span class="line"><span class="string">  &lt;/title&gt;</span></span><br><span class="line"><span class="string"> &lt;/head&gt;</span></span><br><span class="line"><span class="string"> &lt;body&gt;</span></span><br><span class="line"><span class="string">  &lt;p class="title"&gt;</span></span><br><span class="line"><span class="string">   &lt;b&gt;</span></span><br><span class="line"><span class="string">    The Dormouse'</span>s story</span><br><span class="line">   &lt;/b&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class="story"&gt;</span><br><span class="line">   Once upon a time there were three little sisters; <span class="keyword">and</span> their names were</span><br><span class="line">   &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;</span><br><span class="line">    Elsie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ,</span><br><span class="line">   &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;</span><br><span class="line">    Lacie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   <span class="keyword">and</span></span><br><span class="line">   &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;</span><br><span class="line">    Tillie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ;</span><br><span class="line"><span class="keyword">and</span> they lived at the bottom of a well.</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class="story"&gt;</span><br><span class="line">   ...</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;title&gt;The Dormouse<span class="string">'s story&lt;/title&gt;</span></span><br><span class="line"><span class="string">title</span></span><br><span class="line"><span class="string">The Dormouse'</span>s story</span><br><span class="line">head</span><br><span class="line">&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span><br><span class="line">[<span class="string">'title'</span>]</span><br><span class="line">&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;</span><br><span class="line">[&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;, &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;, &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]</span><br><span class="line">&lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>注意，此处使用解析器为<code>lxml</code>，需要提前安装。<br>使用BeautifulSoup解析这段代码,能够得到一个 BeautifulSoup 的对象,并能按照标准的缩进格式的结构输出。<br>同时我们通过下面代码可以分别获取所有的链接，以及文字内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> soup.find_all(<span class="string">'a'</span>):</span><br><span class="line">    print(link.get(<span class="string">'href'</span>))</span><br><span class="line"></span><br><span class="line">print(soup.get_text())</span><br></pre></td></tr></table></figure></p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ul><li>标签选择器<br>在上面的代码中有<code>soup.title</code> <code>soup.head</code> <code>soup.p</code>。<br>通过<code>soup.标签名</code>可以得到标签的内容。当文旦中有多个这样的标签，返回第一个标签的内容。  </li><li>获取名称<br>通过<code>soup.title.name</code>可以得到title标签的名称。  </li><li>获取属性<br>获取p标签的name属性方式<br><code>soup.p.attrs[&#39;name&#39;]</code><br><code>soup.p[&#39;name&#39;]</code>  </li><li>获取内容<br><code>soup.p.string</code>可以得到第一个p标签的内容。  </li><li>嵌套选择<br><code>soup.head.title.string</code>  </li><li><p>子节点和子孙节点<br><strong>contents</strong><br><code>soup.p.contents</code> 将p标签下的所有子标签存到一个列表中<br><strong>children</strong><br><code>soup.p.children</code> 将p标签下的所有子标签放到一个可迭代对象<br>此处content和children得到的结果相同，只是一个为列表，一个是可迭代对象，需要通过循环读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,child <span class="keyword">in</span> enumerate(soup.p.children):</span><br><span class="line">    print(i,child)</span><br></pre></td></tr></table></figure></li><li><p>父节点<br><code>soup.a.parent</code> 获取父节点信息<br>通过list(enumerate(soup.a.parents))可以获取祖先节点，这个方法返回的结果是一个列表，会分别将a标签的父节点的信息存放到列表中，以及父节点的父节点也放到列表中，并且最后还会讲整个文档放到列表中，所有列表的最后一个元素以及倒数第二个元素都是存的整个文档的信息  </p><h4 id="标准选择器"><a href="#标准选择器" class="headerlink" title="标准选择器"></a>标准选择器</h4></li><li>fina_all<br>find_all(name,attrs,recursive,text,<strong>kwargs)<br>可以根据标签名，属性，内容查找文档</strong>name<strong><br><code>soup.find_all(&#39;ul&#39;)</code> 返回列表</strong>attrs**<br>attrs可以传入字典的方式来查找标签，但是这里有个特殊的就是class,因为class在python中是特殊的字段，所以如果想要查找class相关的可以更改attrs={‘class_’:’element’}或者soup.find_all(‘’,{“class”:”element})，特殊的标签属性可以不写attrs，例如id  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(attrs=&#123;<span class="string">'id'</span>: <span class="string">'list-1'</span>&#125;)</span><br><span class="line">soup.find_all(attrs=&#123;<span class="string">'name'</span>: <span class="string">'elements'</span>&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>text</strong><br><code>soup.find_all(text=&#39;Foo&#39;)</code><br>结果返回的是列表形式的查到的所有的text=’Foo’的文本  </p><ul><li>find<br>find(name,attrs,recursive,text,**kwargs)<br>find返回的匹配结果的第一个元素<br>还有其他一些方法<br>find_parents()返回所有祖先节点，find_parent()返回直接父节点<br>find_next_siblings()返回后面所有兄弟节点，find_next_sibling()返回后面第一个兄弟节点<br>find_previous_siblings()返回前面所有兄弟节点，find_previous_sibling()返回前面第一个兄弟节点<br>find_all_next()返回节点后所有符合条件的节点, find_next()返回第一个符合条件的节点<br>find_all_previous()返回节点后所有符合条件的节点, find_previous()返回第一个符合条件的节点  <h4 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h4>通过select()直接传入CSS选择器就可以完成选择<br><code>.</code>表示class<br><code>#</code>表示id<br><code>标签1，标签2</code>找到所有的标签1和标签2<br><code>标签1 标签2</code> 找到标签1内部的所有的标签2<br><code>[atrr=value]</code> 找到具有某个属性的所有标签  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">soup.select(<span class="string">'.panel .panel-heading'</span>)</span><br><span class="line">soup.select(<span class="string">'ul li'</span>)</span><br><span class="line">soup.select(<span class="string">'#list-2 .element'</span>)</span><br></pre></td></tr></table></figure></li></ul><p><strong>获取内容</strong><br>通过<code>get_text()</code>获取文本内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> soup.select(<span class="string">'li'</span>):</span><br><span class="line">    print(li.get_text())</span><br></pre></td></tr></table></figure></p><p><strong>获取属性</strong><br>通过[属性名]或者attrs[属性名]获取属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ul <span class="keyword">in</span> soup.select(<span class="string">'ul'</span>):</span><br><span class="line">    print(ul[<span class="string">'id'</span>])</span><br><span class="line">    print(ul.attrs[<span class="string">'id'</span>])</span><br></pre></td></tr></table></figure></p><p>更多关于<code>Beautiful Soup</code>内容可以点击<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" target="_blank" rel="noopener">Beautiful Soup 4.2.0 文档</a>查看官方文档介绍。<br>点击<a href="https://cuiqingcai.com/1319.html" target="_blank" rel="noopener">Python爬虫利器二之Beautiful Soup的用法</a>查看更多总结。<br>点击<a href="http://www.cnblogs.com/zhaof/" target="_blank" rel="noopener"> python修行路</a>查看更多内容。  </p><h3 id="webdriver"><a href="#webdriver" class="headerlink" title="webdriver"></a>webdriver</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Selenium 是自动化测试工具。它支持各种浏览器，包括 Chrome，Safari，Firefox 等主流界面式浏览器，如果你在这些浏览器里面安装一个 Selenium 的插件，那么便可以方便地实现Web界面的测试。换句话说叫 Selenium 支持这些浏览器驱动。<br>Selenium 2，又名 WebDriver，它的主要新功能是集成了 Selenium 1.0 以及 WebDriver（WebDriver 曾经是 Selenium 的竞争对手）。也就是说 Selenium 2 是 Selenium 和 WebDriver 两个项目的合并，即 Selenium 2 兼容 Selenium，它既支持 Selenium API 也支持 WebDriver API。  </p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p><code>pip install selenium</code>  </p><p>还需要安装驱动，根据不同浏览器需要选择不同的驱动，下面地址是chrome驱动。<br>链接：<a href="https://pan.baidu.com/s/1qZ2LfmW" target="_blank" rel="noopener">https://pan.baidu.com/s/1qZ2LfmW</a> 密码：qixa<br>下载以后，并把chromdriver放在chrome.exe同级目录下面，我的windows下面地址为<code>C:\Program Files (x86)\Google\Chrome\Application</code>。<br>也可以将对应地址添加在环境变量中。<br>下面代码实现了在chrome中打开百度首页，然后自动关闭的功能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">chromedriver = <span class="string">"C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe"</span></span><br><span class="line">browser = webdriver.Chrome(chromedriver)</span><br><span class="line">url = <span class="string">"https://www.baidu.com"</span></span><br><span class="line">browser.get(url=url)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure></p><h4 id="元素查找"><a href="#元素查找" class="headerlink" title="元素查找"></a>元素查找</h4><h5 id="单个元素查找"><a href="#单个元素查找" class="headerlink" title="单个元素查找"></a>单个元素查找</h5><p>查找元素有下面几种<br><code>find_element_by_name</code><br><code>find_element_by_id</code><br><code>find_element_by_xpath</code><br><code>find_element_by_link_text</code><br><code>find_element_by_partial_link_text</code><br><code>find_element_by_tag_name</code><br><code>find_element_by_class_name</code><br><code>find_element_by_css_selector</code><br>示例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">chromedriver = <span class="string">"C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe"</span></span><br><span class="line">browser = webdriver.Chrome(chromedriver)</span><br><span class="line">url = <span class="string">"http://www.taobao.com"</span></span><br><span class="line">browser.get(url=url)</span><br><span class="line">input_first = browser.find_element_by_id(<span class="string">"q"</span>)  <span class="comment">#通过id</span></span><br><span class="line">input_second = browser.find_element_by_css_selector(<span class="string">"#q"</span>) <span class="comment">#通过css选择器</span></span><br><span class="line">input_third = browser.find_element_by_xpath(<span class="string">'//*[@id="q"]'</span>) <span class="comment">#通过xpath选择器</span></span><br><span class="line">print(input_first)</span><br><span class="line">print(input_second)</span><br><span class="line">print(input_third)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class="string">"7341f32aea4238856409f236325848fc"</span>, element=<span class="string">"0.4317776711082031-1"</span>)&gt;</span><br><span class="line">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class="string">"7341f32aea4238856409f236325848fc"</span>, element=<span class="string">"0.4317776711082031-1"</span>)&gt;</span><br><span class="line">&lt;selenium.webdriver.remote.webelement.WebElement (session=<span class="string">"7341f32aea4238856409f236325848fc"</span>, element=<span class="string">"0.4317776711082031-1"</span>)&gt;</span><br></pre></td></tr></table></figure></p><p>还可以通过导入By模块方式使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line">input_first = browser.find_element(By.ID, <span class="string">"q"</span>)</span><br></pre></td></tr></table></figure></p><p>该方法和其他类似，<code>By.ID</code>中ID也可以替换成name等。  </p><h5 id="多个元素查找"><a href="#多个元素查找" class="headerlink" title="多个元素查找"></a>多个元素查找</h5><p>多个元素查找就是使用<code>find_elements</code>，单个使用<code>find_element</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">chromedriver = <span class="string">"C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe"</span></span><br><span class="line">browser = webdriver.Chrome(chromedriver)</span><br><span class="line">browser.get(<span class="string">"http://www.taobao.com"</span>)</span><br><span class="line">lis = browser.find_elements_by_css_selector(<span class="string">'.service-bd li'</span>)</span><br><span class="line">print(lis)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure></p><p>此时得到的结果是列表。<br><strong>xpath说明</strong><br>XPath是XML Path的简称，由于HTML文档本身就是一个标准的XML页面，所以我们可以使用XPath的语法来定位页面元素。<br>绝对路径<br><code>根元素开始用/</code><br>相对路劲<br><code>任意符合条件的元素 //</code><br>查找页面上所有的input元素<br><code>//input</code><br>查找页面上第一个form元素内的直接子input元素(即只包括form元素的下一级input元素，使用绝对路径表示，单/号)<br><code>//form[1]/input</code><br>查找页面上第一个form元素内的所有子input元素(只要在form元素内的input都算，不管还嵌套了多少个其他标签，使用相对路径表示，双//号)<br><code>//form[1]//input</code><br>查找页面上第一个form元素<br><code>//form[1]</code><br>查找页面上id为loginForm的form元素<br><code>//form[@id=&#39;loginForm&#39;]</code><br>查找页面上具有name属性为username的input元素<br><code>//input[@name=&#39;username&#39;]</code><br>查找页面上id为loginForm的form元素下的第一个input元素<br><code>//form[@id=&#39;loginForm&#39;]/input[1]</code><br>查找页面具有name属性为contiune并且type属性为button的input元素<br><code>//input[@name=&#39;continue&#39;][@type=&#39;button&#39;]</code><br>查找页面上id为loginForm的form元素下第4个input元素<br><code>//form[@id=&#39;loginForm&#39;]/input[4]</code>  </p><h4 id="控件交互"><a href="#控件交互" class="headerlink" title="控件交互"></a>控件交互</h4><p>清空输入框数据<br><code>element.clear()</code><br>发送数据<br><code>element.sendkeys(“username”)</code><br>获取文本的值<br><code>element.text</code><br>点击按钮<br><code>element.click()</code><br>表单提交<br><code>element.submit()</code><br>单选和多选框<br><code>element.clear()</code><br><code>element = browser.find_elements_by_id(&#39;checkbox&#39;)</code>  </p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>获取cookies<br><code>browser.get_cookies()</code><br>获取浏览器头名字<br><code>browser.title</code><br>关闭浏览器<br><code>browser.close()</code><br>前进<br><code>browser.forward()</code><br>后退<br><code>browser.back()</code><br>刷新<br><code>browser.refresh()</code><br>返回当前页面url<br><code>browser.current_url</code>  </p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>下面是利用driver实现自动登录京东网站并获取到cookie的操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://passport.jd.com/new/login.aspx?ReturnUrl=https%3A%2F%2Fwww.jd.com%2F'</span></span><br><span class="line">chromedriver = <span class="string">"C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe"</span></span><br><span class="line">driver = webdriver.Chrome(chromedriver)</span><br><span class="line">driver.get(url)</span><br><span class="line">time.sleep(random.uniform(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">driver.find_elements_by_xpath(<span class="string">'//a[@clstag="pageclick|keycount|login_pc_201804112|10"]'</span>)[<span class="number">0</span>].click() <span class="comment">#默认为二维码扫描登录，此处为切换到用户账户登录</span></span><br><span class="line">time.sleep(random.uniform(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">driver.find_element_by_id(<span class="string">'loginname'</span>).clear() <span class="comment">#清空默认用户名</span></span><br><span class="line">time.sleep(random.uniform(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">driver.find_element_by_id(<span class="string">'loginname'</span>).send_keys(<span class="string">"xxxxx"</span>) <span class="comment">#输入用户名</span></span><br><span class="line">time.sleep(random.uniform(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">driver.find_element_by_id(<span class="string">'nloginpwd'</span>).send_keys(<span class="string">"xxxxx"</span>) <span class="comment">#输入密码</span></span><br><span class="line">time.sleep(random.uniform(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">driver.find_element_by_id(<span class="string">'loginsubmit'</span>).click() <span class="comment">#点击登录按钮</span></span><br><span class="line">time.sleep(random.uniform(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">print(driver.get_cookies())</span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure></p><p><code>time.sleep(random.uniform(1, 3))</code>是当前操作之后随机暂停，模拟人的操作，防止被封。  </p><p>更多关于<code>webdriver</code>内容可以点击<a href="http://selenium-python.readthedocs.io/index.html" target="_blank" rel="noopener">Selenium with Python</a>查看官方文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Beautiful-Soup&quot;&gt;&lt;a href=&quot;#Beautiful-Soup&quot; class=&quot;headerlink&quot; title=&quot;Beautiful Soup&quot;&gt;&lt;/a&gt;Beautiful Soup&lt;/h3&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Beautiful Soup&lt;/code&gt;是python的一个库，主要功能是从网页抓取数据。&lt;br&gt;它是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间。&lt;br&gt;通过使用该库，可以不编写正则就可以方便的实现网页信息的抓取。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="webdriver" scheme="https://rosinelan.github.io/tags/webdriver/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫(二)</title>
    <link href="https://rosinelan.github.io/2018/06/19/python%E7%88%AC%E8%99%AB-%E4%BA%8C/"/>
    <id>https://rosinelan.github.io/2018/06/19/python爬虫-二/</id>
    <published>2018-06-19T07:34:06.000Z</published>
    <updated>2018-06-19T12:51:06.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="urllib模块"><a href="#urllib模块" class="headerlink" title="urllib模块"></a>urllib模块</h3><p>python2中有<code>urllib</code>和<code>urllib2</code>2个模块，虽然<code>urllib2</code>是升级版，但是依然不能替代<code>urllib</code>，各有所长。<br>python3中全部封装成一个<code>urllib</code>。  </p><h4 id="python2中的ubllib和urllib2"><a href="#python2中的ubllib和urllib2" class="headerlink" title="python2中的ubllib和urllib2"></a>python2中的ubllib和urllib2</h4><p>urllib 和urllib2都是接受URL请求的相关模块，但是urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，urllib不可以伪装你的User Agent字符串等。<br>urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。<br><a id="more"></a></p><h4 id="python3和python2使用差异"><a href="#python3和python2使用差异" class="headerlink" title="python3和python2使用差异"></a>python3和python2使用差异</h4><p>使用urllib中的request发送数据，无法直接传入字典类的参数，需要进行数据转换。<br>python2中为<code>data = urlib.urlencode(data) urllib2.Request(url, data)</code>，示例如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib, urllib2</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36"</span>,</span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"www.baidu.com"</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;<span class="string">"k1"</span>: <span class="string">"v1"</span>, <span class="string">"k2"</span>: <span class="string">"v2"</span>&#125;</span><br><span class="line">data = urllib.urlencode(data)</span><br><span class="line">print(data)    <span class="comment">#输出结果：k2=v2&amp;k1=v1</span></span><br><span class="line">response = urllib2.Request(url=url, headers=headers, data=data)</span><br></pre></td></tr></table></figure></p><p>python3中<code>data = urllib.parse.urlencode(data) urllib.request.Request(url, data)</code>，示例如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> Request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36"</span>,</span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"www.baidu.com"</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;<span class="string">"k1"</span>: <span class="string">"v1"</span>, <span class="string">"k2"</span>: <span class="string">"v2"</span>&#125;</span><br><span class="line">data = parse.urlencode(data)</span><br><span class="line">print(data)    <span class="comment">#输出结果：k2=v2&amp;k1=v1</span></span><br><span class="line">response = Request(url=url, headers=headers, data=data)</span><br></pre></td></tr></table></figure></p><ul><li>urllib下载</li></ul><ol><li><p>使用urllib中的<code>request.urlretrieve</code>方法  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://inews.gtimg.com/newsapp_match/0/3967692951/0"</span></span><br><span class="line">request.urlretrieve(url, <span class="string">'qq.jpg'</span>)</span><br></pre></td></tr></table></figure></li><li><p>使用<code>urlopen</code>得到response信息，然后读取  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://inews.gtimg.com/newsapp_match/0/2711870562/0"</span></span><br><span class="line">req = request.Request(url)</span><br><span class="line">res = request.urlopen(req)</span><br><span class="line">text = res.read()</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"2.jpg"</span>, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(text)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;urllib模块&quot;&gt;&lt;a href=&quot;#urllib模块&quot; class=&quot;headerlink&quot; title=&quot;urllib模块&quot;&gt;&lt;/a&gt;urllib模块&lt;/h3&gt;&lt;p&gt;python2中有&lt;code&gt;urllib&lt;/code&gt;和&lt;code&gt;urllib2&lt;/code&gt;2个模块，虽然&lt;code&gt;urllib2&lt;/code&gt;是升级版，但是依然不能替代&lt;code&gt;urllib&lt;/code&gt;，各有所长。&lt;br&gt;python3中全部封装成一个&lt;code&gt;urllib&lt;/code&gt;。  &lt;/p&gt;
&lt;h4 id=&quot;python2中的ubllib和urllib2&quot;&gt;&lt;a href=&quot;#python2中的ubllib和urllib2&quot; class=&quot;headerlink&quot; title=&quot;python2中的ubllib和urllib2&quot;&gt;&lt;/a&gt;python2中的ubllib和urllib2&lt;/h4&gt;&lt;p&gt;urllib 和urllib2都是接受URL请求的相关模块，但是urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，urllib不可以伪装你的User Agent字符串等。&lt;br&gt;urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="爬虫" scheme="https://rosinelan.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="urllib" scheme="https://rosinelan.github.io/tags/urllib/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫</title>
    <link href="https://rosinelan.github.io/2018/06/13/python%E7%88%AC%E8%99%AB/"/>
    <id>https://rosinelan.github.io/2018/06/13/python爬虫/</id>
    <published>2018-06-13T10:02:18.000Z</published>
    <updated>2018-06-19T12:37:13.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="爬虫介绍"><a href="#爬虫介绍" class="headerlink" title="爬虫介绍"></a>爬虫介绍</h3><h4 id="爬虫定义"><a href="#爬虫定义" class="headerlink" title="爬虫定义"></a>爬虫定义</h4><p>爬虫是请求网站并提取自己所需要数据的过程。通过我们的程序，可以代替我们向服务器发送请求，然后进行批量的数据下载。  </p><h4 id="爬虫基本流程"><a href="#爬虫基本流程" class="headerlink" title="爬虫基本流程"></a>爬虫基本流程</h4><ol><li>发起请求<br>通过url向服务器发送requests请求，请求可以包含额外的header信息。<a id="more"></a></li><li>获取响应内容<br>如果服务器正常响应，那么将受到一个response，response即为我们所请求的网页内容，可能包含html\json\二进制数据(图片、视频)等。</li><li>解析内容<br>如果是html代码则可以使用网页解析器进行解析；如果是json数据则可以转换成json对象进行解析；如果是二进制数据则可以保存到文件进行进一步的处理。</li><li>保存数据<br>可以保存到本地文件，也可以保存到数据库(mysql\redis\mongodb等)。<h4 id="requests请求"><a href="#requests请求" class="headerlink" title="requests请求"></a>requests请求</h4>当我们通过浏览器向服务器发送requests请求时，这个request包含什么内容？可以通过chrome浏览器的开发人员工具(F12)查看。  </li><li>请求方式<br>最常用的请求方式包括get请求和post请求。<br>post请求在开发中最常见的是通过表单进行提交，从用户角度来讲最常见的就是登陆验证。当你需要输入一些信息进行登陆的时候，这次请求就是post请求。<br>get请求最常见的就是搜索回车之后，信息将以?间隔添加在url后面。类似于<code>https://www.baidu.com/s?wd=python3%20requests</code>。而且get请求是用来获取数据，是幂等的。<br>其他还包括put请求(向服务端发送信息从而改变内容)和delete请求(删除资源)。<br>对于资源的操作，其实都可以通过post/get完成，不需要用到put/delete，实际中put/delete也很少用。    </li><li>uri统一资源定位符<br>一个网址、一个视频、一个图片都可以用uri去定义</li><li>requests headers<br>请求头，包括这次请求的类型，cookie信息以及浏览器类型等。<br>请求头在我们进行网页抓取的时候，服务器会通过解析请求头来进行信息的审核，判断请求是否为合法请求。所以当我们通过程序伪装浏览器进行请求的时候可以设置请求头的信息。  </li><li>请求体<br>post请求会把用户信息包装在form-data里面进行提交，因此相比于get请求，post请求的Headers标签的内容会多出Form Data这个信息包。<h4 id="response"><a href="#response" class="headerlink" title="response"></a>response</h4></li><li>响应状态<br>通过Headers中的General可以看到<code>status code</code>，使用数字代码表示对于状态，200表示成功，301跳转，404找不到网页，502服务器错误等。</li><li>响应头<br>包括内容的类型，cookie信息等。</li><li>响应体<br>请求的目的就是为了得到响应体，包括html代码，json及二进制数据等。<h3 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h3>安装使用<code>pip install requests</code>即可。  </li></ol><ul><li>通过requests进行网页请求<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line">response = requests.get(<span class="string">'https://www.baidu.com'</span>)  </span><br><span class="line">print(response.text)  <span class="comment">#输出结果为html，中文乱码</span></span><br><span class="line">response.encoding = <span class="string">'utf-8'</span>  <span class="comment">#修改编码</span></span><br><span class="line">print(response.text)  <span class="comment">#输出中文正常</span></span><br><span class="line">print(response.status_code) <span class="comment">#输出状态码，200</span></span><br></pre></td></tr></table></figure></li></ul><p>返回的response为文本时通过<code>response.text</code>读取；图片和视频等二进制文件通过<code>response.content</code>读取。</p><ul><li>通过添加请求头信息<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.75 Safari/537.36'</span>&#125;</span><br><span class="line"> response1 = requests.get(<span class="string">'https://www.baidu.com'</span>, headers=headers)</span><br></pre></td></tr></table></figure></li></ul><p>可以通过定义一个列表，然后通过random模块随机取一个header信息进行访问，防止一些反爬虫的操作。  </p><ul><li><p>获取cookie信息<br>cookie的五要素包括<code>name</code>、<code>value</code>、<code>domain</code>、<code>path</code>和<code>expires</code>。我们可以使用requests模块通过会话信息获取这些信息。<br><code>domain</code><br>代表cookie所在的域，默认情况下就是请求的域名，例如请求<a href="http://www.server1.com/files/hello" target="_blank" rel="noopener">http://www.server1.com/files/hello</a>, 那么响应中的set-Cookie默认会使用www.server1.com作为cookie的domain，在浏览器中也是按照domain来组织cookie的。 我们可以在响应中设置cookie的domain为其他域，但是浏览器并不会去保存这些domain为其他域的cookie。<br><code>path</code> 路径<br>path能够进一步的控制cookie的访问，当path=/，当前域的所有请求都可以访问到这个cookie。如果path设为其他值，比如path=/test,那么只有/test下面的请求可以访问到这个cookie。<br><code>expires</code> 过期时间<br><code>name</code> 对应的key值<br><code>value</code>  key对应的value值  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://www.hao123.com/"</span></span><br><span class="line">session = requests.session()</span><br><span class="line">response = session.get(url=url).text</span><br><span class="line">cookies = session.cookies</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookies:</span><br><span class="line">    print(cookie.name)</span><br><span class="line">    print(cookie.value)</span><br><span class="line">    print(cookie.domain)</span><br><span class="line">    print(cookie.path)</span><br><span class="line">    print(cookie.expires)</span><br></pre></td></tr></table></figure></li><li><p>使用已知的cookie信息访问网站</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cookie = dict(_ga=<span class="string">"GA1.2.208618761.1528809975"</span>, _gid=<span class="string">"GA1.2.604525626.1528979734"</span>, PHPSESSID=<span class="string">"ait0b8c22ofqpo630cekpc33b6"</span>, _gat=<span class="string">"1"</span>, Hm_lvt_0936ebcc9fa24aa610a0079314fec2d3=<span class="string">"1528809975,1528809984,1528979734,1528980228"</span>, Hm_lpvt_0936ebcc9fa24aa610a0079314fec2d3=<span class="string">"1528980228"</span>, ape__Session=<span class="string">"ait0b8c22ofqpo630cekpc33b6"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://httpbin.org/cookies"</span></span><br><span class="line">session = requests.session()</span><br><span class="line">res = session.get(url=url, cookies=cookie)</span><br><span class="line">res.encoding = res.apparent_encoding</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure></li><li><p>使用代理访问网站<br>采集信息时为避免IP地址被封，可以使用代理方式访问，可以通过requests模块的proxies属性。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://2018.ip138.com/ic.asp"</span></span><br><span class="line">proxy = &#123;<span class="string">"http"</span>: <span class="string">"http://221.228.17.172:8181"</span>&#125;</span><br><span class="line">res1 = requests.get(url=url, proxies=proxy)</span><br><span class="line">res2 = requests.get(url=url)</span><br><span class="line">res1.encoding = res1.apparent_encoding</span><br><span class="line">res2.encoding = res2.apparent_encoding</span><br><span class="line">print(res1.text)    <span class="comment">#输出结果为代理IP信息</span></span><br><span class="line">print(<span class="string">"###"</span>*<span class="number">10</span>)</span><br><span class="line">print(res2.text)    <span class="comment">#输出结果为本机IP信息</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>总结</strong><br>requests模块提供的接口，在传输数据的时候，都可以以<code>key:value</code>的形式进行传输，方便数据处理。<br>关于requests中文乱码的问题，可以参考<a href="http://xiaorui.cc/2016/02/19/%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90python-requests%E5%BA%93%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">Python requests库中文编码问题</a><br>更多关于<code>Requests</code>模块的介绍可以点击<a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">Requests快速上手</a>查看介绍</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;爬虫介绍&quot;&gt;&lt;a href=&quot;#爬虫介绍&quot; class=&quot;headerlink&quot; title=&quot;爬虫介绍&quot;&gt;&lt;/a&gt;爬虫介绍&lt;/h3&gt;&lt;h4 id=&quot;爬虫定义&quot;&gt;&lt;a href=&quot;#爬虫定义&quot; class=&quot;headerlink&quot; title=&quot;爬虫定义&quot;&gt;&lt;/a&gt;爬虫定义&lt;/h4&gt;&lt;p&gt;爬虫是请求网站并提取自己所需要数据的过程。通过我们的程序，可以代替我们向服务器发送请求，然后进行批量的数据下载。  &lt;/p&gt;
&lt;h4 id=&quot;爬虫基本流程&quot;&gt;&lt;a href=&quot;#爬虫基本流程&quot; class=&quot;headerlink&quot; title=&quot;爬虫基本流程&quot;&gt;&lt;/a&gt;爬虫基本流程&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;发起请求&lt;br&gt;通过url向服务器发送requests请求，请求可以包含额外的header信息。
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="爬虫" scheme="https://rosinelan.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="requests" scheme="https://rosinelan.github.io/tags/requests/"/>
    
  </entry>
  
  <entry>
    <title>python数据处理(二)</title>
    <link href="https://rosinelan.github.io/2018/06/11/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E4%BA%8C/"/>
    <id>https://rosinelan.github.io/2018/06/11/python数据处理-二/</id>
    <published>2018-06-11T15:19:55.000Z</published>
    <updated>2018-06-12T11:15:54.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pdf处理"><a href="#pdf处理" class="headerlink" title="pdf处理"></a>pdf处理</h3><p>pdf是二进制文件，使用<code>PyPDF2</code>模块进行处理，安装方法<code>pip install PyPDF2</code>。  </p><h4 id="提取文本"><a href="#提取文本" class="headerlink" title="提取文本"></a>提取文本</h4><ol><li>导入PyPDF2模块，然后以读二进制模式打开pdf文件，并将其保存到对象pdfFileObj。</li><li>调用pdfFileReader()并传入pdfFileObj，将PdfFileReader对象保存到pdfReader。</li><li>获取pdf文件总页数调用PdfFileReader对象的<code>numPages</code>属性。</li><li>从某页中提取文本，首先通过PdfFileReader对象的<code>getPage()</code>方法得到Page对象，然后调用Page对象的<code>extractText()</code>方法得到文本字符串。<a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PyPDF2</span><br><span class="line"></span><br><span class="line">pdfFileObj = open(<span class="string">"test.pdf"</span>, <span class="string">'rb'</span>)</span><br><span class="line">pdfReader = PyPDF2.PdfFileReader(pdfFileObj)</span><br><span class="line">print(pdfReader.numPages) <span class="comment">#文件总页数</span></span><br><span class="line">pageObj = pdfReader.getPage(<span class="number">0</span>) <span class="comment">#下标从0开始</span></span><br><span class="line">pageObj.extractText()</span><br></pre></td></tr></table></figure></li></ol><h4 id="解密pdf"><a href="#解密pdf" class="headerlink" title="解密pdf"></a>解密pdf</h4><p>当pdf文件加密时，需要传入密码才能正常打开，此时使用<code>decrypt()</code>函数传入密码即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PyPDF2</span><br><span class="line"></span><br><span class="line">pdfFileObj = open(<span class="string">"test.pdf"</span>, <span class="string">'rb'</span>)</span><br><span class="line">pdfReader = PyPDF2.PdfFileReader(pdfFileObj)</span><br><span class="line">print(pdfReader.isEncrypted)    <span class="comment">#是否加密，是返回True，否则返回False</span></span><br><span class="line">pdfReader.decrypt(<span class="string">"123456"</span>)</span><br><span class="line">pageObj = pdfReader.getPage(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><h4 id="创建pdf"><a href="#创建pdf" class="headerlink" title="创建pdf"></a>创建pdf</h4><p>创建pdf使用<code>PdfFileWriter</code>对象。但是该模块不允许直接编辑pdf文件，一般都是从其他pdf拷贝页面。    </p><ol><li>打开一个或多个pdf文件，得到PdfFileReader对象。</li><li>创建一个新的PdfFileWriter对象。</li><li>将页面从PdfFileReader对象拷贝到PdfFileWriter对象。</li><li>利用PdfFileWriter对象写入输出到pdf。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pdf1File = open(<span class="string">"test1.pdf"</span>, <span class="string">"rb"</span>)</span><br><span class="line">pdf2File = open(<span class="string">"test2.pdf"</span>, <span class="string">"rb"</span>)</span><br><span class="line">pdf1Reader = PyPDF2.PdfFileReader(pdf1File)</span><br><span class="line">pdf2Reader = PyPDF2.PdfFileReader(pdf2File)</span><br><span class="line">pdfWriter = PyPDF2.PdfFileWriter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pageNum <span class="keyword">in</span> range(pdf1Reader.numPages):</span><br><span class="line">    pageobj = pdf1Reader.getPage(pageNum)</span><br><span class="line">    pdfWriter.addPage(pageobj)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> pageNum <span class="keyword">in</span> range(pdf2Reader.numPages):</span><br><span class="line">    pageobj = pdf2Reader.getPage(pageNum)</span><br><span class="line">    pdfWriter.addPage(pageobj)</span><br><span class="line"></span><br><span class="line">pdfOutputFile = open(<span class="string">"tst_com.pdf"</span>, <span class="string">"wb"</span>)</span><br><span class="line">pdfWriter.write(pdfOutputFile)</span><br><span class="line">pdfOutputFile.close()</span><br><span class="line">pdf1File.close()</span><br><span class="line">pdf2File.close()</span><br></pre></td></tr></table></figure></li></ol><p>注意：此处<code>addPage()</code>方法只能在末尾添加页面，PyPDF2不支持在中间插入页面。</p><h3 id="pdf转换"><a href="#pdf转换" class="headerlink" title="pdf转换"></a>pdf转换</h3><p>pdf转换使用<code>pdfkit</code>模块，安装方法<code>pip install pdfkit</code>。<br>由于pdfkit模块是wkhtmltopdf工具的封装，所以需要安装该工具，点击<a href="https://wkhtmltopdf.org/downloads.html" target="_blank" rel="noopener">wkhtmltopdf</a>至官方下载地址，根据操作系统版本选择下载安装即可。安装之后将bin执行文件路径添加到PATH变量中。  </p><ul><li><p>网页转换为pdf</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdfkit</span><br><span class="line"></span><br><span class="line">pdfkit.from_url(<span class="string">"12345"</span>, <span class="string">"output1.pdf"</span>)</span><br></pre></td></tr></table></figure></li><li><p>html转换为pdf</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdfkit</span><br><span class="line"></span><br><span class="line">pdfkit.from_file(<span class="string">"12345.html"</span>, <span class="string">"output2.pdf"</span>)</span><br></pre></td></tr></table></figure></li><li><p>字符转换成pdf</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdfkit</span><br><span class="line"></span><br><span class="line">pdfkit.from_string(<span class="string">"12345"</span>, <span class="string">"output3.pdf"</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol><li><p>抓取linux教程然后制作成pdf文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pdfkit</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">'http://www.apelearn.com/study_v2/'</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">"aming"</span>):</span><br><span class="line">    os.mkdir(<span class="string">"aming"</span>)</span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">"aming"</span>)</span><br><span class="line">s = requests.session()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">27</span>):</span><br><span class="line">    url = base_url + <span class="string">'chapter'</span> + str(i) + <span class="string">'.html'</span>  <span class="comment">#拼接网页url</span></span><br><span class="line">    file = str(i) + <span class="string">'.pdf'</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pdfkit.from_url(url, file)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure></li><li><p>将生成的多个pdf文件合并成1个pdf。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> PyPDF2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">files = list()</span><br><span class="line"><span class="keyword">for</span> fileName <span class="keyword">in</span> os.listdir(<span class="string">"aming"</span>):</span><br><span class="line">    <span class="keyword">if</span> fileName.endswith(<span class="string">".pdf"</span>):</span><br><span class="line">        files.append(fileName)</span><br><span class="line"></span><br><span class="line">newFiles = sorted(files, key=<span class="keyword">lambda</span> d: int(d.split(<span class="string">".pdf"</span>)[<span class="number">0</span>])) <span class="comment">#按照章节进行排序，默认为ASCII码排序</span></span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">"aming"</span>)</span><br><span class="line">pdfWriter = PyPDF2.PdfFileWriter() <span class="comment">#生成一个空白的pdf</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> newFiles:</span><br><span class="line">    pdfReader = PyPDF2.PdfFileReader(open(item, <span class="string">"rb"</span>))</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> range(pdfReader.numPages):</span><br><span class="line">        pdfWriter.addPage(pdfReader.getPage(page))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> codecs.open(<span class="string">"aminglinux.pdf"</span>, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pdfWriter.write(f)</span><br></pre></td></tr></table></figure></li></ol><h3 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h3><p>python3中使用<code>pillow</code>模块，安装方法<code>pip install pillow</code>，使用的时候导入方法<code>from PIL import Iamge</code>。  </p><h4 id="image的属性"><a href="#image的属性" class="headerlink" title="image的属性"></a>image的属性</h4><ul><li>format<br>识别图像的源格式，如果该文件不是从文件读取，则置为None。</li><li>size<br>返回一个元组，包含2个元素，值为像素意义上的宽和高。</li><li>mode<br>包括RGB(true color image)/L(luminance)/CMTK(pre-press image)。<h4 id="image的方法"><a href="#image的方法" class="headerlink" title="image的方法"></a>image的方法</h4></li><li>image.show()<br>显示最近加载的图像</li><li>image.open(file)<br>打开文件</li><li>image.save(outputfile)<br>保存文件</li><li>image.crop(left, upper, right, lower)<br>从图像中提取某个矩形大小的图像。它接受一个四元素的元组作为参数，坐标系统的原点(0,0)是左上角。<br>Image的几何处理：</li><li>im.resize((128, 128))<br>调整图片大小</li><li>im.rotate(45)<br>逆时针旋转 45 度角。</li><li>im.transpose(Image.FLIP_LEFT_RIGHT)<br>左右对换。</li><li>im.transpose(Image.FLIP_TOP_BOTTOM)<br>上下对换。</li><li>im.transpose(Image.ROTATE_90)<br>旋转 90 度角。</li><li>im.transpose(Image.ROTATE_180)<br>旋转 180 度角。</li><li>im.transpose(Image.ROTATE_270)<br>旋转 270 度角。<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4></li></ul><ol><li><p>显示图片信息并查看图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.open(<span class="string">"test.jpg"</span>)</span><br><span class="line">print(image.format, image.size, image.mode)</span><br><span class="line">image.show()</span><br></pre></td></tr></table></figure></li><li><p>抠图<br>将图片指定区域进行裁剪并保存在cutting.jpg中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.open(<span class="string">"test..jpg"</span>)</span><br><span class="line">print(image.format, image.size, image.mode)</span><br><span class="line">box = (<span class="number">600</span>, <span class="number">300</span>, <span class="number">1050</span>, <span class="number">660</span>)</span><br><span class="line">region = image.crop(box)</span><br><span class="line">region.save(<span class="string">"cutting.jpg"</span>)</span><br></pre></td></tr></table></figure></li><li><p>图片拼合<br>将指定区域的图片截取出来并旋转180度，然后拼接在一起</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.open(<span class="string">"test..jpg"</span>)</span><br><span class="line">print(image.format, image.size, image.mode)</span><br><span class="line">box = (<span class="number">600</span>, <span class="number">300</span>, <span class="number">1050</span>, <span class="number">660</span>)</span><br><span class="line">egion = image.crop(box)</span><br><span class="line"><span class="comment">#egion.save("cutting.jpg")</span></span><br><span class="line">region = egion.transpose(Image.ROTATE_180)</span><br><span class="line">image.paste(region, box)</span><br><span class="line">image.show()</span><br></pre></td></tr></table></figure></li><li><p>图片缩放</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">infile = <span class="string">"test.jpg"</span></span><br><span class="line">outfile = <span class="string">"newtest.jpg"</span></span><br><span class="line">image = Image.open(infile)</span><br><span class="line">(x, y) = image.size</span><br><span class="line">newx = <span class="number">300</span></span><br><span class="line">newy = int(y*newx/x)</span><br><span class="line">out = image.resize((newx, newy), Image.ANTIALIAS)</span><br><span class="line">out.show()</span><br></pre></td></tr></table></figure></li><li><p>验证码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFont, ImageDraw, ImageFilter</span><br><span class="line"></span><br><span class="line">font_path = <span class="string">"msyh.ttf"</span></span><br><span class="line">number = <span class="number">4</span></span><br><span class="line">size = (<span class="number">100</span>, <span class="number">30</span>)</span><br><span class="line">bgcolor = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line">fontcolor = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">linecolor = (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">draw_line = <span class="keyword">True</span></span><br><span class="line"><span class="comment"># 加入干扰线条数的上下限</span></span><br><span class="line">line_number = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成一个随机字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNumber</span><span class="params">()</span>:</span></span><br><span class="line">    source = list(string.ascii_letters) + list(string.digits)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(random.sample(source, number))</span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制干扰线</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLine</span><span class="params">(draw, width, height)</span>:</span></span><br><span class="line">    begin = random.randint(<span class="number">0</span>, width), random.randint(<span class="number">0</span>, height)</span><br><span class="line">    end  = random.randint(<span class="number">0</span>, width), random.randint(<span class="number">0</span>, height)</span><br><span class="line">    draw.line([begin, end], fill=linecolor)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCode</span><span class="params">()</span>:</span></span><br><span class="line">    width, height = size</span><br><span class="line">    image = Image.new(<span class="string">"RGBA"</span>, size, bgcolor)</span><br><span class="line">    font = ImageFont.truetype(font_path, <span class="number">25</span>)</span><br><span class="line">    draw = ImageDraw.Draw(image)</span><br><span class="line">    text = getNumber()</span><br><span class="line">    font_width, font_height = font.getsize(text)</span><br><span class="line">    draw.text(((width - font_width) / <span class="number">2</span>, (height - font_height) / <span class="number">2</span>), text, font=font, fill=fontcolor)  <span class="comment"># 填充字符串</span></span><br><span class="line">    <span class="keyword">if</span> draw_line:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(line_number):</span><br><span class="line">            getLine(draw, width, height)</span><br><span class="line"></span><br><span class="line">    image = image.filter(ImageFilter.EDGE_ENHANCE_MORE)  <span class="comment"># 滤镜，边界加强</span></span><br><span class="line">    image.save(<span class="string">'idencode.png'</span>)  <span class="comment"># 保存验证码图片</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    getCode()</span><br></pre></td></tr></table></figure></li></ol><p>关于<code>pillow</code>模块的更多介绍，可以点击<a href="http://pillow.readthedocs.io/en/latest/" target="_blank" rel="noopener">Pillow</a>查看官方文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;pdf处理&quot;&gt;&lt;a href=&quot;#pdf处理&quot; class=&quot;headerlink&quot; title=&quot;pdf处理&quot;&gt;&lt;/a&gt;pdf处理&lt;/h3&gt;&lt;p&gt;pdf是二进制文件，使用&lt;code&gt;PyPDF2&lt;/code&gt;模块进行处理，安装方法&lt;code&gt;pip install PyPDF2&lt;/code&gt;。  &lt;/p&gt;
&lt;h4 id=&quot;提取文本&quot;&gt;&lt;a href=&quot;#提取文本&quot; class=&quot;headerlink&quot; title=&quot;提取文本&quot;&gt;&lt;/a&gt;提取文本&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;导入PyPDF2模块，然后以读二进制模式打开pdf文件，并将其保存到对象pdfFileObj。&lt;/li&gt;
&lt;li&gt;调用pdfFileReader()并传入pdfFileObj，将PdfFileReader对象保存到pdfReader。&lt;/li&gt;
&lt;li&gt;获取pdf文件总页数调用PdfFileReader对象的&lt;code&gt;numPages&lt;/code&gt;属性。&lt;/li&gt;
&lt;li&gt;从某页中提取文本，首先通过PdfFileReader对象的&lt;code&gt;getPage()&lt;/code&gt;方法得到Page对象，然后调用Page对象的&lt;code&gt;extractText()&lt;/code&gt;方法得到文本字符串。
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="pdf" scheme="https://rosinelan.github.io/tags/pdf/"/>
    
      <category term="pdfkit" scheme="https://rosinelan.github.io/tags/pdfkit/"/>
    
      <category term="图片" scheme="https://rosinelan.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="image" scheme="https://rosinelan.github.io/tags/image/"/>
    
  </entry>
  
  <entry>
    <title>python数据处理</title>
    <link href="https://rosinelan.github.io/2018/06/08/python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://rosinelan.github.io/2018/06/08/python数据处理/</id>
    <published>2018-06-08T13:42:44.000Z</published>
    <updated>2018-06-12T09:36:16.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="csv数据处理"><a href="#csv数据处理" class="headerlink" title="csv数据处理"></a>csv数据处理</h3><p>csv表示”Comma-Separated Values(逗号分隔的值)”，csv文件时简化的电子表格，保存为纯文本文件。<br>python中解析csv文件可以使用csv模块。<br>注意：csv是文本文件，通过打开文件的操作，将其内容读入一个字符串，然后通过字符串的<code>split()</code>方法处理每行文本取得值。需要注意csv文件中也有自己的转义字符，允许逗号或者其他字符作为值的一部分，<code>split()</code>方法无法处理这部分转义字符。所以处理csv文件时为避免这些潜在的问题，建议使用csv模块处理csv文件。<br><a id="more"></a></p><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p>使用csv模块从csv文件中读取数据，需要创建一个<code>Reader</code>对象，可以通过Reader对象迭代遍历csv文件中的每一行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"example.csv"</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> dataObject:</span><br><span class="line">    dataReader = csv.reader(dataObject)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> dataReader:</span><br><span class="line">        print(<span class="string">"第&#123;0&#125;行:&#123;1&#125;"</span>.format(dataReader.line_num, row))</span><br></pre></td></tr></table></figure></p><p>Reader对象的<code>line_num</code>变量是当前的行号。<br>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">1</span>行:[<span class="string">'2018/06/09'</span>, <span class="string">'Apples'</span>, <span class="string">'73'</span>]</span><br><span class="line">第<span class="number">2</span>行:[<span class="string">'2018/06/10'</span>, <span class="string">'Cherries'</span>, <span class="string">'85'</span>]</span><br><span class="line">第<span class="number">3</span>行:[<span class="string">'2018/06/11'</span>, <span class="string">'Pears'</span>, <span class="string">'14'</span>]</span><br></pre></td></tr></table></figure></p><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p>Write对象可以将数据写入到csv文件中。<br>首先调用<code>open()</code>并传入<code>w</code>，以写模式打开一个文件。这时会创建一个对象。<br>然后将创建的对象传递给<code>csv.writer()</code>，创建一个Writer对象。<br>接下来调用Writer对象的<code>writerow()</code>方法写入文件。该方法接受参数为列表，返回值为写入文件这一行中的字符数(包括换行符)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"test.csv"</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> outputFile:</span><br><span class="line">    dataWriter = csv.writer(outputFile)</span><br><span class="line">    dataWriter.writerow([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">    dataWriter.writerow([<span class="string">'啊'</span>, <span class="string">'吧'</span>, <span class="string">'次'</span>])</span><br><span class="line">    dataWriter.writerow([<span class="string">'A'</span>, <span class="string">'Hello,World!'</span>, <span class="string">'C'</span>])</span><br></pre></td></tr></table></figure></p><p>最后输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a,b,c</span><br><span class="line">啊,吧,次</span><br><span class="line">A,&quot;Hello,World!&quot;,C</span><br></pre></td></tr></table></figure></p><p>此处的<code>Hello,Wrold!</code>中的逗号自动转义，使用双引号处理了。<br>在windows中<code>open()</code>需加上<code>newline=&#39;&#39;</code>参数，否则将出现2倍行距的情况。<br>写入的文件必须已经存在。  </p><ul><li>delimiter 指定分隔符，默认为逗号</li><li>lineterminator 行距，默认为单倍行距<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataWriter = csv.writer(outputFile, delimiter=<span class="string">'\t'</span>, lineterminator=<span class="string">'\n\n'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>上面表示使用制表符作为分隔符，两倍行距(也就是行之间字符变为2个换行符)。  </p><h3 id="excel数据处理"><a href="#excel数据处理" class="headerlink" title="excel数据处理"></a>excel数据处理</h3><p>excel的操作都是通过第三方库来进行。常用的有<code>xlrd</code>、<code>xlwt</code>、<code>xluntils</code>、<code>pyExcelerator</code>、<code>openpyxl</code>。<br>安装类似与其它第三方模块，使用<code>pip install module_name</code>即可。  </p><ul><li>xlrd只能进行读取excel文件，没法进行写入文件。</li><li>xlwt可以写入文件，但是不能在已有的excel的文件上进行修改。  </li><li>xluntils可以对文件进行复制和修改，该模块功能实现依赖于<code>xlrd</code>和<code>xlwt</code>。  </li><li>pyExcelerator模块与xlwt类似，也可以用来生成excel文件，同时支持单元格合并、冻结等操作。  </li><li>openpyxl也支持文件的读取、写入、创建和删除工作表、设置字体格式、单元格合并、冻结等操作。  </li></ul><h4 id="xlrd"><a href="#xlrd" class="headerlink" title="xlrd"></a>xlrd</h4><p><code>xlrd</code>主要用于excel文件读取。<br>excel名称为<code>test.xlsx</code>，内容如下<br><img src="http://cdn.rosinelan.com/blog/program/python_data_xlrd.png" alt="python_data_xlrd" title="python_data_xlrd"></p><ul><li><p>打开excel文件并获取所有的sheet。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line">workbook = xlrd.open_workbook(<span class="string">"test.xlsx"</span>)</span><br><span class="line">worksheets = workbook.sheet_names()</span><br><span class="line">print(worksheets)    <span class="comment">#输出结果：['物理机', '虚拟机']</span></span><br></pre></td></tr></table></figure></li><li><p>根据下标获取sheet名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worksheet1 = workbook.sheet_names()[<span class="number">0</span>]</span><br><span class="line">print(worksheet1)    <span class="comment">#输出结果：物理机</span></span><br><span class="line">worksheet2 = workbook.sheet_names()[<span class="number">1</span>]</span><br><span class="line">print(worksheet2)    <span class="comment">#输出结果：虚拟机</span></span><br></pre></td></tr></table></figure></li><li><p>根据sheet索引或名称获取sheet内容，同时获取sheet名称、行数、列数  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sheet1 = workbook.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">print(sheet1.name, sheet1.nrows, sheet1.ncols)    <span class="comment">#输出结果：物理机 16 6</span></span><br><span class="line">sheet2 = workbook.sheet_by_name(<span class="string">"虚拟机"</span>)</span><br><span class="line">print(sheet2.name, sheet2.nrows, sheet2.ncols)    <span class="comment">#输出结果：虚拟机 13 6</span></span><br></pre></td></tr></table></figure></li></ul><p>索引从<code>0</code>开始；<code>nrows</code>表示所有行；<code>ncols</code>表示所有列。</p><ul><li><p>根据sheet名称获取整行和整列的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sheet1 = workbook.sheet_by_name(<span class="string">"物理机"</span>)</span><br><span class="line">rows = sheet1.row_values(<span class="number">0</span>)    <span class="comment">#第一行内容</span></span><br><span class="line">print(rows)    <span class="comment">#输出结果：['IP地址', '设备用途', '型号', '主要配置', '操作系统', '区域']</span></span><br><span class="line">cols = sheet1.col_values(<span class="number">0</span>)    <span class="comment">#第一列的内容</span></span><br><span class="line">print(cols)    <span class="comment">#输出结果：['IP地址', '192.168.0.1', '192.168.0.2',... '192.168.0.15']</span></span><br></pre></td></tr></table></figure></li><li><p>获取指定单元格的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sheet1 = workbook.sheet_by_name(<span class="string">"物理机"</span>)</span><br><span class="line">print(sheet1.cell(<span class="number">1</span>, <span class="number">2</span>).value)     <span class="comment">#输出结果：Lenovo R680g7</span></span><br><span class="line">print(sheet1.cell_value(<span class="number">1</span>, <span class="number">2</span>))    <span class="comment">#输出结果：Lenovo R680g7</span></span><br><span class="line">print(sheet1.row(<span class="number">1</span>)[<span class="number">2</span>].value)    <span class="comment">#输出结果：Lenovo R680g7</span></span><br></pre></td></tr></table></figure></li><li><p>获取单元格内容的数据类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sheet1 = workbook.sheet_by_name(<span class="string">"物理机"</span>)</span><br><span class="line">print(sheet1.cell(<span class="number">1</span>, <span class="number">2</span>).ctype)    <span class="comment">#输出结果：1</span></span><br><span class="line">print(sheet1.cell(<span class="number">1</span>, <span class="number">6</span>).ctype)    <span class="comment">#输出结果：3</span></span><br></pre></td></tr></table></figure></li></ul><p><code>ctype</code>共有5种，<code>0 empty</code>,<code>1 string</code>, <code>2 number</code>, <code>3 date</code>, <code>4 boolean</code>, <code>5 error</code>。</p><ul><li>日期类型的特殊处理<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sheet1 = workbook.sheet_by_name(<span class="string">"物理机"</span>)</span><br><span class="line">print(sheet1.cell(<span class="number">1</span>, <span class="number">6</span>).value)    <span class="comment">#输出结果：43252.0</span></span><br></pre></td></tr></table></figure></li></ul><p>日期类型输出结果为number，可以使用<code>xldate_as_tuple</code>或<code>xldate_as_datetime</code>进行处理。</p><ul><li><p><code>xldate_as_tuple</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"></span><br><span class="line">sheet1 = workbook.sheet_by_name(<span class="string">"物理机"</span>)</span><br><span class="line">date_value = xlrd.xldate_as_tuple(sheet1.cell(<span class="number">1</span>, <span class="number">6</span>).value, workbook.datemode)</span><br><span class="line">print(date_value)    <span class="comment">#输出结果：(2018, 6, 1, 0, 0, 0)</span></span><br><span class="line">print(date_value[:<span class="number">3</span>])    <span class="comment">#输出结果：(2018, 6, 1)</span></span><br><span class="line">print(*date_value[:<span class="number">3</span>])    <span class="comment">#输出结果：2018 6 1</span></span><br><span class="line">print(date(*date_value[:<span class="number">3</span>]))    <span class="comment">#输出结果：2018-06-01</span></span><br></pre></td></tr></table></figure></li><li><p><code>xldate_as_datetime</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sheet1 = workbook.sheet_by_name(<span class="string">"物理机"</span>)</span><br><span class="line">date_time = xlrd.xldate_as_datetime(sheet1.cell(<span class="number">1</span>, <span class="number">6</span>).value, workbook.datemode)</span><br><span class="line">print(date_time.strftime(<span class="string">'%Y-%m-%d'</span>))    <span class="comment">#输出结果：2018-06-01</span></span><br></pre></td></tr></table></figure></li></ul><p>在脚本中需要获取并显示单元格中的日期类型时，可以先判断数据类型是否为日期类型，如果是则进行处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sheet1.cell(<span class="number">1</span>, <span class="number">6</span>).ctype == <span class="number">3</span>):</span><br><span class="line">    date_time = xlrd.xldate_as_datetime(sheet1.cell(<span class="number">1</span>, <span class="number">6</span>).value, workbook.datemode)</span><br><span class="line">    print(date_time.strftime(<span class="string">'%Y-%m-%d'</span>))</span><br></pre></td></tr></table></figure></p><p>关于<code>xlrd</code>模块更多介绍，可以点击<a href="http://xlrd.readthedocs.io/en/latest/" target="_blank" rel="noopener">xlrd documentation</a>查看官方文档介绍。  </p><h4 id="xlwt"><a href="#xlwt" class="headerlink" title="xlwt"></a>xlwt</h4><ul><li><p>创建workbook和sheet对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line">workbook = xlwt.Workbook()</span><br><span class="line">sheet1 = workbook.add_sheet(<span class="string">"sheet1"</span>, cell_overwrite_ok=<span class="keyword">True</span>)</span><br><span class="line">sheet2 = workbook.add_sheet(<span class="string">"sheet2"</span>, cell_overwrite_ok=<span class="keyword">True</span>)</span><br><span class="line">sheet3 = workbook.add_sheet(<span class="string">"表3"</span>, cell_overwrite_ok=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></li><li><p>sheet页中写入数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sheet1.write(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"姓名"</span>)</span><br><span class="line">sheet2.write(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"HOW"</span>)</span><br></pre></td></tr></table></figure></li><li><p>write方法参数列表<br><code>write(r, c, label=&quot;&quot;, style=Style.default_style)</code><br><code>r</code>表示行，<code>c</code>表示列，<code>label</code>表示写入的内容，<code>style</code>表示单元格格式。  </p></li><li><p>使用样式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">style = xlwt.XFStyle()</span><br><span class="line">font = style.font</span><br><span class="line">font.name = <span class="string">"Times New Roman"</span></span><br><span class="line">font.bold = <span class="keyword">True</span></span><br><span class="line">sheet3.write(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"WHAT"</span>, style)</span><br></pre></td></tr></table></figure></li><li><p>保存文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workbook.save(<span class="string">"test1.xls"</span>)    <span class="comment">#此处保存为xls格式，xlsx格式无法打开</span></span><br></pre></td></tr></table></figure></li></ul><p>关于<code>xlwt</code>模块更多介绍，可以点击<a href="http://xlwt.readthedocs.io/en/latest/" target="_blank" rel="noopener">xlwt documentation</a>查看官方文档介绍。 </p><h4 id="openpyxl"><a href="#openpyxl" class="headerlink" title="openpyxl"></a>openpyxl</h4><p>继续以上面的excel为例进行示例操作。  </p><h5 id="worksheet操作"><a href="#worksheet操作" class="headerlink" title="worksheet操作"></a>worksheet操作</h5><ul><li>加载工作表并打印当前所有sheet<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook, load_workbook</span><br><span class="line"></span><br><span class="line">wb1 = load_workbook(<span class="string">'test.xlsx'</span>)</span><br><span class="line">print(wb1.sheetnames) <span class="comment">#输出结果：['物理机', '虚拟机']</span></span><br><span class="line">print(wb1.active)    <span class="comment">#输出结果：&lt;Worksheet "物理机"&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><code>active</code>调用的是<code>_active_sheet_index</code>属性，默认情况为0.所以得到的都是第一个worksheet。</p><ul><li>创建sheet页<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ws1 = wb1.create_sheet(<span class="string">"sheet1"</span>)</span><br><span class="line">ws2 = wb1.create_sheet(<span class="string">"sheet2"</span>, <span class="number">0</span>)</span><br><span class="line">print(wb1.sheetnames) <span class="comment">#输出结果：['sheet2', '物理机', '虚拟机', 'sheet1']</span></span><br><span class="line">print(wb1.active) <span class="comment">#输出结果：&lt;Worksheet "sheet2"&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><code>create_sheet()</code>默认情况下插入在最后，当传入index参数时，插入至指定位置，例如0表示插入至最前面。  </p><ul><li>sheet页属性修改<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws1.title = <span class="string">"new sheet"</span> <span class="comment">#修改标题</span></span><br><span class="line">ws1.sheet_properties.tabColor = <span class="string">"1072BA"</span> <span class="comment">#修改工作表标签颜色</span></span><br><span class="line">print(wb1.sheetnames) <span class="comment">#输出结果：['sheet2', '物理机', '虚拟机', 'new sheet']</span></span><br></pre></td></tr></table></figure></li></ul><p>也可以通过循环的方式得到所有sheet页名称<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> sheet <span class="keyword">in</span> wb1:</span><br><span class="line">    print(sheet.title, end=<span class="string">' '</span>) <span class="comment">#输出结果：sheet2 物理机 虚拟机 new sheet</span></span><br></pre></td></tr></table></figure></p><ul><li>sheet页复制<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source = wb1.active</span><br><span class="line">target = wb1.copy_worksheet(source)</span><br><span class="line">print(wb1.sheetnames) <span class="comment">#输出结果：['sheet2', '物理机', '虚拟机', 'new sheet', 'sheet2 Copy']</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="cell操作"><a href="#cell操作" class="headerlink" title="cell操作"></a>cell操作</h5><ul><li>获取及修改指定cell内容<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ws4 = wb1[<span class="string">"物理机"</span>]</span><br><span class="line">print(ws4[<span class="string">"A4"</span>].value) <span class="comment">#输出结果：192.168.0.3</span></span><br><span class="line">print(ws4[<span class="string">"G4"</span>].value) <span class="comment">#输出结果：2018-06-03 00:00:00</span></span><br><span class="line">ws4[<span class="string">'A4'</span>] = <span class="number">4</span> <span class="comment">#可直接修改指定单元格内容</span></span><br><span class="line">print(ws4[<span class="string">"A4"</span>].value) <span class="comment">#输出结果：4</span></span><br></pre></td></tr></table></figure></li></ul><p>对于日期格式可直接正确输出。<br>修改指定单元格的内容也可以使用<code>cell()</code>方法传入行、列和值的方式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = ws4.cell(column=<span class="number">1</span>, row=<span class="number">4</span>, value=<span class="number">10</span>)</span><br><span class="line">print(ws4[<span class="string">"A4"</span>].value) <span class="comment">#输出结果：10</span></span><br></pre></td></tr></table></figure></p><p>当一个sheet页被创建时无单元格。单元格在首次被访问的时候创建，无论是否有值。<br>对于下面的操作,将会在内存中创建100*100的单元格，即使未分配值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line"><span class="meta">... </span>           ws.cell(row=i, column=j)</span><br></pre></td></tr></table></figure></p><ul><li>访问多个单元格或行或列<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cell_range = ws4[<span class="string">'A1'</span>:<span class="string">'B2'</span>] <span class="comment">#多个单元格</span></span><br><span class="line">print(cell_range)</span><br></pre></td></tr></table></figure></li></ul><p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((&lt;Cell <span class="string">'物理机'</span>.A1&gt;, &lt;Cell <span class="string">'物理机'</span>.B1&gt;), (&lt;Cell <span class="string">'物理机'</span>.A2&gt;, &lt;Cell <span class="string">'物理机'</span>.B2&gt;))</span><br></pre></td></tr></table></figure></p><p>输出结果为包含<code>2个元组的元组</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colC = ws4[<span class="string">'C'</span>] <span class="comment">#指定单行</span></span><br><span class="line">print(colC)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;Cell <span class="string">'物理机'</span>.C1&gt;... &lt;Cell <span class="string">'物理机'</span>.C15&gt;, &lt;Cell <span class="string">'物理机'</span>.C16&gt;)</span><br></pre></td></tr></table></figure></p><p>输出结果为<code>元组</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">col_range = ws4[<span class="string">'C:D'</span>] <span class="comment">#指定多行</span></span><br><span class="line">print(col_range)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((&lt;Cell <span class="string">'物理机'</span>.C1&gt;, ... &lt;Cell <span class="string">'物理机'</span>.C16&gt;), (&lt;Cell <span class="string">'物理机'</span>.D1&gt;,... &lt;Cell <span class="string">'物理机'</span>.D16&gt;))</span><br></pre></td></tr></table></figure></p><p>输出结果为包含<code>2个元组的元组</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">row10 = ws4[<span class="number">10</span>] <span class="comment">#指定单列</span></span><br><span class="line">print(row10)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;Cell <span class="string">'物理机'</span>.A10&gt;, &lt;Cell <span class="string">'物理机'</span>.B10&gt;,...&lt;Cell <span class="string">'物理机'</span>.L10&gt;)</span><br></pre></td></tr></table></figure></p><p>输出结果为<code>元组</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">row_range = ws4[<span class="number">5</span>:<span class="number">6</span>] <span class="comment">#指定多列</span></span><br><span class="line">print(row_range)</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((&lt;Cell <span class="string">'物理机'</span>.A5&gt;, &lt;Cell <span class="string">'物理机'</span>.B5&gt;,... &lt;Cell <span class="string">'物理机'</span>.L5&gt;), (&lt;Cell <span class="string">'物理机'</span>.A6&gt;, &lt;Cell <span class="string">'物理机'</span>.B6&gt;,... &lt;Cell <span class="string">'物理机'</span>.L6&gt;))</span><br></pre></td></tr></table></figure></p><p>输出结果为包含<code>2个元组的元组</code><br>也可以通过<code>iter_rows()</code>、<code>iter_cols()</code>、<code>rows()</code>、<code>columns()</code>方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iter_rows()</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws4.iter_rows(min_row=<span class="number">1</span>, max_col=<span class="number">3</span>, max_row=<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">        print(cell)</span><br><span class="line"><span class="comment"># iter_cols()</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> ws4.iter_cols(min_row=<span class="number">1</span>, max_col=<span class="number">3</span>, max_row=<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> col:</span><br><span class="line">        print(cell)</span><br><span class="line"><span class="comment"># rows()</span></span><br><span class="line">print(tuple(ws4.rows))</span><br><span class="line"><span class="comment"># columns()</span></span><br><span class="line">print(tuple(ws4.columns))</span><br></pre></td></tr></table></figure></p><ul><li>数据存储</li></ul><p>直接赋值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line">wb1 = load_workbook(<span class="string">'test.xlsx'</span>)</span><br><span class="line">ws = wb1[<span class="string">"sheet2"</span>]</span><br><span class="line">c = ws[<span class="string">"A1"</span>]</span><br><span class="line">c.value = <span class="string">"hello, world"</span></span><br><span class="line">print(c.value) <span class="comment">#输出结果：hello, world</span></span><br><span class="line">d = ws[<span class="string">"B1"</span>]</span><br><span class="line">d.value = <span class="number">3.14</span></span><br><span class="line">print(d.value) <span class="comment">#输出结果：3.14</span></span><br></pre></td></tr></table></figure></p><p>启用格式和类型推断<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wb = load_workbook(<span class="string">'test.xlsx'</span>, guess_types=<span class="keyword">True</span>)</span><br><span class="line">ws = wb.create_sheet(<span class="string">"sheet2"</span>)</span><br><span class="line">c = ws[<span class="string">"B1"</span>]</span><br><span class="line">c.value = <span class="string">'12%'</span></span><br><span class="line">print(c.value)    <span class="comment">#输出结果：0.12</span></span><br><span class="line">d = ws[<span class="string">"B2"</span>]</span><br><span class="line">d.value = datetime.now()</span><br><span class="line">print(d.value)    <span class="comment">#输出结果：2018-06-12 17:19:10.700439</span></span><br></pre></td></tr></table></figure></p><ul><li>文件保存<br>直接调用<code>save()</code>方法即可。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.save(<span class="string">"test.xlsx"</span>)</span><br></pre></td></tr></table></figure></li></ul><p>注意</p><ol><li>当文件存在时会直接覆盖，不会给出提示或警告信息。  </li><li>当在操作系统中打开excel文件时调用保存方法，会出现<code>PermissionError</code>的错误，关闭即可。  </li><li><code>save()</code>提供另一个文件名，相当于另存为操作，不会影响原文件的内容。  <h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5>使用<code>openpyxl</code>进行excel的操作，主要是<code>Workbook</code>(excel文件)、<code>sheet</code>(excel中的sheet页)、<code>cell</code>(一个单元格)进行操作。<br>读写操作主要步骤：打开Workbook，定位sheet，操作cell。<br>关于<code>openpyxl</code>模块的更多介绍，可以点击<a href="https://openpyxl.readthedocs.io/en/stable/" target="_blank" rel="noopener">openpyxl - A Python library to read/write Excel 2010 xlsx/xlsm files</a>查看官方文档。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;csv数据处理&quot;&gt;&lt;a href=&quot;#csv数据处理&quot; class=&quot;headerlink&quot; title=&quot;csv数据处理&quot;&gt;&lt;/a&gt;csv数据处理&lt;/h3&gt;&lt;p&gt;csv表示”Comma-Separated Values(逗号分隔的值)”，csv文件时简化的电子表格，保存为纯文本文件。&lt;br&gt;python中解析csv文件可以使用csv模块。&lt;br&gt;注意：csv是文本文件，通过打开文件的操作，将其内容读入一个字符串，然后通过字符串的&lt;code&gt;split()&lt;/code&gt;方法处理每行文本取得值。需要注意csv文件中也有自己的转义字符，允许逗号或者其他字符作为值的一部分，&lt;code&gt;split()&lt;/code&gt;方法无法处理这部分转义字符。所以处理csv文件时为避免这些潜在的问题，建议使用csv模块处理csv文件。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="excel" scheme="https://rosinelan.github.io/tags/excel/"/>
    
      <category term="csv" scheme="https://rosinelan.github.io/tags/csv/"/>
    
  </entry>
  
  <entry>
    <title>python邮件发送</title>
    <link href="https://rosinelan.github.io/2018/06/06/python%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
    <id>https://rosinelan.github.io/2018/06/06/python邮件发送/</id>
    <published>2018-06-06T01:12:47.000Z</published>
    <updated>2018-06-08T13:42:24.735Z</updated>
    
    <content type="html"><![CDATA[<p>python中邮件发送可以使用<code>smtplib</code>模块，也可以使用第三方的<code>yagmail</code>模块。</p><h3 id="邮件收发简介"><a href="#邮件收发简介" class="headerlink" title="邮件收发简介"></a>邮件收发简介</h3><p>假如从<code>xx@126.com</code>发送一份邮件至<code>xx@sina.com</code>。首先使用<code>Foxmail</code>等软件写好邮件发送，这些软件称为<strong>MUA</strong>(Mail User Agent，邮件用户代理)。<br>邮件从MUA发出去之后，先发到<strong>MTA</strong>(Mail Transfer Agent，邮件传输代理)，也就是邮件服务提供商。我们的邮件是从<code>126.com</code>发送的，所以先被投递到网易提供的MTA，再由网易的MTA发到对方服务商，也就是新浪的MTA。<br>邮件到达新浪的MTA后，由于对方使用的是新浪的邮箱，因此新浪的MTA会将邮件投递至最终的目的地<strong>MDA</strong>(Mail Delivery Agent，邮件投递代理)。<br>邮件到达MDA之后就会存放在某个服务器，我们将这个长期保存邮件的地方称为电子邮箱。<br>编写程序发送邮件本质就是编写MUA把邮件发送到MTA；收取邮件就是编写MUA从MDA收邮件。<br><a id="more"></a><br>发邮件时，MUA和MTA使用额协议就是<code>SMTP</code>(Simple Mail Transfer Protocol),后面的MTA到另一个MTA也是使用SMTP协议。<br>收邮件时，MUA和MDA使用的协议有两种，<code>POP</code>(Post Office Protocol)，目前版本是3，称为<code>POP3</code>。<code>IMAP</code>(Internet Message Access Protocol)目前版本是4，优点是不但能收取邮件，还可以直接操作MDA上存储的邮件，比如从收件箱移动到垃圾箱等。<br>另外使用python发送邮件时需要注意：</p><ol><li>大多数邮件服务商需要手动打开SMTP发信和POP收信功能。否则只能网页登录。    </li><li>邮件客户端大多数要求使用客户端授权密码，而不是邮箱密码。需要网页登录设置。</li></ol><h3 id="smtplib"><a href="#smtplib" class="headerlink" title="smtplib"></a>smtplib</h3><p>python对SMTP支持的有<code>smtplib</code>和<code>email</code>2个模块，其中<code>email</code>负责构造邮件，<code>smtplib</code>负责发送邮件。  </p><h4 id="email构造邮件"><a href="#email构造邮件" class="headerlink" title="email构造邮件"></a>email构造邮件</h4><p>邮件构造主要使用<code>email.mime</code>。</p><ul><li>纯文本邮件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email <span class="keyword">import</span> encoders</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr, formataddr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_format_addr</span><span class="params">(s)</span>:</span></span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr((Header(name, <span class="string">'utf-8'</span>).encode(), addr))</span><br><span class="line"></span><br><span class="line">msg_from=<span class="string">'XXXXX@163.com'</span>                                 </span><br><span class="line">passwd=<span class="string">'XXXXX'</span>                                  </span><br><span class="line">msg_to=<span class="string">'XXXXX@qq.com'</span></span><br><span class="line">receivers = [<span class="string">'XXXXX@qq.com'</span>]                                                            </span><br><span class="line">subject=<span class="string">"python邮件测试"</span>                                       </span><br><span class="line">content=<span class="string">"hello, send by Python..."</span></span><br><span class="line"></span><br><span class="line">msg = MIMEText(content,<span class="string">'plain'</span>,<span class="string">'utf-8'</span>)</span><br><span class="line">msg[<span class="string">'Subject'</span>] = Header(subject,<span class="string">'utf-8'</span>).encode()</span><br><span class="line">msg[<span class="string">'From'</span>] = _format_addr(<span class="string">'xiaohh &lt;%s&gt;'</span> %msg_from)  <span class="comment">#此处xiaohh表示发件人的昵称</span></span><br><span class="line">msg[<span class="string">'To'</span>] = msg_to</span><br><span class="line"></span><br><span class="line">msg = MIMEText(content, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure></li></ul><p><code>_format_addr()</code>用于格式化邮件地址。如果包含中文，需要通过<code>Header</code>对象进行编码<br>构造<code>MIMEText</code>对象时，第一个参数是邮件正文，第二个参数是MIME的subtype，传入<code>plain</code>表示文本，最终的MIME就是<code>text/plain</code>，最后使用<code>utf-8</code>编码。<br><code>msg[&#39;T0&#39;]</code>接受的是字符串而不是列表，若有多个地址可使用<code>,</code>分隔。</p><ul><li><p>HTML邮件<br>在构造<code>MIMEText</code>对象时，把html字符串传进去，再把第二个参数由<code>plain</code>变为<code>html</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">content = ''&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;' +</span><br><span class="line">    <span class="string">'&lt;p&gt;send by &lt;a href="http://www.python.org"&gt;Python&lt;/a&gt;...&lt;/p&gt;'</span> +</span><br><span class="line">    <span class="string">'&lt;/body&gt;&lt;/html&gt;'</span><span class="string">'</span></span><br><span class="line"><span class="string">msg = MIMEText(content, '</span>plain<span class="string">', '</span>utf<span class="number">-8</span><span class="string">')</span></span><br></pre></td></tr></table></figure></li><li><p>发送附件<br>带附件的邮件可以看做包含若干部分的邮件：文本和各个附件本身，可以构造一个<code>MIMEMultipart</code>对象代表邮件本身，然后往里面添加<code>MIMEText</code>作为邮件正文，再继续往里面加上表示附件的<code>MIMEBase</code>对象即可。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg.attach(MIMEText(<span class="string">'send with file...'</span>, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)) <span class="comment">#邮件正文</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/Users/michael/Downloads/test.png'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    mime = MIMEBase(<span class="string">'image'</span>, <span class="string">'png'</span>, filename=<span class="string">'test.png'</span>) <span class="comment"># 设置附件的MIME和文件名，这里是png类型</span></span><br><span class="line">    mime.add_header(<span class="string">'Content-Disposition'</span>, <span class="string">'attachment'</span>, filename=<span class="string">'test.png'</span>) <span class="comment"># 加上必要的头信息</span></span><br><span class="line">    mime.add_header(<span class="string">'Content-ID'</span>, <span class="string">'&lt;0&gt;'</span>)</span><br><span class="line">    mime.add_header(<span class="string">'X-Attachment-Id'</span>, <span class="string">'0'</span>)</span><br><span class="line">    mime.set_payload(f.read()) <span class="comment"># 把附件的内容读进来</span></span><br><span class="line">    encoders.encode_base64(mime) <span class="comment"># 用Base64编码</span></span><br><span class="line">    msg.attach(mime) <span class="comment"># 添加到MIMEMultipart</span></span><br></pre></td></tr></table></figure></li><li><p>发送图片<br>要想把图片嵌入到邮件正文中，直接在HTML邮件中链接图片地址是不可行的，因为邮件服务商无法确定链接是否指向恶意网站。<br>要把图片嵌入到正文中，需要按照发送附件的方式，先把图片作为附件添加进去，然后在HTML中通过引用<code>src=&quot;cid:0&quot;</code>就可以把附件作为图片嵌入。如果有多个图片，给它们依次编号，然后引用不同的<code>cid:x</code>即可。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg.attach(MIMEText(<span class="string">'&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;'</span> +</span><br><span class="line">    <span class="string">'&lt;p&gt;&lt;img src="cid:0"&gt;&lt;/p&gt;'</span> +</span><br><span class="line">    <span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>, <span class="string">'html'</span>, <span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure></li></ul><p>关于<code>email.mime</code>更多的说明可以点击<a href="https://docs.python.org/3/library/email.mime.html" target="_blank" rel="noopener">email.mime: Creating email and MIME objects from scratch</a>查看官方介绍。<br>关于<code>email</code>邮件构造和解析更多的说明可以点击<a href="https://docs.python.org/3/library/email.html" target="_blank" rel="noopener">email — An email and MIME handling package</a>查看官方介绍。</p><h4 id="smtplib发送邮件"><a href="#smtplib发送邮件" class="headerlink" title="smtplib发送邮件"></a>smtplib发送邮件</h4><p><code>smtplib</code>发送邮件，实例化<code>SMTP()</code>，指定smtp_server地址和端口号；<br>调用<code>logine()</code>方法登录SMTP服务器；<br>调用<code>sendmail()</code>方法发邮件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">25</span>) <span class="comment"># SMTP协议默认端口是25</span></span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure></p><p>由于邮件正文是<code>str</code>，所以<code>msg.as_string()</code>是将<code>MIMEText</code>对象变成<code>str</code>。  </p><ul><li>加密SMTP<br>使用25端口连接SMTP服务器时使用的是明文传输，要更安全的发送邮件，可以加密SMTP会话。  </li></ul><p><code>starttls()</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server = smtplib.SMTP(<span class="string">'smtp.gmail.com'</span>, <span class="number">587</span>) <span class="comment"># gmail加密传输端口是587</span></span><br><span class="line">server.starttls() <span class="comment">#创建安全连接</span></span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure></p><p>调用<code>starttls()</code>方式创建安全连接，其余代码和前面相同。<br><code>smtp_ssl()</code><br>在连接建立的时候就需要SSL并且不适合使用<code>starttls()</code>的情况下可以选择使用<code>smtp_ssl()</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server = smtplib.SMTP_SSL(smtp_server, <span class="number">465</span>) <span class="comment">#使用smtp_ssl()方法</span></span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure></p><p>备注：<code>starttls()</code>使用TLS，默认端口587；<code>smtp_ssl()</code>使用SSL，默认端口为465。此处需要根据邮件服务商提供的加密方式选择。<br>关于<code>smtplib</code>更多的说明可以点击<a href="https://docs.python.org/3/library/smtplib.html" target="_blank" rel="noopener">smtplib — SMTP protocol client</a>查看官方介绍。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email <span class="keyword">import</span> encoders</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr, formataddr</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_format_addr</span><span class="params">(s)</span>:</span></span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr((Header(name, <span class="string">'utf-8'</span>).encode(), addr))</span><br><span class="line"></span><br><span class="line">msg_from=<span class="string">'XXXXX@163.com'</span>                                 </span><br><span class="line">passwd=<span class="string">'XXXXX'</span>                                  </span><br><span class="line">msg_to=<span class="string">'XXXXX@qq.com'</span></span><br><span class="line">receivers = [<span class="string">'XXXXX@qq.com'</span>]                                                            </span><br><span class="line">subject=<span class="string">"python邮件测试"</span>                                       </span><br><span class="line">content=<span class="string">"hello, send by Python..."</span></span><br><span class="line"></span><br><span class="line">msg = MIMEText(content,<span class="string">'plain'</span>,<span class="string">'utf-8'</span>)</span><br><span class="line">msg[<span class="string">'Subject'</span>] = Header(subject,<span class="string">'utf-8'</span>).encode()</span><br><span class="line">msg[<span class="string">'From'</span>] = _format_addr(<span class="string">'xiaohh &lt;%s&gt;'</span> %msg_from)  <span class="comment">#此处xiaohh表示发件人的昵称</span></span><br><span class="line">msg[<span class="string">'To'</span>] = msg_to</span><br><span class="line"></span><br><span class="line">msg = MIMEText(content, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">25</span>)</span><br><span class="line">server.set_debuglevel(<span class="number">1</span>)</span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure><h3 id="yagmail"><a href="#yagmail" class="headerlink" title="yagmail"></a>yagmail</h3><p><code>yagmail</code>是一个第三方模块，点击<a href="https://github.com/kootenpv/yagmail" target="_blank" rel="noopener">yagmail</a>可以在github查看该项目使用说明及源码。<br>使用<code>yagmail</code>发送邮件简单方便，免去了构建邮件内容的繁琐步骤。  </p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>python2和python3的安装如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install yagmail</span><br><span class="line">pip3 install yagmail</span><br></pre></td></tr></table></figure></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>实例化<code>SMTP()</code>类，然后调用send()方法即可。<br>更多使用可以参考github项目主页说明。  </p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yagmail</span><br><span class="line"></span><br><span class="line">args = &#123;</span><br><span class="line">    <span class="string">"user"</span>: <span class="string">"xxxx@163.com"</span>,</span><br><span class="line">    <span class="string">"password"</span>: <span class="string">"xxxx"</span>,</span><br><span class="line">    <span class="string">"host"</span>: <span class="string">"smtp.163.com"</span>,</span><br><span class="line">    <span class="string">"port"</span>: <span class="string">"465"</span></span><br><span class="line">&#125;</span><br><span class="line">emailList = [<span class="string">'xxx@qq.com'</span>]</span><br><span class="line">yag = yagmail.SMTP(**args)</span><br><span class="line">yag.send(to=emailList, subject=<span class="string">"python邮件"</span>, contents=<span class="string">"Thanks for your python email!"</span>, attachments=<span class="string">"__init__.py"</span>)</span><br></pre></td></tr></table></figure><p><code>to</code>：收件人，多个收件人可以通过列表方式传递。<br><code>subject</code>：邮件主题。<br><code>contents</code>：邮件正文。<br><code>attachments</code>：附件，可以使用绝对路径。此处表示该文件夹和代码在同一目录。<br>另外，此处的<code>contents</code>可以传递列表，它可以自动识别文件格式。例如：<br>上面发送修改为如下格式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yag.send(to=emailList, subject=<span class="string">"python邮件"</span>, contents=[<span class="string">"Thanks for your python email!"</span>,<span class="string">"__init__.py"</span>])</span><br></pre></td></tr></table></figure></p><p>最后收到邮件效果和上面的代码一致。可自动将<code>__init__.py</code>识别为附件并添加。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python中邮件发送可以使用&lt;code&gt;smtplib&lt;/code&gt;模块，也可以使用第三方的&lt;code&gt;yagmail&lt;/code&gt;模块。&lt;/p&gt;
&lt;h3 id=&quot;邮件收发简介&quot;&gt;&lt;a href=&quot;#邮件收发简介&quot; class=&quot;headerlink&quot; title=&quot;邮件收发简介&quot;&gt;&lt;/a&gt;邮件收发简介&lt;/h3&gt;&lt;p&gt;假如从&lt;code&gt;xx@126.com&lt;/code&gt;发送一份邮件至&lt;code&gt;xx@sina.com&lt;/code&gt;。首先使用&lt;code&gt;Foxmail&lt;/code&gt;等软件写好邮件发送，这些软件称为&lt;strong&gt;MUA&lt;/strong&gt;(Mail User Agent，邮件用户代理)。&lt;br&gt;邮件从MUA发出去之后，先发到&lt;strong&gt;MTA&lt;/strong&gt;(Mail Transfer Agent，邮件传输代理)，也就是邮件服务提供商。我们的邮件是从&lt;code&gt;126.com&lt;/code&gt;发送的，所以先被投递到网易提供的MTA，再由网易的MTA发到对方服务商，也就是新浪的MTA。&lt;br&gt;邮件到达新浪的MTA后，由于对方使用的是新浪的邮箱，因此新浪的MTA会将邮件投递至最终的目的地&lt;strong&gt;MDA&lt;/strong&gt;(Mail Delivery Agent，邮件投递代理)。&lt;br&gt;邮件到达MDA之后就会存放在某个服务器，我们将这个长期保存邮件的地方称为电子邮箱。&lt;br&gt;编写程序发送邮件本质就是编写MUA把邮件发送到MTA；收取邮件就是编写MUA从MDA收邮件。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="email" scheme="https://rosinelan.github.io/tags/email/"/>
    
      <category term="yagmail" scheme="https://rosinelan.github.io/tags/yagmail/"/>
    
      <category term="mime" scheme="https://rosinelan.github.io/tags/mime/"/>
    
      <category term="smtp" scheme="https://rosinelan.github.io/tags/smtp/"/>
    
  </entry>
  
  <entry>
    <title>python网络编程之socketserver</title>
    <link href="https://rosinelan.github.io/2018/06/05/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocketserver/"/>
    <id>https://rosinelan.github.io/2018/06/05/python网络编程之socketserver/</id>
    <published>2018-06-05T01:23:34.000Z</published>
    <updated>2018-06-06T02:20:30.506Z</updated>
    
    <content type="html"><![CDATA[<p>关于socket的基础介绍可以点击<a href="https://rosinelan.coding.me/2018/06/01/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocket/" target="_blank" rel="noopener">python网络编程之socket</a>查看。  </p><h3 id="socketserver"><a href="#socketserver" class="headerlink" title="socketserver"></a>socketserver</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>socket并不能多并发，只能支持一个用户。socketserver则实现了并发处理。当有多个客户端连接时，socketserver都会在服务器上创建一个线程或进程来处理该客户端的请求，一个客户端对应一个服务端的进程或线程，这样增加系统的利用率。<br>socketserver是socket的封装，简化了编写网络服务程序的任务。python2中为<code>SocketServer</code>，python3中取消了首字母大写，改为<code>socketserver</code>。<br><a id="more"></a><br>socketserver中包含了两种类，一种为服务类(server class)，一种为请求处理类(request handle class)。前者提供了许多方法，像绑定、监听、运行(建立连接的过程)，后者则专注于如何处理用户所发送的数据(事务逻辑)。一般情况下，所有的服务都是先建立连接(也就是建立服务类的实例)，然后开始处理用户请求(也就是建立请求处理类的实例)。<br>socketserver有4个类，分别是<code>TCPServer</code>、<code>UDPServer</code>、<code>UnixStreamServer</code>和<code>UnixDatagramServer</code>。  </p><ol><li><code>class socketserver.TCPServer(server_address, RequestHandlerClass, bind_and_activate=True)</code><br>TCP协议</li><li><code>class socketserver.UDPServer(server_address, RequestHandlerClass, bind_and_activate=True)</code><br>UDP协议，传输过程中可能会造成数据丢失等情况。</li><li><code>class socketserver.UnixStreamServer(server_address, RequestHandlerClass, bind_and_activate=True)</code><br>tcp协议，用于unix机器的进程间通信，不可用于windows主机。</li><li><code>class socketserver.UnixDatagramServer(server_address, RequestHandlerClass, bind_and_activate=True)</code><br>udp协议，用于unix机器的进程间通信，不可用于windows主机。</li></ol><ul><li>继承关系  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------------+</span><br><span class="line">| BaseServer |</span><br><span class="line">+------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----------+        +------------------+</span><br><span class="line">| TCPServer |-------&gt;| UnixStreamServer |</span><br><span class="line">+-----------+        +------------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----------+        +--------------------+</span><br><span class="line">| UDPServer |-------&gt;| UnixDatagramServer |</span><br><span class="line">+-----------+        +--------------------+</span><br></pre></td></tr></table></figure></li></ul><p>上述的4个类用于处理同步的请求，也就是当前请求必须处理完成才能开始下一个请求。不适用于单个请求处理时间很长的情况。<br>单个请求处理需要很长时间的情况，可以创建一个单独的线程或进程去处理每个请求，<code>ForkingMixIn</code>和<code>ThreadingMixIn</code>类支持异步请求。<br>当从<code>ThreadingMixIn</code>继承线程连接时，应该明确声明线程意外关闭时的行为。<code>ThreadingMixIn</code>类中定义了一个属性<code>daemon_threads</code>，它用来标识服务器是否等待线程终止。如果希望线程自动执行，应该明确设置标识，默认情况下是<code>False</code>，也就是python将会在<code>ThreadingMixIn</code>创建的所有线程都退出之后才退出。<br>不论采用何种协议，服务类(server class)的外部方法和属性都是相同的。</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ol><li>创建一个请求处理类，并且这个类要继承<code>BaseRequsetHandler</code>类，重写父类的<code>handle()</code>方法。  </li><li>实例化一个服务类，并给它传递服务端IP地址和上面的请求处理类。推荐在server使用with语句。    </li><li>调用服务对象的<code>handle_request()</code>或者<code>serve_forever()</code>方法，前者用于处理一个请求，后者用于处理多个请求。  </li><li>调用<code>server_close()</code>关闭socket(使用with语句则不需要)。  </li></ol><h4 id="Server-创建说明"><a href="#Server-创建说明" class="headerlink" title="Server 创建说明"></a>Server 创建说明</h4><p><code>class socketserver.ForkingMixIn</code><br><code>class socketserver.ThreadingMixIn</code><br>创建forking和threading类型的服务端可以使用上面的mix-in类。例如，ThreadingUDPServer创建方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadingUDPServer</span><span class="params">(ThreadingMixIn, UDPServer)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>先写mix-in类是因为它重写了UDPServer中定义的一个方法。设置各种属性也会改变底层服务机制的运行。<br>下面提到的ForkingMixIn和Forking类只能在支持fork()的POSIX平台使用。<br><code>class socketserver.ForkingTCPServer</code><br><code>class socketserver.ForkingUDPServer</code><br><code>class socketserver.ThreadingTCPServer</code><br><code>class socketserver.ThreadingUDPServer</code><br>上面的几个类都是在<code>mix-in</code>类中预定义好的。<br>要实现服务，定义的类必须继承自BaseRequestHandler，并且要重新定义<code>handle()</code>方法。接下来将其中的server类和request handler类结合起来，就可以跑不同的服务。<code>datagram</code>和<code>stream</code>服务对应的request handler类不能相同。这个可以通过使用<code>handler</code>的子类<code>StreamRequestHandler</code>或<code>DatagramRequestHandler</code>隐式实现。<br>对于何时应该选用何种方式的服务，还是需要根据实际情况分析。  </p><h4 id="Server-对象"><a href="#Server-对象" class="headerlink" title="Server 对象"></a>Server 对象</h4><p><code>class socketserver.BaseServer(server_address, RequestHandlerClass)</code><br>BaseServer是所有Server对象的超类，它定义了下面的这些接口，但大多数都未实现，在子类中细化。  </p><ul><li>fileno()<br>返回server监听socket的文件描述符，整数。通常用来传递给select.select()以允许一个进程监视多个服务器。  </li><li>handle_request()<br>处理单个请求。该函数依次调用<code>get_request()</code>、<code>verify_request()</code>、<code>process_request()</code>方法。假如用户提提供的<code>handle()</code>方法抛出异常，将会调用服务端的<code>handle_error()</code>方法。如果在timeout时间(单位：s)内未接到用户请求，将会调用<code>handle_timeout()</code>并返回<code>handle_request()</code>。</li><li>serve_forever(poll_interval=0.5)<br>处理请求，直接收到一个明确的<code>shutdown()</code>请求。每隔pool_interval时间轮询一次shutdown。忽略timeout属性。  </li><li>server_actions()<br>在<code>serve_forever()</code>循环中调用。该方法可以在子类中重写，为指定的服务执行指定的动作。  </li><li>shutdown()<br>告诉<code>serve_forever()</code>循环停止并等待其停止。  </li><li>server_close()<br>清理服务。可以被重写。  </li><li>address_family()<br>server socket所属的协议簇。例如<code>socket.AF_INET</code>和<code>socket.AF_UNIX</code>。</li><li>RequestHandlerClass<br>用户提供的请求处理类。这个类为每个请求创建实例。  </li><li>server_address<br>server监听的地址。地址的格式由协议决定。对于<code>Internet protocols</code>，就是一个元组，包括字符串类型的地址和整型的端口号。  <h4 id="Request-Handler-对象"><a href="#Request-Handler-对象" class="headerlink" title="Request Handler 对象"></a>Request Handler 对象</h4><code>class socketserver.BaseRequestHandler</code><br>这是所有<code>request handler</code>对象的超类。它定义了下面的接口。一个具体的<code>request handler</code>子类必须定义一个新的<code>handle()</code>方法，并且可以重写任何其他的方法。会为每一个请求创建子类的实例。  </li><li>setup()<br>在<code>hanlde()</code>方法自行任何初始化动作之前被调用。默认什么也不做。  </li><li>handle()<br>该函数处理服务请求的所有工作。默认什么也不做。可用的几个实例的属性：<code>self.request</code>、<code>self.client_address</code>、<code>self.server</code>。<br>对于<code>stream</code>服务，<code>self.request</code>返回一个socket对象。对于<code>datagram</code>服务，<code>self.request</code>返回<code>string和socket</code>。</li><li>finsh()<br>在<code>handle()</code>方法之后被调用，执行一些清理动作。默认什么也不做。假如<code>setup()</code>出现异常，这个函数将不会被调用。<br><code>class socketserver.StreamRequestHandler</code><br><code>class socketserver.DatagramRequestHandler</code><br>上面的2个<code>BaseRequestHandler</code>的子类重写了<code>setup()</code>和<code>finsh()</code>方法，同时提供<code>self.rfile</code>和<code>self.wfile</code>属性。<code>self.rfile</code>和<code>self.wfile</code>可以读取或写入，以获得请求数据或将数据返回到客户端。  <h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><code>服务端</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTcpHandler</span><span class="params">(socketserver.BaseRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.data = self.request.recv(<span class="number">1024</span>).strip()</span><br><span class="line">                print(<span class="string">"&#123;&#125; wrote:"</span>.format(self.client_address[<span class="number">0</span>]), end=<span class="string">" "</span>)</span><br><span class="line">                print(self.data)</span><br><span class="line">                self.request.sendall(self.data.upper())</span><br><span class="line">            <span class="keyword">except</span> ConnectionResetError <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">"err "</span>, e)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    HOST, PORT = <span class="string">"localhost"</span>, <span class="number">9999</span></span><br><span class="line">    <span class="keyword">with</span> socketserver.ThreadingTCPServer((HOST, PORT), MyTcpHandler) <span class="keyword">as</span> server:</span><br><span class="line">        server.serve_forever()</span><br></pre></td></tr></table></figure></li></ul><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><code>客户端</code></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client = socket.socket()</span><br><span class="line">client.connect((<span class="string">'localhost'</span>, <span class="number">9999</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    msg = input(<span class="string">"&gt;&gt;&gt;"</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> len(msg) ==<span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    client.send(msg.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">"recv:&gt;"</span>,data.decode())</span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure><p>实现效果<br>在客户端输入内容，服务端可看到输入内容；<br>多个客户端可同时连接，服务端可分别显示不同客户端显示的内容。<br>更多关于socketserver的内容点击<a href="https://docs.python.org/3/library/socketserver.html" target="_blank" rel="noopener">socketserver — A framework for network servers</a>查看官方介绍。</p><h3 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select/poll/epoll"></a>select/poll/epoll</h3><p><code>select/poll/epoll</code>也是IO multiplexing(I/O多路复用)，有时候也称这种I/O方式为event driven IO。它的好处在于单个process就可以同时处理多个网络连接的I/O。<br>基本原理是<code>select/poll/epoll</code>函数会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>通过一个<code>select()</code>系统调用来监视多个文件描述符的数组，当<code>select()</code>返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。<br>selecet目前几乎所有的平台都支持。<br>一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。<br>另外，<code>select()</code>所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用<code>select()</code>会对所有的socket进行一次线性扫描，所以这也浪费了一定的开销。  </p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。<br>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。<br>另外，<code>select()</code>和<code>poll()</code>将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。  </p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。<br>epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。<br>另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</p><p>更多关于select模块的内容点击<a href="https://docs.python.org/3/library/select.html" target="_blank" rel="noopener">select — Waiting for I/O completion</a>查看官方介绍。<br>网络编程更多的关于<code>事件驱动模型</code>、<code>异步I/O</code>、<code>I/O多路复用</code>的内容可以参考<a href="http://www.cnblogs.com/bigberg/category/1097785.html" target="_blank" rel="noopener">网络编程基础</a>。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于socket的基础介绍可以点击&lt;a href=&quot;https://rosinelan.coding.me/2018/06/01/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocket/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;python网络编程之socket&lt;/a&gt;查看。  &lt;/p&gt;
&lt;h3 id=&quot;socketserver&quot;&gt;&lt;a href=&quot;#socketserver&quot; class=&quot;headerlink&quot; title=&quot;socketserver&quot;&gt;&lt;/a&gt;socketserver&lt;/h3&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;socket并不能多并发，只能支持一个用户。socketserver则实现了并发处理。当有多个客户端连接时，socketserver都会在服务器上创建一个线程或进程来处理该客户端的请求，一个客户端对应一个服务端的进程或线程，这样增加系统的利用率。&lt;br&gt;socketserver是socket的封装，简化了编写网络服务程序的任务。python2中为&lt;code&gt;SocketServer&lt;/code&gt;，python3中取消了首字母大写，改为&lt;code&gt;socketserver&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="socketserver" scheme="https://rosinelan.github.io/tags/socketserver/"/>
    
      <category term="handle" scheme="https://rosinelan.github.io/tags/handle/"/>
    
      <category term="TCPServer" scheme="https://rosinelan.github.io/tags/TCPServer/"/>
    
      <category term="UDPServer" scheme="https://rosinelan.github.io/tags/UDPServer/"/>
    
  </entry>
  
  <entry>
    <title>python网络编程之socket</title>
    <link href="https://rosinelan.github.io/2018/06/01/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocket/"/>
    <id>https://rosinelan.github.io/2018/06/01/python网络编程之socket/</id>
    <published>2018-06-01T12:28:37.000Z</published>
    <updated>2018-06-01T15:54:53.716Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程，肯定就会涉及到网络中进程的通信，那么网络中进程如何通信呢？  </p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="网络中的进程通信"><a href="#网络中的进程通信" class="headerlink" title="网络中的进程通信"></a>网络中的进程通信</h4><p>首先需要标识一个进程。本地可以通过进程PID来唯一标识一个进程，但在网络中不可行。TCP/IP协议中，在网络层用<code>IP地址</code>唯一标识网络中的主机，传输层中用<code>协议+端口</code>唯一标识主机中的应用程序(进程)，这样利用三元组(IP地址，协议，端口)就可以标识网络的进程，网络中的进程通信就可以利用这个标识与其它进程进行交互。<br>使用TCP/IP协议的应用程序通常采用引用编程接口:UNIX BSD的套接字(socket)来实现网络进程之间的通信。<br><a id="more"></a><br><img src="http://cdn.rosinelan.com/blog/program/python-socket-module.png" alt="python-socket-module" title="python-socket-module"></p><h4 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h4><p>TCP是<code>Transmission Control Protocol</code>(传输控制协议)的简写。<br>TCP是一种面向连接的，提供可靠交付服务和全双工通信的，基于字节流的端到端的传输层通信协议。<br>TCP在传输数据之前必须先建立连接，数据传输结束后要释放连接。<br>每一条TCP连接只能有2个端点，故TCP不提供广播或多播服务。<br>TCP提供可靠交付，通过TCP连接传输的数据，无差错、不丢失、不重复、并且按序到达。<br>TCP是面向字节流的。虽然应用进程和TCP的交互是一次一个数据块(大小不等），但TCP把英语程序交下来的数据看成仅仅是一连串的无结构的字节流。TCP并不知道所传输的字节流的含义。<br><code>TCP三次握手</code><br>状态说明<br><code>SYN</code>表示建立连接，<code>FIN</code>表示关闭连接，<code>ACK</code>表示响应，<code>PSH</code>表示有DATA数据传输，<code>RST</code>表示连接重置。    </p><ol><li>客户端向服务器发送一个SYN J。</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1。</li><li>客户端再向服务器发一个确认ACK K+1。<br>至此连接建立完成。<br><img src="http://cdn.rosinelan.com/blog/program/python-tcp-establish.png" alt="python-tcp-establish" title="python-tcp-establish"><br><code>TCP四次挥手</code><br>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。<br>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送(M)。<br>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1(M+1)。和SYN一样，一个FIN将占用一个序号。<br>服务器B关闭与客户端A的连接，发送一个FIN给客户端A(N)。<br>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1(N+1)。<br><img src="http://cdn.rosinelan.com/blog/program/python-tcp-close.png" alt="python-tcp-close" title="python-tcp-close"><h4 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h4>UDP是<code>User Datagram Protocol</code>(用户数据报协议)的简写。<br>UDP是一种无连接的，尽最大努力交付的，基于报文的端到端的传输层通信协议。<br>UDP在发送数据之前不需要建立连接；UDP不保证可靠交付，主机不需要位置复杂的连接状态。<br>UDP是面向报文的。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的的边界，即应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。在接收端，UDP一次交付一个完整的报文。<br>UDP没有拥塞控制，网络出现的拥塞不会使源主机的发送速率降低。<br>UDP支持一对一、一对多、多对一和多对多的交互通信。<br>UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。  <h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3>套接字的格式<br>socket(family,type[,protocal])<br>使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。<h4 id="socket类型"><a href="#socket类型" class="headerlink" title="socket类型"></a>socket类型</h4></li></ol><ul><li>socket.AF_UNIX<br>只能够用于单一的Unix系统进程间通信。  </li><li>socket.AF_INET<br>服务器之间网络通信。  </li><li>socket.AF_INET6<br>IPv6</li><li>socket.SOCK_STREAM<br>流式socket , for TCP。</li><li>socket.SOCK_DGRAM<br>数据报式socket , for UDP。</li><li>socket.SOCK_RAW<br>原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。</li><li>socket.SOCK_SEQPACKET<br>可靠的连续数据包服务。  </li></ul><p>创建TCP Socket <code>s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</code><br>创建UDP Socket <code>s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</code></p><h4 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h4><p><strong>服务端socket函数</strong></p><ul><li>s.bind(address)<br>将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址。</li><li>s.listen(backlog)<br>开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。</li><li>s.accept()<br>接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。<br><strong>客户端socket</strong></li><li>s.connect(address)<br>接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。  </li><li>s.connect_ex(adddress)<br>功能与connect(address)相同，但是成功返回0，失败返回errno的值。<br><strong>公共socket函数</strong></li><li>s.recv(bufsize[,flag])<br>接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。  </li><li>s.send(string[,flag])<br>发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。</li><li>s.sendall(string[,flag])<br>完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。</li><li>s.recvfrom(bufsize[.flag])<br>接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</li><li>s.sendto(string[,flag],address)<br>发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。</li><li>s.close()<br>关闭套接字。</li><li>s.getpeername()<br>返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</li><li>s.getsockname()<br>返回套接字自己的地址。通常是一个元组(ipaddr,port)</li><li>s.setsockopt(level,optname,value)<br>设置给定套接字选项的值。</li><li>s.getsockopt(level,optname[.buflen])<br>返回套接字选项的值。</li><li>s.settimeout(timeout)<br>设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）</li><li>s.gettimeout()<br>返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。</li><li>s.fileno()<br>返回套接字的文件描述符。</li><li>s.setblocking(flag)<br>如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。</li><li>s.makefile()<br>创建一个与该套接字相关连的文件</li></ul><h3 id="python中socket编程步骤"><a href="#python中socket编程步骤" class="headerlink" title="python中socket编程步骤"></a>python中socket编程步骤</h3><p><img src="http://cdn.rosinelan.com/blog/program/python-socket-axiom.png" alt="&quot;python-socket-axiom&quot;" title="python-socket-axiom"></p><h4 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h4><ol><li><p>创建套接字，绑定套接字到本地IP与端口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">address = (<span class="string">'0.0.0.0'</span>, <span class="number">8090</span>)</span><br><span class="line">s.bind(address)</span><br></pre></td></tr></table></figure></li><li><p>开始监听连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.listen(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li><li><p>进入循环，不断接受客户端的连接请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.accept()</span><br></pre></td></tr></table></figure></li><li><p>然后接收传来的数据，并发送给对方数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.recv(bufsize)</span><br><span class="line">s.sendall(string)</span><br></pre></td></tr></table></figure></li><li><p>传输完毕后，关闭套接字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.close()</span><br></pre></td></tr></table></figure></li></ol><h4 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端:"></a>TCP客户端:</h4><ol><li><p>创建套接字，连接远端地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.connect()</span><br></pre></td></tr></table></figure></li><li><p>连接后发送数据和接收数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.sendall()</span><br><span class="line">s.recv()</span><br></pre></td></tr></table></figure></li><li><p>传输完毕后，关闭套接字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.close()</span><br></pre></td></tr></table></figure></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="TCP服务端-1"><a href="#TCP服务端-1" class="headerlink" title="TCP服务端"></a>TCP服务端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">address = (<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>)</span><br><span class="line">s.bind(address)</span><br><span class="line">s.listen(<span class="number">10</span>)</span><br><span class="line">print(<span class="string">"start server"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn, addr = s.accept()</span><br><span class="line">        <span class="keyword">if</span> conn:</span><br><span class="line">            print(<span class="string">"recv client from &#123;0&#125;"</span>.format(addr))</span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">                data = conn.recv(<span class="number">2048</span>)</span><br><span class="line">                print(<span class="string">"recv data:&#123;0&#125;"</span>.format(data.decode(<span class="string">'utf-8'</span>)))</span><br><span class="line">                conn.sendall(data.decode(<span class="string">'utf-8'</span>).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure><h4 id="TCP客户端-1"><a href="#TCP客户端-1" class="headerlink" title="TCP客户端"></a>TCP客户端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">address = (<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>)</span><br><span class="line">s.connect(address)</span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line">print(<span class="string">"start client"</span>)</span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    word = input(<span class="string">"word:"</span>)</span><br><span class="line">    <span class="keyword">if</span> word == <span class="string">"exit"</span>:</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">    s.sendall(word.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    data = s.recv(<span class="number">2048</span>)</span><br><span class="line">    print(<span class="string">"recv:&#123;0&#125;"</span>.format(data.decode(<span class="string">'utf-8'</span>)))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p>实现效果<br>分别启动服务端和客户端，在客户端输入，服务端可查看到客户端输入的内容。<br>在客户端输入exit，客户端进程结束。  </p><p>更多关于<code>socket</code>的内容可以点击<a href="https://docs.python.org/3/library/socket.html" target="_blank" rel="noopener">socket — Low-level networking interface</a>查看官方介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络编程，肯定就会涉及到网络中进程的通信，那么网络中进程如何通信呢？  &lt;/p&gt;
&lt;h3 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h3&gt;&lt;h4 id=&quot;网络中的进程通信&quot;&gt;&lt;a href=&quot;#网络中的进程通信&quot; class=&quot;headerlink&quot; title=&quot;网络中的进程通信&quot;&gt;&lt;/a&gt;网络中的进程通信&lt;/h4&gt;&lt;p&gt;首先需要标识一个进程。本地可以通过进程PID来唯一标识一个进程，但在网络中不可行。TCP/IP协议中，在网络层用&lt;code&gt;IP地址&lt;/code&gt;唯一标识网络中的主机，传输层中用&lt;code&gt;协议+端口&lt;/code&gt;唯一标识主机中的应用程序(进程)，这样利用三元组(IP地址，协议，端口)就可以标识网络的进程，网络中的进程通信就可以利用这个标识与其它进程进行交互。&lt;br&gt;使用TCP/IP协议的应用程序通常采用引用编程接口:UNIX BSD的套接字(socket)来实现网络进程之间的通信。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="socket" scheme="https://rosinelan.github.io/tags/socket/"/>
    
      <category term="bind" scheme="https://rosinelan.github.io/tags/bind/"/>
    
      <category term="tcp" scheme="https://rosinelan.github.io/tags/tcp/"/>
    
      <category term="udp" scheme="https://rosinelan.github.io/tags/udp/"/>
    
  </entry>
  
  <entry>
    <title>python单词查找练习题</title>
    <link href="https://rosinelan.github.io/2018/05/30/python%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <id>https://rosinelan.github.io/2018/05/30/python单词查找练习题/</id>
    <published>2018-05-30T15:38:30.000Z</published>
    <updated>2018-05-30T17:36:45.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>现有一个文件<code>dictionary.txt</code>，要求对数据进行处理，分别将英文单词和中文解释保存到mysql数据库，并且可通过输入关键字进行模糊匹配查询。<br><code>dictionary.txt</code>文件格式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abandon   v.抛弃，放弃</span><br><span class="line">abandonment   n.放弃</span><br><span class="line">abbreviation   n.缩写</span><br><span class="line">abeyance   n.缓办，中止</span><br><span class="line">abide   v.遵守</span><br><span class="line">ability   n.能力</span><br></pre></td></tr></table></figure></p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><a id="more"></a><ol><li>数据库建表，表字段至少包括<code>单词</code>和<code>含义</code>。涉及知识点为<code>SQLAlchemy</code>，主要是创建表。  </li><li>读取文件并对内容进行处理，然后插入数据库。涉及知识点为<code>文件读写</code>、<code>字符串处理</code>、<code>SQLAlchemy</code>插入数据。  </li><li>通过关键字进行模糊匹配。涉及知识点为<code>SQLAlchemy</code>查询。<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="数据库建表"><a href="#数据库建表" class="headerlink" title="数据库建表"></a>数据库建表</h4><code>createTable.py</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, Column, String, Integer</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:123456@localhost/test"</span>)</span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'dictionary'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    wod = Column(String(<span class="number">50</span>))</span><br><span class="line">    mean = Column(String(<span class="number">50</span>))</span><br><span class="line"></span><br><span class="line">Base.metadata.create_all(engine)</span><br></pre></td></tr></table></figure></li></ol><p>mysql数据库查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc dictionary;</span><br><span class="line">+<span class="comment">-------+-------------+------+-----+---------+----------------+</span></span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+<span class="comment">-------+-------------+------+-----+---------+----------------+</span></span><br><span class="line">| id    | int(11)     | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| key   | varchar(50) | YES  |     | NULL    |                |</span><br><span class="line">| value | varchar(50) | YES  |     | NULL    |                |</span><br><span class="line">+<span class="comment">-------+-------------+------+-----+---------+----------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p><code>insertData.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> fuzzyMatching.createTable <span class="keyword">import</span> Dictionary</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:123456@localhost/test?charset=utf8"</span>)</span><br><span class="line">DBsession = sessionmaker(bind=engine)</span><br><span class="line">session = DBsession()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerData</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dataFile)</span>:</span></span><br><span class="line">        self.dataFile = dataFile</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_data_to_str</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> codecs.open(self.dataFile, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            <span class="keyword">for</span> (num, value) <span class="keyword">in</span> enumerate(file):</span><br><span class="line">                line = value.strip().split()</span><br><span class="line">                diction = Dictionary(id=num+<span class="number">1</span>, wod=line[<span class="number">0</span>], mean=line[<span class="number">1</span>])</span><br><span class="line">                session.add(diction)</span><br><span class="line">        session.commit()</span><br><span class="line"></span><br><span class="line">handlerData = HandlerData(<span class="string">'dictionary.txt'</span>)</span><br><span class="line">handlerData.make_data_to_str()</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></p><p>mysql数据库查询结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from dictionary;</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">| count(*) |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">|     7988 |</span><br><span class="line">+<span class="comment">----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure></p><h4 id="数据模糊匹配"><a href="#数据模糊匹配" class="headerlink" title="数据模糊匹配"></a>数据模糊匹配</h4><p><code>fuzzyMatch.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> fuzzyMatching.createTable <span class="keyword">import</span> Dictionary</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:123456@localhost/test?charset=utf8"</span>)</span><br><span class="line">DBsession = sessionmaker(bind=engine)</span><br><span class="line">session = DBsession()</span><br><span class="line">word = input(<span class="string">"Please input a word:"</span>)</span><br><span class="line">zero_result = session.query(Dictionary).filter(Dictionary.wod.like(<span class="string">"%&#123;0&#125;%"</span>.format(word))).all()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> zero_result:</span><br><span class="line">    print(i.id, i.wod, i.mean)</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Please input a word:test</span><br><span class="line">]<span class="number">1517</span> contest n.,v.争夺，比赛</span><br><span class="line"><span class="number">1518</span> contestant n.参赛人</span><br><span class="line"><span class="number">5604</span> protest v.,n.抗议，反对</span><br><span class="line"><span class="number">5605</span> protestant n.清教徒，新教徒</span><br><span class="line"><span class="number">7159</span> test v.,n.测验，试验</span><br><span class="line"><span class="number">7160</span> testify v.证明，证实</span><br><span class="line"><span class="number">7161</span> testimony n.证据</span><br></pre></td></tr></table></figure></p><h3 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h3><ol><li>UnicodeEncodeError: ‘latin-1’ codec can’t encode characters in position 18-22: ordinal not in range(256)  </li><li>查询结果汉字乱码  </li></ol><p>处理方法<br>在创建engine时需要添加<code>?charset=utf8</code>参数</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;p&gt;现有一个文件&lt;code&gt;dictionary.txt&lt;/code&gt;，要求对数据进行处理，分别将英文单词和中文解释保存到mysql数据库，并且可通过输入关键字进行模糊匹配查询。&lt;br&gt;&lt;code&gt;dictionary.txt&lt;/code&gt;文件格式&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;abandon   v.抛弃，放弃&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;abandonment   n.放弃&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;abbreviation   n.缩写&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;abeyance   n.缓办，中止&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;abide   v.遵守&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ability   n.能力&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h3&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="sql" scheme="https://rosinelan.github.io/tags/sql/"/>
    
      <category term="orm" scheme="https://rosinelan.github.io/tags/orm/"/>
    
      <category term="mysql" scheme="https://rosinelan.github.io/tags/mysql/"/>
    
      <category term="session" scheme="https://rosinelan.github.io/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>python任务调度模块celery(二)</title>
    <link href="https://rosinelan.github.io/2018/05/27/python%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97celery-%E4%BA%8C/"/>
    <id>https://rosinelan.github.io/2018/05/27/python任务调度模块celery-二/</id>
    <published>2018-05-27T14:23:50.000Z</published>
    <updated>2018-05-28T03:09:20.864Z</updated>
    
    <content type="html"><![CDATA[<p>关于celery的的基础介绍及安装使用参见<a href="https://rosinelan.coding.me/2018/05/25/python%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97celery/" target="_blank" rel="noopener">python任务调度模块celery</a>。  </p><h3 id="多worker和多队列"><a href="#多worker和多队列" class="headerlink" title="多worker和多队列"></a>多worker和多队列</h3><p>首先是多worker和多队列的原理及流程图。<br><a id="more"></a><br><img src="http://cdn.rosinelan.com/blog/program/celery-multi-queue.png" alt="celery-multi-queue" title="celery-multi-queue"><br>一般情况下对于多worker和多队列的配置文件单独写在一个配置文件，方便管理和配置。  </p><h4 id="定义任务列表"><a href="#定义任务列表" class="headerlink" title="定义任务列表"></a>定义任务列表</h4><p><code>multique.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery()</span><br><span class="line">app.config_from_object(<span class="string">"celeryconfig"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taskA</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*y</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">taskB</span><span class="params">(x, y, z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y+z</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br></pre></td></tr></table></figure></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p><code>celeryconfig.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kombu <span class="keyword">import</span> Queue, Exchange</span><br><span class="line"></span><br><span class="line">BROKER_URL = <span class="string">"redis://118.24.18.158:6380/1"</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">"redis://118.24.18.158:6380/2"</span></span><br><span class="line"></span><br><span class="line">CELERY_QUEUES = &#123;</span><br><span class="line">    Queue(<span class="string">"default"</span>, Exchange(<span class="string">"default"</span>), routing_key=<span class="string">"default"</span>),</span><br><span class="line">    Queue(<span class="string">"for_task_A"</span>, Exchange(<span class="string">"for_task_A"</span>), routing_key=<span class="string">"for_task_A"</span>),</span><br><span class="line">    Queue(<span class="string">"for_task_B"</span>, Exchange(<span class="string">"for_task_B"</span>), routing_key=<span class="string">"for_task_B"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CELERY_ROUTES = &#123;</span><br><span class="line">    <span class="string">"multique.taskA"</span>: &#123;<span class="string">"queue"</span>: <span class="string">"for_task_A"</span>, <span class="string">"routing_key"</span>: <span class="string">"for_task_A"</span>&#125;,</span><br><span class="line">    <span class="string">"multique.taskB"</span>: &#123;<span class="string">"queue"</span>: <span class="string">"for_task_B"</span>, <span class="string">"routing_key"</span>: <span class="string">"for_task_B"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="启动celery-worker监听"><a href="#启动celery-worker监听" class="headerlink" title="启动celery worker监听"></a>启动celery worker监听</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">celery -A multique worker -l=info -n workerA.%h -Q for_task_A</span><br><span class="line"> celery -A multique worker -l=info -n workerB.%h -Q for_task_B</span><br></pre></td></tr></table></figure><h4 id="调用任务"><a href="#调用任务" class="headerlink" title="调用任务"></a>调用任务</h4><p><code>multicelery.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue1.multique <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">re1 = taskA.delay(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">re2 = taskB.delay(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br><span class="line">re3 = add.delay(<span class="number">1000</span>, <span class="number">2000</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">print(re1.result) <span class="comment">#输出结果：200</span></span><br><span class="line">print(re2.result) <span class="comment">#输出结果：600</span></span><br><span class="line">print(re3.status) <span class="comment">#输出结果：PENDING</span></span><br><span class="line">print(re3.result) <span class="comment">#输出结果：None</span></span><br></pre></td></tr></table></figure></p><p>我们看到状态是PENDING，表示没有执行，这个是因为没有celeryconfig.py文件中指定改route到哪一个Queue中，所以会被发动到默认的名字celery的Queue中，但是我们还没有启动worker执行celery中的任务。下面，我们来启动一个worker来执行celery队列中的任务。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A multique worker -l info -n worker.%h -Q celery</span><br></pre></td></tr></table></figure></p><p>再次调用任务，状态应该为SUCCESS,结果为3000。</p><h3 id="celery定时任务"><a href="#celery定时任务" class="headerlink" title="celery定时任务"></a>celery定时任务</h3><p>celery定时任务，<code>Celery Beat</code>进程通过读取配置文件的内容，周期性的将定时任务发往任务队列。<br>以上面多worker的异步任务为例，配置文件<code>celeryconfig.py</code> 中添加<code>CELERYBEAT_SCHEDULE</code>变量，添加内容如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CELERY_TIMEZONE = <span class="string">'UTC'</span> <span class="comment">#指定时区，默认为UTC</span></span><br><span class="line">CELERYBEAT_SCHEDULE = &#123;</span><br><span class="line">    <span class="string">'taskA_schedule'</span>: &#123;</span><br><span class="line">        <span class="string">'task'</span>: <span class="string">'multique.taskA'</span>,</span><br><span class="line">        <span class="string">'schedule'</span>: <span class="number">2</span>, <span class="comment">#每2s执行一次</span></span><br><span class="line">        <span class="string">'args'</span>: (<span class="number">5</span>, <span class="number">6</span>) <span class="comment">#传递函数参数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'taskB_scheduler'</span>: &#123;</span><br><span class="line">        <span class="string">'task'</span>: <span class="string">"multique.taskB"</span>,</span><br><span class="line">        <span class="string">"schedule"</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">"args"</span>:(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'add_schedule'</span>: &#123;</span><br><span class="line">        <span class="string">"task"</span>: <span class="string">"multique.add"</span>,</span><br><span class="line">        <span class="string">"schedule"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">"args"</span>: (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参数说明  </p><ul><li>task<br>指定任务的名字</li><li>schedule<br>设定任务的调度方式(设定任务如何重复执行)，可以是一个表示秒的整数，也可以是一个 timedelta 对象，或者是一个 crontab 对象</li><li>args<br>任务的参数列表</li><li>kwargs<br>任务的参数字典</li><li>options<br>所有 apply_async 所支持的参数<h4 id="启动celery-worker进程"><a href="#启动celery-worker进程" class="headerlink" title="启动celery worker进程"></a>启动celery worker进程</h4>在项目根目录执行命令  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A celeryapp worker -l=info    <span class="comment">#celeryapp为项目文件所在的package名称</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="启动celery-beat进程"><a href="#启动celery-beat进程" class="headerlink" title="启动celery beat进程"></a>启动celery beat进程</h4><p>启动Celery Beat进程，定时将任务发送到Broker，在项目根目录执行下面命令<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery beat -A celeryapp</span><br></pre></td></tr></table></figure></p><p>之后在启动的worker窗口可以看到任务定时执行的情况。<br>启动worker和beat进程也可以放在同一个命令中执行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -B -A celeryapp worker --loglevel=info</span><br></pre></td></tr></table></figure></p><p>更多celery定时任务相关内容点击<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html" target="_blank" rel="noopener">Periodic Tasks</a>查看官方介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于celery的的基础介绍及安装使用参见&lt;a href=&quot;https://rosinelan.coding.me/2018/05/25/python%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97celery/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;python任务调度模块celery&lt;/a&gt;。  &lt;/p&gt;
&lt;h3 id=&quot;多worker和多队列&quot;&gt;&lt;a href=&quot;#多worker和多队列&quot; class=&quot;headerlink&quot; title=&quot;多worker和多队列&quot;&gt;&lt;/a&gt;多worker和多队列&lt;/h3&gt;&lt;p&gt;首先是多worker和多队列的原理及流程图。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="celery" scheme="https://rosinelan.github.io/tags/celery/"/>
    
      <category term="定时任务" scheme="https://rosinelan.github.io/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="多线程" scheme="https://rosinelan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python多线程练习题</title>
    <link href="https://rosinelan.github.io/2018/05/27/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <id>https://rosinelan.github.io/2018/05/27/python多线程练习题/</id>
    <published>2018-05-27T12:50:24.000Z</published>
    <updated>2018-05-27T13:59:11.652Z</updated>
    
    <content type="html"><![CDATA[<p>多线程练习题目，涉及知识点较多，属于很好的练习题。  </p><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>通过多线程实现类似linux中的<code>&gt;&gt;</code>功能，也就是将日志记录到指定的文件中。  </p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>基本为<code>main.py</code>写主要处理逻辑，<code>utils.py</code>构造工具类及对应的方法。<br><code>main.py</code><br>定义Server()类，类中定义方法输出内容。<br>实例化工具类，启动线程，设置标准输出和错误输出至日志文件。<br>实例化Server()类并调用方法进行内容的持续输出。<br><a id="more"></a><br><code>utils.py</code><br>定义工具类，工具类需要传入参数：日志名称。<br>首先判断日志是否存在，若不存在则创建，然后写入日志；存在则追加写入日志。  </p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><code>main.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> queue1.log_out.utils <span class="keyword">import</span> TraceLog</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"start server"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">            print(i)</span><br><span class="line">        print(<span class="string">"end server"</span>) <span class="comment">#print的实现是调用sys.stdout.write()方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    traceLog = TraceLog(<span class="string">"main.log"</span>)</span><br><span class="line">    traceLog.start()</span><br><span class="line">    sys.stdout = traceLog </span><br><span class="line">    sys.stderr = traceLog</span><br><span class="line">    server = Server()</span><br><span class="line">    server.log() <span class="comment">#print将会调用traceLog.write()方法</span></span><br></pre></td></tr></table></figure></p><p><code>utils.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceLog</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, logName)</span>:</span></span><br><span class="line">        super(TraceLog, self).__init__() <span class="comment">#调用父类的初始化方法</span></span><br><span class="line">        self.logName = logName</span><br><span class="line">        self.lock = Lock()</span><br><span class="line">        self.contexts = []</span><br><span class="line">        self.isFile()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFile</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(self.logName):</span><br><span class="line">            <span class="keyword">with</span> codecs.open(self.logName, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="string">"this log name is :&#123;0&#125;\n"</span>.format(self.logName))</span><br><span class="line">                f.write(<span class="string">"start log\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, context)</span>:</span></span><br><span class="line">        self.contexts.append(context) <span class="comment">#将需要输出的内容追加至列表中</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            self.lock.acquire()</span><br><span class="line">            <span class="keyword">if</span> len(self.contexts) != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">with</span> codecs.open(self.logName, <span class="string">'a'</span>) <span class="keyword">as</span> f: <span class="comment">#追加方式写入文件</span></span><br><span class="line">                    <span class="keyword">for</span> context <span class="keyword">in</span> self.contexts:</span><br><span class="line">                        f.write(context)</span><br><span class="line">                <span class="keyword">del</span> self.contexts[:] <span class="comment">#每次写入完成后清空列表</span></span><br><span class="line">            self.lock.release()</span><br></pre></td></tr></table></figure></p><p>输出结果<br>当前目录下会生成<code>main.log</code>文件，文件内容如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">this log name <span class="keyword">is</span> :main.log</span><br><span class="line">start log</span><br><span class="line">start server</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="number">98</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line">end server</span><br></pre></td></tr></table></figure></p><p>涉及文件读写、锁、多线程、sys模块、os模块等内容。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程练习题目，涉及知识点较多，属于很好的练习题。  &lt;/p&gt;
&lt;h3 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h3&gt;&lt;p&gt;通过多线程实现类似linux中的&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;功能，也就是将日志记录到指定的文件中。  &lt;/p&gt;
&lt;h3 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h3&gt;&lt;p&gt;基本为&lt;code&gt;main.py&lt;/code&gt;写主要处理逻辑，&lt;code&gt;utils.py&lt;/code&gt;构造工具类及对应的方法。&lt;br&gt;&lt;code&gt;main.py&lt;/code&gt;&lt;br&gt;定义Server()类，类中定义方法输出内容。&lt;br&gt;实例化工具类，启动线程，设置标准输出和错误输出至日志文件。&lt;br&gt;实例化Server()类并调用方法进行内容的持续输出。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="log" scheme="https://rosinelan.github.io/tags/log/"/>
    
      <category term="sys" scheme="https://rosinelan.github.io/tags/sys/"/>
    
      <category term="os" scheme="https://rosinelan.github.io/tags/os/"/>
    
      <category term="threading" scheme="https://rosinelan.github.io/tags/threading/"/>
    
      <category term="write" scheme="https://rosinelan.github.io/tags/write/"/>
    
  </entry>
  
  <entry>
    <title>python任务调度模块celery</title>
    <link href="https://rosinelan.github.io/2018/05/25/python%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97celery/"/>
    <id>https://rosinelan.github.io/2018/05/25/python任务调度模块celery/</id>
    <published>2018-05-25T13:21:29.000Z</published>
    <updated>2018-05-27T13:59:27.564Z</updated>
    
    <content type="html"><![CDATA[<h3 id="celery简介"><a href="#celery简介" class="headerlink" title="celery简介"></a>celery简介</h3><p>Celery是一个python开发的异步分布式任务调度模块。<br>Celery本身并不提供消息服务，使用第三方服务，也就是borker来传递任务，一般使用rabbitMQ或者Redis。  </p><ul><li>Celery特点<br>简单：一单熟悉了celery的工作流程后，配置和使用还是比较简单的。<br>高可用：当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务。<br>快速：一个单进程的celery每分钟可处理上百万个任务。<br>灵活： 几乎celery的各个组件都可以被扩展及自定制。  <a id="more"></a></li><li>Celery工作流程图<br><img src="http://cdn.rosinelan.com/blog/program/python-Celery.png" alt="python-Celery" title="python-Celery"><h3 id="celery安装使用"><a href="#celery安装使用" class="headerlink" title="celery安装使用"></a>celery安装使用</h3>安装Celery模块<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install celery</span><br></pre></td></tr></table></figure></li></ul><p>Celery的默认broker是RabbitMQ，仅需配置一行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broker_url = <span class="string">'amqp://guest:guest@localhost:5672//'</span></span><br></pre></td></tr></table></figure></p><p>RabbitMQ的安装点击<a href="http://docs.celeryproject.org/en/latest/getting-started/brokers/rabbitmq.html#id3" target="_blank" rel="noopener">Using RabbitMQ</a>查看。<br>redis作为broker也可以。  </p><ul><li><p>安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure></li><li><p>配置<br>broker_url配置redis数据库地址，格式为<code>redis://:password@hostname:port/db_number</code>。<br>backend配置任务结果存储位置，将保存每个任务的执行结果。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.conf.broker_url = <span class="string">'redis://localhost:6379/0'</span></span><br><span class="line">app.conf.result_backend = <span class="string">'redis://localhost:6379/0'</span></span><br></pre></td></tr></table></figure></li></ul><p>port和db_number是可选项，默认情况下端口使用6379，db_number使用0。  </p><ul><li>示例<br>创建一个celery application定义任务列表，新建一个<code>celery1.py</code>文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line">broker = <span class="string">"redis://118.24.18.158:6379/5"</span></span><br><span class="line">backend = <span class="string">"redis://118.24.18.158:6379/6"</span></span><br><span class="line">app = Celery(<span class="string">"celery1"</span>, broker=broker, backend=backend)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br></pre></td></tr></table></figure></li></ul><p>启动Celery Worker开始监听并执行任务<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A celery1 worker --loglevel=info</span><br></pre></td></tr></table></figure></p><p>调用任务<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery1 <span class="keyword">import</span> add</span><br><span class="line"></span><br><span class="line">re = add.delay(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">print(re)</span><br><span class="line">print(re.status)</span><br><span class="line">time.sleep(<span class="number">8</span>)</span><br><span class="line">print(re.status)</span><br><span class="line">print(re.result)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;celery简介&quot;&gt;&lt;a href=&quot;#celery简介&quot; class=&quot;headerlink&quot; title=&quot;celery简介&quot;&gt;&lt;/a&gt;celery简介&lt;/h3&gt;&lt;p&gt;Celery是一个python开发的异步分布式任务调度模块。&lt;br&gt;Celery本身并不提供消息服务，使用第三方服务，也就是borker来传递任务，一般使用rabbitMQ或者Redis。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Celery特点&lt;br&gt;简单：一单熟悉了celery的工作流程后，配置和使用还是比较简单的。&lt;br&gt;高可用：当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务。&lt;br&gt;快速：一个单进程的celery每分钟可处理上百万个任务。&lt;br&gt;灵活： 几乎celery的各个组件都可以被扩展及自定制。
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="celery" scheme="https://rosinelan.github.io/tags/celery/"/>
    
  </entry>
  
  <entry>
    <title>python消息队列</title>
    <link href="https://rosinelan.github.io/2018/05/25/python%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>https://rosinelan.github.io/2018/05/25/python消息队列/</id>
    <published>2018-05-25T13:13:35.000Z</published>
    <updated>2018-05-25T14:19:07.884Z</updated>
    
    <content type="html"><![CDATA[<h3 id="消息队列简介"><a href="#消息队列简介" class="headerlink" title="消息队列简介"></a>消息队列简介</h3><p>消息队列”是在消息的传输过程中保存消息的容器。<br>消息队列最经典的用法就是消费者和生成者之间通过消息管道来传递消息，消费者和生成者是不通的进程。生产者往管道中写消息，消费者从管道中读消息。  </p><h3 id="消息队列在multiprocessing的实现"><a href="#消息队列在multiprocessing的实现" class="headerlink" title="消息队列在multiprocessing的实现"></a>消息队列在multiprocessing的实现</h3><p>操作系统提供了很多机制来实现进程间的通信 ，multiprocessing模块就提供了Queue和Pipe两种方法来实现。<br><a id="more"></a></p><h4 id="Queue实现"><a href="#Queue实现" class="headerlink" title="Queue实现"></a>Queue实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'Process to write: %s'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]:</span><br><span class="line">        print(<span class="string">'Put %s to queue...'</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'Process to read: %s'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        value = q.get(<span class="keyword">True</span>)</span><br><span class="line">        print(<span class="string">'Get %s from queue.'</span> % value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 父进程创建Queue，并传给各个子进程</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    <span class="comment"># 启动子进程pw，写入</span></span><br><span class="line">    pw.start()</span><br><span class="line">    <span class="comment"># 启动子进程pr，读取</span></span><br><span class="line">    pr.start()</span><br><span class="line">    <span class="comment"># 等待pw结束:</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line">    r.terminate()</span><br></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Process to write: <span class="number">32532</span></span><br><span class="line">Process to read: <span class="number">28588</span></span><br><span class="line">Put A to queue...</span><br><span class="line">Get A <span class="keyword">from</span> queue.</span><br><span class="line">Put B to queue...</span><br><span class="line">Get B <span class="keyword">from</span> queue.</span><br><span class="line">Put C to queue...</span><br><span class="line">Get C <span class="keyword">from</span> queue.</span><br></pre></td></tr></table></figure></p><h4 id="Pipe实现"><a href="#Pipe实现" class="headerlink" title="Pipe实现"></a>Pipe实现</h4><p>Pipe方法返回(conn1, conn2)代表一个管道的两个端。<br>Pipe方法有duplex参数，如果duplex参数为True(默认值)，那么这个管道是全双工模式，也就是说conn1和conn2均可收发。duplex为False，conn1只负责接受消息，conn2只负责发送消息。<br>send和recv方法分别是发送和接受消息的方法。close方法表示关闭管道，当消息接受结束以后，关闭管道。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc1</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">"send: %s"</span> %(i))</span><br><span class="line">        pipe.send(i)</span><br><span class="line">        <span class="comment"># print(dir(pipe))</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc2</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    n = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        print(<span class="string">"proc2 rev:"</span>, pipe.recv())</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pipe = multiprocessing.Pipe(duplex=<span class="keyword">False</span>)</span><br><span class="line">    p1 = multiprocessing.Process(target=proc1, args=(pipe[<span class="number">1</span>],))</span><br><span class="line">    p2 = multiprocessing.Process(target=proc2, args=(pipe[<span class="number">0</span>],))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    pipe[<span class="number">0</span>].close()</span><br><span class="line">    pipe[<span class="number">1</span>].close()</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">send: <span class="number">0</span></span><br><span class="line">proc2 rev: <span class="number">0</span></span><br><span class="line">send: <span class="number">1</span></span><br><span class="line">proc2 rev: <span class="number">1</span></span><br><span class="line">send: <span class="number">2</span></span><br><span class="line">proc2 rev: <span class="number">2</span></span><br><span class="line">send: <span class="number">3</span></span><br><span class="line">proc2 rev: <span class="number">3</span></span><br><span class="line">send: <span class="number">4</span></span><br><span class="line">proc2 rev: <span class="number">4</span></span><br></pre></td></tr></table></figure></p><h3 id="queue模块实现消息队列"><a href="#queue模块实现消息队列" class="headerlink" title="queue模块实现消息队列"></a>queue模块实现消息队列</h3><p>在python中还可以直接使用queue模块专门实现消息队列。<br>queue对象实现一个fifo队列（其他的还有lifo、priority队列，这里不再介绍）。queue只有maxsize一个构造参数，用来指定队列容量，指定为0的时候代表容量无限。主要有以下成员函数  </p><ul><li>queue.qsize()<br>返回消息队列的当前空间。返回的值不一定可靠。  </li><li>queue.empty()<br>判断消息队列是否为空，返回True或False。同样不可靠。  </li><li>queue.full()<br>类似上边，判断消息队列是否满。  </li><li>queue.put(item, block=True, timeout=None)<br>往消息队列中存放消息。block可以控制是否阻塞，timeout指定阻塞时候的等待时间。如果不阻塞或者超时，会引起一个full exception。  </li><li>queue.put_nowait(item)<br>相当于put(item, False)。  </li><li>queue.get(block=True, timeout=None)<br>获取一个消息，其他同put。<br>以下两个函数用来判断消息对应的任务是否完成。  </li><li>queue.task_done()<br>接受消息的线程通过调用这个函数来说明消息对应的任务已完成。  </li><li>queue.join()<br>实际上意味着等到队列为空，再执行别的操作。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># Producer thread</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, t_name, queue)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self, name=t_name)</span><br><span class="line">        self.data = queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):  <span class="comment"># 随机产生10个数字 ，可以修改为任意大小</span></span><br><span class="line">            print(<span class="string">"%s: %s is producing %d to the queue!"</span> % (time.ctime(), self.getName(), i))</span><br><span class="line">            self.data.put(i)  <span class="comment"># 将数据依次存入队列</span></span><br><span class="line">        print(<span class="string">"%s: %s finished!"</span> % (time.ctime(), self.getName()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Consumer thread</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer_even</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, t_name, queue)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self, name=t_name)</span><br><span class="line">        self.data = queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                val_even = self.data.get(<span class="number">1</span>, <span class="number">5</span>)  <span class="comment"># get(self, block=True, timeout=None) ,1就是阻塞等待,5是超时5秒</span></span><br><span class="line">                <span class="keyword">if</span> val_even % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    print(<span class="string">"%s: %s is consuming. %d in the queue is consumed!"</span> % (time.ctime(), self.getName(), val_even))</span><br><span class="line">                    time.sleep(<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.data.put(val_even)</span><br><span class="line">                    time.sleep(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">except</span>:  <span class="comment"># 等待输入，超过5秒  就报异常</span></span><br><span class="line">                print(<span class="string">"%s: %s finished!"</span> % (time.ctime(), self.getName()))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer_odd</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, t_name, queue)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self, name=t_name)</span><br><span class="line">        self.data = queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                val_odd = self.data.get(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">                <span class="keyword">if</span> val_odd % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                    print(<span class="string">"%s: %s is consuming. %d in the queue is consumed!"</span> % (time.ctime(), self.getName(), val_odd))</span><br><span class="line">                    time.sleep(<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.data.put(val_odd)</span><br><span class="line">                    time.sleep(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                print(<span class="string">"%s: %s finished!"</span> % (time.ctime(), self.getName()))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Main thread</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    queue = Queue()</span><br><span class="line">    producer = Producer(<span class="string">'Pro.'</span>, queue)</span><br><span class="line">    consumer_even = Consumer_even(<span class="string">'Con_even.'</span>, queue)</span><br><span class="line">    consumer_odd = Consumer_odd(<span class="string">'Con_odd.'</span>, queue)</span><br><span class="line">    producer.start()</span><br><span class="line">    consumer_even.start()</span><br><span class="line">    consumer_odd.start()</span><br><span class="line">    producer.join()</span><br><span class="line">    consumer_even.join()</span><br><span class="line">    consumer_odd.join()</span><br><span class="line">    print(<span class="string">'All threads terminate!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Fri May <span class="number">25</span> <span class="number">22</span>:<span class="number">10</span>:<span class="number">01</span> <span class="number">2018</span>: Pro. <span class="keyword">is</span> producing <span class="number">0</span> to the queue!</span><br><span class="line">Fri May <span class="number">25</span> <span class="number">22</span>:<span class="number">10</span>:<span class="number">01</span> <span class="number">2018</span>: Pro. <span class="keyword">is</span> producing <span class="number">1</span> to the queue!</span><br><span class="line">Fri May <span class="number">25</span> <span class="number">22</span>:<span class="number">10</span>:<span class="number">01</span> <span class="number">2018</span>: Pro. <span class="keyword">is</span> producing <span class="number">2</span> to the queue!</span><br><span class="line">Fri May <span class="number">25</span> <span class="number">22</span>:<span class="number">10</span>:<span class="number">01</span> <span class="number">2018</span>: Pro. <span class="keyword">is</span> producing <span class="number">3</span> to the queue!</span><br><span class="line">Fri May <span class="number">25</span> <span class="number">22</span>:<span class="number">10</span>:<span class="number">01</span> <span class="number">2018</span>: Pro. <span class="keyword">is</span> producing <span class="number">4</span> to the queue!</span><br><span class="line">Fri May <span class="number">25</span> <span class="number">22</span>:<span class="number">10</span>:<span class="number">01</span> <span class="number">2018</span>: Pro. finished!</span><br><span class="line">Fri May <span class="number">25</span> <span class="number">22</span>:<span class="number">10</span>:<span class="number">01</span> <span class="number">2018</span>: Con_even. <span class="keyword">is</span> consuming. <span class="number">0</span> <span class="keyword">in</span> the queue <span class="keyword">is</span> consumed!</span><br><span class="line">Fri May <span class="number">25</span> <span class="number">22</span>:<span class="number">10</span>:<span class="number">01</span> <span class="number">2018</span>: Con_odd. <span class="keyword">is</span> consuming. <span class="number">1</span> <span class="keyword">in</span> the queue <span class="keyword">is</span> consumed!</span><br><span class="line">Fri May <span class="number">25</span> <span class="number">22</span>:<span class="number">10</span>:<span class="number">05</span> <span class="number">2018</span>: Con_even. <span class="keyword">is</span> consuming. <span class="number">4</span> <span class="keyword">in</span> the queue <span class="keyword">is</span> consumed!</span><br><span class="line">Fri May <span class="number">25</span> <span class="number">22</span>:<span class="number">10</span>:<span class="number">13</span> <span class="number">2018</span>: Con_odd. <span class="keyword">is</span> consuming. <span class="number">3</span> <span class="keyword">in</span> the queue <span class="keyword">is</span> consumed!</span><br><span class="line">Fri May <span class="number">25</span> <span class="number">22</span>:<span class="number">10</span>:<span class="number">13</span> <span class="number">2018</span>: Con_even. <span class="keyword">is</span> consuming. <span class="number">2</span> <span class="keyword">in</span> the queue <span class="keyword">is</span> consumed!</span><br><span class="line">Fri May <span class="number">25</span> <span class="number">22</span>:<span class="number">10</span>:<span class="number">20</span> <span class="number">2018</span>: Con_even. finished!</span><br><span class="line">Fri May <span class="number">25</span> <span class="number">22</span>:<span class="number">10</span>:<span class="number">20</span> <span class="number">2018</span>: Con_odd. finished!</span><br><span class="line">All threads terminate!</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;消息队列简介&quot;&gt;&lt;a href=&quot;#消息队列简介&quot; class=&quot;headerlink&quot; title=&quot;消息队列简介&quot;&gt;&lt;/a&gt;消息队列简介&lt;/h3&gt;&lt;p&gt;消息队列”是在消息的传输过程中保存消息的容器。&lt;br&gt;消息队列最经典的用法就是消费者和生成者之间通过消息管道来传递消息，消费者和生成者是不通的进程。生产者往管道中写消息，消费者从管道中读消息。  &lt;/p&gt;
&lt;h3 id=&quot;消息队列在multiprocessing的实现&quot;&gt;&lt;a href=&quot;#消息队列在multiprocessing的实现&quot; class=&quot;headerlink&quot; title=&quot;消息队列在multiprocessing的实现&quot;&gt;&lt;/a&gt;消息队列在multiprocessing的实现&lt;/h3&gt;&lt;p&gt;操作系统提供了很多机制来实现进程间的通信 ，multiprocessing模块就提供了Queue和Pipe两种方法来实现。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="queue" scheme="https://rosinelan.github.io/tags/queue/"/>
    
      <category term="pipe" scheme="https://rosinelan.github.io/tags/pipe/"/>
    
      <category term="消息队列" scheme="https://rosinelan.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>python多线程</title>
    <link href="https://rosinelan.github.io/2018/05/23/python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://rosinelan.github.io/2018/05/23/python多线程/</id>
    <published>2018-05-23T13:25:22.000Z</published>
    <updated>2018-05-23T16:31:41.782Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>任务可以由多进程完成，也可以由一个进程内的多线程完成。<br>我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。<br>由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。Python的标准库提供了threading模块。<br><a id="more"></a></p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>在python中多线程的实现方法有2种。  </p><ol><li>将要执行的方法作为参数传递给Thread的构造方法。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(args)</span>:</span></span><br><span class="line">    print(<span class="string">"开始子进程 &#123;0&#125;"</span>.format(args))</span><br><span class="line">    print(<span class="string">"结束子进程 &#123;0&#125;"</span>.format(args))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"start main"</span>)</span><br><span class="line">    t1 = threading.Thread(target=worker, args=(<span class="number">1</span>,))</span><br><span class="line">    t2 = threading.Thread(target=worker, args=(<span class="number">2</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    print(<span class="string">"end main"</span>)</span><br></pre></td></tr></table></figure></li></ol><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start main</span><br><span class="line">开始子进程 <span class="number">1</span></span><br><span class="line">结束子进程 <span class="number">1</span></span><br><span class="line">开始子进程 <span class="number">2</span></span><br><span class="line">结束子进程 <span class="number">2</span></span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><ol><li>从Thread继承，并重写run()方法。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, args)</span>:</span></span><br><span class="line">        super(Hello, self).__init__()    <span class="comment">#注意：要显式的调用父类的初始化函数</span></span><br><span class="line">        self.args = args</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"开始子进程 &#123;0&#125;"</span>.format(self.args))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">"结束子进程 &#123;0&#125;"</span>.format(self.args))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    print(<span class="string">"start main"</span>)</span><br><span class="line">    t1 = Hello(<span class="number">1</span>)</span><br><span class="line">    t2 = Hello(<span class="number">2</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    print(<span class="string">"end main"</span>)</span><br></pre></td></tr></table></figure></li></ol><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start main</span><br><span class="line">开始子进程 <span class="number">1</span></span><br><span class="line">开始子进程 <span class="number">2</span></span><br><span class="line">end main</span><br><span class="line">结束子进程 <span class="number">1</span></span><br><span class="line">结束子进程 <span class="number">2</span></span><br></pre></td></tr></table></figure></p><h4 id="模块函数"><a href="#模块函数" class="headerlink" title="模块函数"></a>模块函数</h4><ul><li>threading.active_count()<br>返回当前存活的thread对象的数量。返回的数量和<code>enumerate()</code>列表长度相等。  </li><li>threading.current_thread()<br>返回当前线程对象。  </li><li>threading.get_ident()<br>返回当前线程的<code>thread identifier</code>。这是个非零的整数。该值无特殊含义。  </li><li>threading.enumerate()<br>以列表形式返回当前存活的所有线程对象。列表中包括守护线程和由<code>current_thread()</code>创建的虚拟线程对象，不包括已结束和还没开始的线程。  </li><li>threading.main_thread()<br>返回主线程对象。正常情况下，主线程由python解释器启动。<h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4></li><li>start()<br>启动线程，调用run方法。同一线程对象多次调用将会出现<code>RuntimeError</code>错误。</li><li>run()<br>启动线程</li><li>join(timeout=None)<br>等待线程对象结束。</li><li>is_alive()<br>线程是否活着<h4 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h4></li><li>name<br>线程的名称，无特殊意义。</li><li>daemon<br>布尔值，表示该线程是否为守护线程。设置该值必须在调用run()方法前，否则会报<code>RuntimeError</code>错误。假如主线程不是守护线程，该主线程创建的所有子线程该值为False。<h3 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h3>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。<br>这种情况下通过线程锁保证修改不会发生冲突。<br>锁的创建通过<code>threading.Lock()</code>进行，操作类似于多进程。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(name, lock)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        print(<span class="string">"start &#123;0&#125;"</span>.format(name))</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        print(<span class="string">"end &#123;0&#125;"</span>.format(name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    t1 = threading.Thread(target=worker, args=(<span class="string">"worker1"</span>, lock))</span><br><span class="line">    t2 = threading.Thread(target=worker, args=(<span class="string">"worker2"</span>, lock))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure></li></ul><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start worker1</span><br><span class="line">end worker1</span><br><span class="line">start worker2</span><br><span class="line">end worker2</span><br></pre></td></tr></table></figure></p><p>当然，获取锁也可以通过<code>lock.acquire()</code>完成，释放锁通过<code>lock.release()</code>完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(name, lock)</span>:</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">"start &#123;0&#125;"</span>.format(name))</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        print(<span class="string">"end &#123;0&#125;"</span>.format(name))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        lock.release()</span><br></pre></td></tr></table></figure></p><ul><li>锁的好处<br>确保了某段关键代码只能由一个线程从头到尾完整地执行。  </li><li>坏处<br>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。<br>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。<h3 id="线程共享内存"><a href="#线程共享内存" class="headerlink" title="线程共享内存"></a>线程共享内存</h3>多线程和多进程不同之处在于多线程本身就是可以和父进程共享内存的，这也是为什么其中一个线程挂掉以后，为什么其他线程也会死掉的道理。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">l = list()</span><br><span class="line">l += range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    l.append(<span class="string">"GOD"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = threading.Thread(target=worker)</span><br><span class="line">    t2 = threading.Thread(target=worker)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    print(l)</span><br></pre></td></tr></table></figure></li></ul><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'GOD'</span>, <span class="string">'GOD'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>在使用多线程处理任务时也不是线程越多越好，由于在切换线程的时候，需要切换上下文环境，依然会造成cpu的大量开销。为解决这个问题，线程池的概念被提出来了。预先创建好一个较为优化的数量的线程，让过来的任务立刻能够使用，就形成了线程池。<br>此处介绍<code>threapool</code>是一个第三方模块，需要使用<code>pip install threadpool</code>安装。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threadpool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(m, n, o)</span>:</span></span><br><span class="line">    print(<span class="string">"m = &#123;0&#125;  n=&#123;1&#125;  o=&#123;2&#125;"</span>.format(m, n, o))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lst_vars_1 = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line">    lst_vars_2 = [<span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>]</span><br><span class="line">    func_var = [(lst_vars_1, <span class="keyword">None</span>), (lst_vars_2, <span class="keyword">None</span>)]</span><br><span class="line"></span><br><span class="line">    pool = threadpool.ThreadPool(<span class="number">2</span>)</span><br><span class="line">    requests = threadpool.makeRequests(hello, func_var)</span><br><span class="line">    [pool.putRequest(req) <span class="keyword">for</span> req <span class="keyword">in</span> requests]</span><br><span class="line">    pool.wait()</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="number">1</span>  n=<span class="number">2</span>  o=<span class="number">3</span></span><br><span class="line">m = <span class="number">4</span>  n=<span class="number">5</span>  o=<span class="number">6</span></span><br></pre></td></tr></table></figure></p><ul><li>Executor<br>在python3.3之后，并行任务可以使用<code>Executor Objects</code>，更多内容点击<a href="https://docs.python.org/3/library/concurrent.futures.html" target="_blank" rel="noopener">concurrent.futures — Launching parallel tasks</a>查看官方介绍。  </li><li>关于python中多核CPU的说明<br>Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。<br>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。<br>所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。<br>Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。<br>更多关于<code>threading</code>的内容可以点击<a href="https://docs.python.org/3/library/threading.html" target="_blank" rel="noopener">threading — Thread-based parallelism</a>查看官方介绍。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h3&gt;&lt;p&gt;任务可以由多进程完成，也可以由一个进程内的多线程完成。&lt;br&gt;我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。&lt;br&gt;由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。Python的标准库提供了threading模块。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="threading" scheme="https://rosinelan.github.io/tags/threading/"/>
    
      <category term="Lock" scheme="https://rosinelan.github.io/tags/Lock/"/>
    
      <category term="threadpool" scheme="https://rosinelan.github.io/tags/threadpool/"/>
    
  </entry>
  
  <entry>
    <title>python多进程</title>
    <link href="https://rosinelan.github.io/2018/05/20/python%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>https://rosinelan.github.io/2018/05/20/python多进程/</id>
    <published>2018-05-20T12:47:38.000Z</published>
    <updated>2018-05-23T14:44:02.246Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程简介"><a href="#进程简介" class="headerlink" title="进程简介"></a>进程简介</h3><p>进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的(静态的)，进程是活的(动态的)。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身；用户进程就不必我多讲了吧，所有由你启动的进程都是用户进程。进程是操作系统进行资源分配的单位。<br>在操作系统的管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，这样用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。但实际上在任何一个时间内有且仅有一个进程占有CPU。<br><a id="more"></a></p><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>进程(process)和线程(thread)<br>单个CPU一次只能运行一个任务；在任一时刻，CPU总是运行一个进程，其他进程处于非运行状态；<br>一个进程可以包含多个线程；<br>进程没有任何共享状态，进程修改的数据，改动仅限于该进程内；<br>一个进程的内存空间是共享的，每个线程都可以使用这些共享内存；<br>一个线程使用某些共享内存时，其他线程必须等它结束才能使用这一块内存；防止多个线程同时读写某一块内存区域，采用互斥锁(Mutual exclusion，缩写Mutex)；<br>某些内存区域只能供给固定数目的线程使用，此时通过信号量(Semaphore)保证多个线程不会互相冲突；<br>多进程形式，运行多个任务同时运行；多线程形式，允许单个任务分成不同的部分运行；<br>多线程使用的是cpu的一个核，适合io密集型；<br>多进程使用的是cpu的多个核，适合运算密集型。<br>在linux中可以使用ps -efL查看进程和线程ID。以memcached进程为例，输出结果如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_4_centos ~]<span class="comment"># ps -efL |grep memcached</span></span><br><span class="line">root     24421     1 24421  0   10 May19 ?        00:00:03 memcached -d -u root</span><br><span class="line">root     24421     1 24422  0   10 May19 ?        00:00:01 memcached -d -u root</span><br><span class="line">root     24421     1 24423  0   10 May19 ?        00:00:00 memcached -d -u root</span><br><span class="line">root     24421     1 24424  0   10 May19 ?        00:00:00 memcached -d -u root</span><br><span class="line">root     24421     1 24425  0   10 May19 ?        00:00:00 memcached -d -u root</span><br><span class="line">root     24421     1 24426  0   10 May19 ?        00:00:00 memcached -d -u root</span><br><span class="line">root     24421     1 24427  0   10 May19 ?        00:00:00 memcached -d -u root</span><br><span class="line">root     24421     1 24428  0   10 May19 ?        00:00:00 memcached -d -u root</span><br><span class="line">root     24421     1 24429  0   10 May19 ?        00:00:09 memcached -d -u root</span><br><span class="line">root     24421     1 24430  0   10 May19 ?        00:00:00 memcached -d -u root</span><br><span class="line">root     32169 31101 32169  0    1 23:23 pts/0    00:00:00 grep --color=auto memcached</span><br></pre></td></tr></table></figure></p><p>第一行<code>UID</code>(用户ID)，第二行为<code>PID</code>(进程ID)，第三行<code>PPID</code>(父进程ID)，第四行<code>LWP</code>(线程ID)。<br>从示例可以看出，进程24421子进程有10个，对应线程ID分别为24421-24430。  </p><h3 id="multiprocess"><a href="#multiprocess" class="headerlink" title="multiprocess"></a>multiprocess</h3><p>python中的多线程无法利用多核优势，若要充分使用多核CPU资源，在python中大部分情况使用多进程。python提供了非常好用的多进程包multiprocessing。<br>multiprocessing模块用来开启子进程，并在子进程中执行我们定制的任务（比如函数），该模块与多线程模块threading的编程接口类似。<br>multiprocessing模块的功能众多：支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。  </p><h4 id="Process类"><a href="#Process类" class="headerlink" title="Process类"></a>Process类</h4><p>创建一个Process对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = multiprocessing.Process(target=worker_1, args=(<span class="number">2</span>, ))</span><br></pre></td></tr></table></figure></p><ul><li><p>参数<br>target：函数名字<br>args：函数需要的参数，以tuple的形式传入(单个元素的tuple必须有逗号)</p></li><li><p>方法<br>p.is_alive()     判断进程p是否存活，是返回True<br>p.run()          启动进程，它去调用target指定的函数<br>p.start()        启动进程，它会自动调用run方法，推荐使用start<br>p.join(timeout)  主线程等待p终止(主线程处于等的状态，p处于运行状态)。p.join只能join使用start开启的进程，不能join使用run开启的进程<br>p.terminate()    强制进程p退出，不会进行任何清理操作，如果p创建了子进程，该子进程就变成了僵尸进程  </p></li><li>属性<br>p.name           进程的名字<br>p.pid            进程的pid<br>p.daemon         默认为False，如果设置为True代表p为后台运行的守护进程，当p的父进程终止时p也随之终止，并且设置为True后，p不能创建自己的新进程，必须在p.start()之前设置  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(args, interval)</span>:</span></span><br><span class="line">    print(<span class="string">"start worker &#123;0&#125;"</span>.format(args))</span><br><span class="line">    time.sleep(interval)</span><br><span class="line">    print(<span class="string">"end worker &#123;0&#125;"</span>.format(args))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start main"</span>)</span><br><span class="line">    p1 = multiprocessing.Process(target=worker, args=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    p2 = multiprocessing.Process(target=worker, args=(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">    p3 = multiprocessing.Process(target=worker, args=(<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    print(<span class="string">"end main"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start main</span><br><span class="line">end main</span><br><span class="line">start worker <span class="number">1</span></span><br><span class="line">start worker <span class="number">2</span></span><br><span class="line">start worker <span class="number">3</span></span><br><span class="line">end worker <span class="number">1</span></span><br><span class="line">end worker <span class="number">2</span></span><br><span class="line">end worker <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>multprocessing用到的两个方法<br>cpu_count()：统计cpu总数<br>active_children()：获得所有子进程<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(args, interval)</span>:</span></span><br><span class="line">    print(<span class="string">"start worker &#123;0&#125;"</span>.format(args))</span><br><span class="line">    time.sleep(interval)</span><br><span class="line">    print(<span class="string">"end worker &#123;0&#125;"</span>.format(args))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start main"</span>)</span><br><span class="line">    p1 = multiprocessing.Process(target=worker, args=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    p2 = multiprocessing.Process(target=worker, args=(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">    p3 = multiprocessing.Process(target=worker, args=(<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">    p1.start()</span><br><span class="line">    p1.join(timeout=<span class="number">0.5</span>)    <span class="comment">#此处保证了p1优先执行</span></span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    print(<span class="string">"the number of CPU is: &#123;0&#125;"</span>.format(multiprocessing.cpu_count()))</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> multiprocessing.active_children():</span><br><span class="line">       print(<span class="string">"The name of active children is: &#123;0&#125;, pid is: &#123;1&#125; is alive"</span>.format(p.name, p.pid))</span><br><span class="line">    print(<span class="string">"end main"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">start main</span><br><span class="line">start worker <span class="number">1</span></span><br><span class="line">the number of CPU <span class="keyword">is</span>: <span class="number">4</span></span><br><span class="line">The name of active children <span class="keyword">is</span>: Process<span class="number">-1</span>, pid <span class="keyword">is</span>: <span class="number">25360</span> <span class="keyword">is</span> alive</span><br><span class="line">The name of active children <span class="keyword">is</span>: Process<span class="number">-2</span>, pid <span class="keyword">is</span>: <span class="number">24500</span> <span class="keyword">is</span> alive</span><br><span class="line">The name of active children <span class="keyword">is</span>: Process<span class="number">-3</span>, pid <span class="keyword">is</span>: <span class="number">26100</span> <span class="keyword">is</span> alive</span><br><span class="line">end main</span><br><span class="line">start worker <span class="number">3</span></span><br><span class="line">start worker <span class="number">2</span></span><br><span class="line">end worker <span class="number">1</span></span><br><span class="line">end worker <span class="number">2</span></span><br><span class="line">end worker <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h4 id="lock组件"><a href="#lock组件" class="headerlink" title="lock组件"></a>lock组件</h4><p>当我们用多进程来读写文件的时候，如果一个进程是写文件，一个进程是读文件，如果两个文件同时进行，肯定是不行的，必须是文件写结束以后，才可以进行读操作。或者是多个进程在共享一些资源的时候，同时只能有一个进程进行访问，那就要有一个锁机制进行控制。<br>下面使用2个进程分别进行<code>+1</code>和<code>+3</code>操作为例 </p><ul><li>不加锁  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(value, number)</span>:</span></span><br><span class="line">    print(<span class="string">"start add&#123;0&#125; number= &#123;1&#125;"</span>.format(value, number))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">        number += value</span><br><span class="line">        time.sleep(<span class="number">0.3</span>)</span><br><span class="line">        print(<span class="string">"number = &#123;0&#125;"</span>.format(number))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"start main"</span>)</span><br><span class="line">    number = <span class="number">0</span></span><br><span class="line">    p1 = multiprocessing.Process(target=add, args=(<span class="number">1</span>, number))</span><br><span class="line">    p3 = multiprocessing.Process(target=add, args=(<span class="number">3</span>, number))</span><br><span class="line">    p1.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    print(<span class="string">"end main"</span>)</span><br></pre></td></tr></table></figure></li></ul><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start main</span><br><span class="line">end main</span><br><span class="line">start add1 number= <span class="number">0</span></span><br><span class="line">start add3 number= <span class="number">0</span></span><br><span class="line">number = <span class="number">1</span></span><br><span class="line">number = <span class="number">3</span></span><br><span class="line">number = <span class="number">2</span></span><br><span class="line">number = <span class="number">6</span></span><br></pre></td></tr></table></figure></p><ul><li>加锁  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(lock, value, number)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        print(<span class="string">"start add&#123;0&#125; number= &#123;1&#125;"</span>.format(value, number))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">            number += value</span><br><span class="line">            time.sleep(<span class="number">0.3</span>)</span><br><span class="line">            print(<span class="string">"number = &#123;0&#125;"</span>.format(number))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"start main"</span>)</span><br><span class="line">    number = <span class="number">0</span></span><br><span class="line">    lock = multiprocessing.Lock()</span><br><span class="line">    p1 = multiprocessing.Process(target=add, args=(lock, <span class="number">1</span>, number))</span><br><span class="line">    p3 = multiprocessing.Process(target=add, args=(lock, <span class="number">3</span>, number))</span><br><span class="line">    p1.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    print(<span class="string">"end main"</span>)</span><br></pre></td></tr></table></figure></li></ul><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start main</span><br><span class="line">end main</span><br><span class="line">start add1 number= <span class="number">0</span></span><br><span class="line">number = <span class="number">1</span></span><br><span class="line">number = <span class="number">2</span></span><br><span class="line">start add3 number= <span class="number">0</span></span><br><span class="line">number = <span class="number">3</span></span><br><span class="line">number = <span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>锁的获取可以使用<code>lock.acquire()</code>获取，<code>lock.release()</code>释放<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(lock, value, number)</span>:</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    print(<span class="string">"start add3 number= &#123;0&#125;"</span>.format(number))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">            number += value</span><br><span class="line">            time.sleep(<span class="number">0.3</span>)</span><br><span class="line">            print(<span class="string">"number = &#123;0&#125;"</span>.format(number))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> e</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        lock.release()</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>一般变量在进程之间是没法进行通讯的，但是multiprocessing提供了<code>Value</code>和<code>Array</code>模块，可以在不同的进程中使用同一变量。<code>Value</code>和<code>Array</code>结构内部都实现了锁机制，因此多进程是安全的。<br>Value和Array都需要设置其中存放值的类型，d是double类型，i是int类型。类型设置和<code>array</code>模块的值类似，更多的类型可以点击<a href="https://docs.python.org/3/library/array.html#module-array" target="_blank" rel="noopener">array — Efficient arrays of numeric values</a>查看。<br>上面的示例中，两个进程执行后number结果分别为2和6，假如两个进程可以共享变量，name输出结果将会是8。  </p><ul><li>Value<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(value, number)</span>:</span></span><br><span class="line">    print(<span class="string">"start add&#123;0&#125; number= &#123;1&#125;"</span>.format(value, number.value))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">        number.value += value</span><br><span class="line">        print(<span class="string">"number = &#123;0&#125;"</span>.format(number.value))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"start main"</span>)</span><br><span class="line">    number = Value(<span class="string">'d'</span>, <span class="number">0</span>)    <span class="comment">#使用Value创建变量,d表示数据类型为double</span></span><br><span class="line">    p1 = multiprocessing.Process(target=add, args=(<span class="number">1</span>, number))</span><br><span class="line">    p3 = multiprocessing.Process(target=add, args=(<span class="number">3</span>, number))</span><br><span class="line">    p1.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    print(<span class="string">"end main"</span>)</span><br></pre></td></tr></table></figure></li></ul><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start main</span><br><span class="line">end main</span><br><span class="line">start add1 number= <span class="number">0.0</span></span><br><span class="line">start add3 number= <span class="number">0.0</span></span><br><span class="line">number = <span class="number">1.0</span></span><br><span class="line">number = <span class="number">4.0</span></span><br><span class="line">number = <span class="number">5.0</span></span><br><span class="line">number = <span class="number">8.0</span></span><br></pre></td></tr></table></figure></p><p>number最终结果是8，但是具体输出结果每次执行可能存在差异。</p><ul><li>Array<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Array, Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        arr[i] = -arr[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = Array(<span class="string">'i'</span>, [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">6</span>)])    <span class="comment">#定义Array类型变量,i表示数据类型为int</span></span><br><span class="line">    print(arr[:])</span><br><span class="line">    p = Process(target=worker, args=(arr,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()    <span class="comment">#等待子进程执行完成</span></span><br><span class="line">    print(arr[:])</span><br></pre></td></tr></table></figure></li></ul><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">-5</span>]</span><br></pre></td></tr></table></figure></p><h4 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h4><p>共享内存的实现，除了使用<code>Value</code>和<code>Array</code>，还可以使用<code>Manager</code>实现。<br>Manager()返回的manager对象通过一个服务进程，让其他进程通过代理的方式从挨揍python对象。manager对象支持<code>list</code>, <code>dict</code>, <code>Namespace</code>, <code>Lock</code>, <code>RLock</code>, <code>Semaphore</code>, <code>BoundedSemaphore</code>, <code>Condition</code>, <code>Event</code>, <code>Barrier</code>, <code>Queue</code>, <code>Value</code> and <code>Array</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager, Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(d, l)</span>:</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="string">'1'</span></span><br><span class="line">    d[<span class="number">2</span>] = <span class="string">'2'</span></span><br><span class="line">    d[<span class="number">0.25</span>] = <span class="keyword">None</span></span><br><span class="line">    l.reverse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager = Manager()</span><br><span class="line">    d = manager.dict()</span><br><span class="line">    l = manager.list(range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    p = Process(target=f, args=(d, l))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    print(d)</span><br><span class="line">    print(l)</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>: <span class="string">'1'</span>, <span class="number">2</span>: <span class="string">'2'</span>, <span class="number">0.25</span>: <span class="keyword">None</span>&#125;</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure></p><h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p>Pool可以提供指定数量的进程，供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程。<br>进程池提供阻塞和非阻塞两种方法<br><code>Pool.apply_async</code> 非阻塞，定义的进程池进程最大数可以同时执行<br><code>Pool.apply</code> 一个进程结束，释放回进程池，下一个进程才可以开始  </p><ul><li>使用<code>Pool.apply</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">"_start &#123;0&#125;"</span>.format(msg))</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"_end &#123;0&#125;"</span>.format(msg))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"start main"</span>)</span><br><span class="line">    pool = multiprocessing.Pool(processes=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">        msg = <span class="string">"hello &#123;0&#125;"</span>.format(i)</span><br><span class="line">        pool.apply(fun, (msg,))</span><br><span class="line">    pool.close()<span class="comment">#在调用join之前，要先调用close，否则会报错，close执行完不会有新的进程加入到pool</span></span><br><span class="line">    pool.join()<span class="comment">#join 是等待所有的子进程结束</span></span><br><span class="line">    print(<span class="string">"end main"</span>)</span><br></pre></td></tr></table></figure></li></ul><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start main</span><br><span class="line">_start hello <span class="number">1</span></span><br><span class="line">_end hello <span class="number">1</span></span><br><span class="line">_start hello <span class="number">2</span></span><br><span class="line">_end hello <span class="number">2</span></span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p>输出结果为按顺序，一个进程结束再进行下一个</p><ul><li>使用<code>Pool.apply_async</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">"_start &#123;0&#125;"</span>.format(msg))</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"_end &#123;0&#125;"</span>.format(msg))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"start main"</span>)</span><br><span class="line">    pool = multiprocessing.Pool(processes=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">        msg = <span class="string">"hello &#123;0&#125;"</span>.format(i)</span><br><span class="line">        pool.apply_async(fun, (msg,))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    print(<span class="string">"end main"</span>)</span><br></pre></td></tr></table></figure></li></ul><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start main</span><br><span class="line">_start hello <span class="number">1</span></span><br><span class="line">_start hello <span class="number">2</span></span><br><span class="line">_end hello <span class="number">1</span></span><br><span class="line">_end hello <span class="number">2</span></span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p>此时两个进程可以同时执行。<br>更多关于<code>multiprocessing</code>的内容可以点击<a href="https://docs.python.org/3/library/multiprocessing.html" target="_blank" rel="noopener">multiprocessing — Process-based parallelism</a>查看官方介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;进程简介&quot;&gt;&lt;a href=&quot;#进程简介&quot; class=&quot;headerlink&quot; title=&quot;进程简介&quot;&gt;&lt;/a&gt;进程简介&lt;/h3&gt;&lt;p&gt;进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的(静态的)，进程是活的(动态的)。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身；用户进程就不必我多讲了吧，所有由你启动的进程都是用户进程。进程是操作系统进行资源分配的单位。&lt;br&gt;在操作系统的管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，这样用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。但实际上在任何一个时间内有且仅有一个进程占有CPU。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="Lock" scheme="https://rosinelan.github.io/tags/Lock/"/>
    
      <category term="多进程" scheme="https://rosinelan.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="Process" scheme="https://rosinelan.github.io/tags/Process/"/>
    
      <category term="Value" scheme="https://rosinelan.github.io/tags/Value/"/>
    
      <category term="Array" scheme="https://rosinelan.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>python访问memcached</title>
    <link href="https://rosinelan.github.io/2018/05/18/python%E8%AE%BF%E9%97%AEmemcached/"/>
    <id>https://rosinelan.github.io/2018/05/18/python访问memcached/</id>
    <published>2018-05-18T06:15:25.000Z</published>
    <updated>2018-05-19T01:13:21.826Z</updated>
    
    <content type="html"><![CDATA[<h3 id="memcached介绍"><a href="#memcached介绍" class="headerlink" title="memcached介绍"></a>memcached介绍</h3><p>Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。Memcached基于一个存储键/值对的hashmap。其守护进程（daemon ）是用C写的，但是客户端可以用任何语言来编写，并通过memcached协议与守护进程通信。<br>memcached在实现分布式群集部署时，memcached服务之间是不能进行通讯的，分布式也是通过客户端的算法把数据保存在不同的memcached中。magent是一款开源的代理服务软件，我们可以通过它来实现缓存数据的同步。magent还可以使用keepalived来实现高可用。<br><a id="more"></a></p><h3 id="memcached安装"><a href="#memcached安装" class="headerlink" title="memcached安装"></a>memcached安装</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在linux下安装</p><ul><li><p>安装libevent<br>Libevent 是一个异步事件处理软件函式库，以 BSD 许可证释出。Memcached 依赖 Libevent，因此必须先安装 Libevent。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libevent-devel</span><br></pre></td></tr></table></figure></li><li><p>安装memcached</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">wget http://memcached.org/latest</span><br><span class="line">tar zxf memcached-1.5.7.tar.gz</span><br><span class="line">mv memcached-1.5.7 memcached</span><br><span class="line"><span class="built_in">cd</span> memcached/</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li></ul><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcached -d -u root</span><br></pre></td></tr></table></figure><p><strong>启动参数说明</strong><br><code>memcached -d -m 10 -u root -l 127.0.0.1 -p 12000 -c 256 -P /tmp/memcache/logs/memcache.pid</code><br>-p 指定端口号（默认11211）<br>-m 指定最大使用内存大小（默认64MB）<br>-t 线程数（默认4）<br>-l 连接的IP地址, 默认是本机<br>-d 以后台守护进程的方式启动<br>-c 最大同时连接数，默认是1024<br>-P 制定memecache的pid文件<br>-h  打印帮助信息<br><strong>启动确认</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_4_centos memcached]<span class="comment"># ps aux|grep memcache</span></span><br><span class="line">root     24421  0.0  0.0 413792  1080 ?        Ssl  07:45   0:00 memcached -d -u root</span><br><span class="line">root     24436  0.0  0.0 112644   964 pts/0    R+   07:45   0:00 grep --color=auto memcache</span><br><span class="line">[root@VM_0_4_centos memcached]<span class="comment"># netstat -lntp|grep memcached</span></span><br><span class="line">tcp        0      0 0.0.0.0:11211           0.0.0.0:*               LISTEN      24421/memcached     </span><br><span class="line">tcp6       0      0 :::11211                :::*                    LISTEN      24421/memcached</span><br></pre></td></tr></table></figure></p><h3 id="python访问memcached"><a href="#python访问memcached" class="headerlink" title="python访问memcached"></a>python访问memcached</h3><p>python访问memcached需要安装python-memcached模块。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-memcached</span><br></pre></td></tr></table></figure></p><p>操作实例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"></span><br><span class="line">mem = memcache.Client([<span class="string">"118.24.18.158:11211"</span>])</span><br><span class="line">mem.set(<span class="string">"db"</span>, <span class="string">"oracle"</span>)</span><br><span class="line">print(mem.get(<span class="string">"db"</span>))    <span class="comment">#输出结果：oracle</span></span><br></pre></td></tr></table></figure></p><p>另外，python-memcached模块原生支持集群操作，其原理是在内存中维护一个主机列表，且集群中主机的权重值和主机在列表中重复出现的次数成正比。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主机IP        权重</span><br><span class="line"><span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span>        <span class="number">1</span></span><br><span class="line"><span class="number">1.1</span><span class="number">.1</span><span class="number">.2</span>        <span class="number">2</span></span><br><span class="line"><span class="number">1.1</span><span class="number">.1</span><span class="number">.3</span>        <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>那么内存中主机列表为：host_list = [“1.1.1.1”, “1.1.1.2”,”1.1.1.2”,”1.1.1.3”,]<br>用户如果要在内存中创建一个键值对（如：k1 = “value1”），那么要执行以下步骤：<br>根据算法将k1转换成一个数字<br>将数字和主机列表长度求余数，得到一个值N（0 &lt;= N &lt; 长度）<br>在主机列表中根据第二步得到的值为索引获取主机，例如: host_list[N]<br>连接将第三步中获取的主机，将k1 = “value1” 放置在该服务器的内存中<br>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line">mc = memcache.Client([(<span class="string">'1.1.1.1:11211'</span>, <span class="number">1</span>), (<span class="string">'1.1.1.2:11211'</span>, <span class="number">2</span>),(<span class="string">'1.1.1.3:11211'</span>,<span class="number">1</span>)])</span><br><span class="line">mc.set(<span class="string">'k1'</span>,<span class="string">'value1'</span>)</span><br><span class="line">ret = mc.get(<span class="string">'k1'</span>)</span><br><span class="line"><span class="keyword">print</span> (ret)</span><br></pre></td></tr></table></figure></p><h3 id="memcached常用操作"><a href="#memcached常用操作" class="headerlink" title="memcached常用操作"></a>memcached常用操作</h3><ul><li>set(key, val)<br>在memcache中设置key的值为val。若key不存在则创建，否则修改。</li><li>get(key)<br>获取memcache中key对应的值或者<code>None</code>。</li><li>set_multi(mapping)<br>一次设置多个key/value对。以列表方式传入。若key不存在则创建，否则修改。</li><li><p>get_multi(keys)<br>一次获取多个keys</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem.set_multi(&#123;<span class="string">"db1"</span>: <span class="string">"oracle"</span>, <span class="string">"db2"</span>: <span class="string">"mysql"</span>&#125;)</span><br><span class="line">mem.set(<span class="string">"db3"</span>, <span class="string">"memcache"</span>)</span><br><span class="line">print(mem.get(<span class="string">"db1"</span>))    <span class="comment">#输出结果：oracle</span></span><br><span class="line">print(mem.get_multi([<span class="string">"db2"</span>, <span class="string">"db3"</span>]))    <span class="comment">#输出结果：&#123;'db2': 'mysql', 'db3': 'memcache'&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>add(key, val)<br>在memcache中添加新的键值对。若已存在则返回False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(mem.add(<span class="string">"db"</span>, <span class="string">"memcache"</span>))     <span class="comment">#输出结果：True</span></span><br><span class="line">print(mem.get(<span class="string">"db"</span>))     <span class="comment">#输出结果：memcache</span></span><br><span class="line">print(mem.add(<span class="string">"db"</span>, <span class="string">"memcache"</span>))     <span class="comment">#输出结果：False</span></span><br></pre></td></tr></table></figure></li><li><p>replace(key, val)<br>修改key的值为val，若不存在则返回False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem.add(<span class="string">"db"</span>, <span class="string">"memcache"</span>)</span><br><span class="line">print(mem.replace(<span class="string">"db"</span>, <span class="string">"redis"</span>))    <span class="comment">#输出结果：True</span></span><br><span class="line">print(mem.get(<span class="string">"db"</span>))    <span class="comment">#输出结果：redis</span></span><br><span class="line">print(mem.replace(<span class="string">"db1"</span>, <span class="string">"redis"</span>))    <span class="comment">#输出结果：False</span></span><br></pre></td></tr></table></figure></li><li><p>delete(key)<br>删除一个指定的key/value对。</p></li><li><p>delete_multi(keys)<br>删除多个指定的key/value对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem.set_multi(&#123;<span class="string">"db1"</span>: <span class="string">"oracle"</span>, <span class="string">"db2"</span>: <span class="string">"mysql"</span>, <span class="string">"db3"</span>: <span class="string">"memcache"</span>&#125;)</span><br><span class="line">mem.delete(<span class="string">"db1"</span>)</span><br><span class="line">mem.delete_multi([<span class="string">"db2"</span>, <span class="string">"db3"</span>])</span><br><span class="line">print(mem.get_multi([<span class="string">"db1"</span>, <span class="string">"db2"</span>, <span class="string">"db3"</span>]))    <span class="comment">#输出结果：&#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>append(key, val)<br>在指定key对应的value<code>后面</code>追加内容。</p></li><li>prepend(key, val)<br>在指定key对应的额value<code>前面</code>追加内容。</li><li><p>stats<br>查看历史操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mem.set(<span class="string">"db"</span>, <span class="string">"oracle"</span>)</span><br><span class="line">print(mem.get(<span class="string">"db"</span>))    <span class="comment">#输出结果：oracle</span></span><br><span class="line">mem.append(<span class="string">"db"</span>, <span class="string">" or mysql"</span>)</span><br><span class="line">print(mem.get(<span class="string">"db"</span>))    <span class="comment">#输出结果：oracle or mysql</span></span><br><span class="line">mem.prepend(<span class="string">"db"</span>, <span class="string">"redis or "</span>)</span><br><span class="line">print(mem.get(<span class="string">"db"</span>))    <span class="comment">#输出结果：redis or oracle or mysql</span></span><br><span class="line">print(mem.stats)    <span class="comment">#输出结果：&#123;'set': 1, 'get': 3, 'append': 1, 'prepend': 1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>gets和cas<br>使用缓存系统共享数据资源就必然绕不开数据争夺和脏数据（数据混乱）的问题。<br>假设商城某件商品的剩余个数保存在memcache中，product_count = 900，<br>A用户刷新页面从memecache中读取到product_count = 900，<br>B用户刷新页面从memecache中读取到product_count = 900，<br>A,B用户均购买商品，并修改product_count的值。<br>A修改后，product_count = 899；<br>B修改后，product_count = 899；<br>然而正确数字应该是898，数据就混乱了。<br>如果想要避免这种情况的发生，则可以使用gets和cas。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mem = memcache.Client([<span class="string">"118.24.18.158:11211"</span>])</span><br><span class="line">mem.set(<span class="string">"count"</span>, <span class="string">"100"</span>)</span><br><span class="line">print(mem.get(<span class="string">"count"</span>))    <span class="comment">#输出结果：100</span></span><br><span class="line">print(mem.cas(<span class="string">"count"</span>, <span class="string">"99"</span>))    <span class="comment">#输出结果：True</span></span><br><span class="line">print(mem.gets(<span class="string">"count"</span>))    <span class="comment">#输出结果：99</span></span><br></pre></td></tr></table></figure></li></ul><p>gets和cas一起使用，cas是<code>check and set</code>操作。它仅当当前客户端最后一次取值后，该key对应的值没有被其他客户端修改的情况下，才能够将值写入。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;memcached介绍&quot;&gt;&lt;a href=&quot;#memcached介绍&quot; class=&quot;headerlink&quot; title=&quot;memcached介绍&quot;&gt;&lt;/a&gt;memcached介绍&lt;/h3&gt;&lt;p&gt;Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。Memcached基于一个存储键/值对的hashmap。其守护进程（daemon ）是用C写的，但是客户端可以用任何语言来编写，并通过memcached协议与守护进程通信。&lt;br&gt;memcached在实现分布式群集部署时，memcached服务之间是不能进行通讯的，分布式也是通过客户端的算法把数据保存在不同的memcached中。magent是一款开源的代理服务软件，我们可以通过它来实现缓存数据的同步。magent还可以使用keepalived来实现高可用。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="memcached" scheme="https://rosinelan.github.io/tags/memcached/"/>
    
  </entry>
  
  <entry>
    <title>python访问redis(二)</title>
    <link href="https://rosinelan.github.io/2018/05/18/python%E8%AE%BF%E9%97%AEredis-%E4%BA%8C/"/>
    <id>https://rosinelan.github.io/2018/05/18/python访问redis-二/</id>
    <published>2018-05-18T06:15:06.000Z</published>
    <updated>2018-05-18T17:27:20.265Z</updated>
    
    <content type="html"><![CDATA[<p>关于常用nosql数据库介绍及redis安装配置的介绍，点击<a href="https://rosinelan.coding.me/2018/05/17/python%E8%AE%BF%E9%97%AEredis/" target="_blank" rel="noopener">python访问redis</a>查看。<br>前面介绍了<code>redis</code>常用的数据类型，包括<code>String</code>、<code>List</code>、<code>Hash</code>、<code>Set</code>和<code>Sorted Set</code>。下面针对不同数据类型的操作进行介绍。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li>set(name, value)<br>设置值，默认不存在则创建，存在则修改<a id="more"></a></li><li><p>get(name)<br>获取值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">"118.24.18.158"</span>, port=<span class="number">6379</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line">r.set(<span class="string">"db"</span>, <span class="string">"oracle"</span>)</span><br><span class="line">print(r.get(<span class="string">"db"</span>))    <span class="comment">#输出结果：b'oracle'</span></span><br><span class="line">print(r.get(<span class="string">"db"</span>).decode())    <span class="comment">#输出结果：oracle</span></span><br></pre></td></tr></table></figure></li><li><p>mset(<em>args, *</em>kwargs)<br>批量设置值，传入参数为类型为<code>dict</code></p></li><li>mget(keys, *args)<br>批量获取key的值，传入参数类型为<code>tuple</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.mset(db1=<span class="string">"oracle"</span>, db2=<span class="string">"mysql"</span>, db3=<span class="string">"redis"</span>)</span><br><span class="line">print(r.mget(<span class="string">"db1"</span>, <span class="string">"db2"</span>, <span class="string">"db3"</span>))    <span class="comment">#输出结果：[b'oracle', b'mysql', b'redis']</span></span><br></pre></td></tr></table></figure></li></ul><p>或者使用下面传递参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.mset(&#123;<span class="string">"db1"</span>: <span class="string">"oracle"</span>, <span class="string">"db2"</span>: <span class="string">"mysql"</span>, <span class="string">"db3"</span>: <span class="string">"redis"</span>&#125;)</span><br><span class="line">print(r.mget([<span class="string">"db1"</span>, <span class="string">"db2"</span>, <span class="string">"db3"</span>]))    <span class="comment">#输出结果：[b'oracle', b'mysql', b'redis']</span></span><br></pre></td></tr></table></figure></p><ul><li>append(key, value)<br>在key对应的value后面追加内容<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.set(<span class="string">"db"</span>, <span class="string">"oracle"</span>)</span><br><span class="line">print(r.get(<span class="string">"db"</span>))     <span class="comment">#输出结果：b'oracle'</span></span><br><span class="line">r.append(<span class="string">"db"</span>, <span class="string">" and "</span>)</span><br><span class="line">r.append(<span class="string">"db"</span>, <span class="string">"mysql"</span>)</span><br><span class="line">print(r.get(<span class="string">"db"</span>))     <span class="comment">#输出结果：b'oracle and mysql'</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>在redis中，list类型的存储按照一个name对应一个list来存储。  </p><ul><li>lpush(name, *values)<br>左边添加<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.lpush(<span class="string">"db"</span>, <span class="string">"oracle"</span>)</span><br><span class="line">r.lpush(<span class="string">"db"</span>, <span class="string">"mysql"</span>)</span><br><span class="line">r.lpush(<span class="string">"db"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'redis', b'mysql', b'oracle']</span></span><br></pre></td></tr></table></figure></li></ul><p>或者可以如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.lpush(<span class="string">"db"</span>, <span class="string">"oracle"</span>, <span class="string">"mysql"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'redis', b'mysql', b'oracle']</span></span><br></pre></td></tr></table></figure></p><ul><li><p>rpush(name, *values)<br>右边添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.rpush(<span class="string">"db"</span>, <span class="string">"oracle"</span>)</span><br><span class="line">r.rpush(<span class="string">"db"</span>, <span class="string">"mysql"</span>)</span><br><span class="line">r.rpush(<span class="string">"db"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'oracle', b'mysql', b'redis']</span></span><br></pre></td></tr></table></figure></li><li><p>linsert(name, where, refvalue, value)<br>根据where参数，在列表name的值refvalue前面或者后面插入值value，成功则返回值为新的列表的长度，否则返回-1。<br>where取值为before或者after。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r.lpush(<span class="string">"db"</span>, <span class="string">"oracle"</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'oracle']</span></span><br><span class="line">r.linsert(<span class="string">"db"</span>, <span class="string">"after"</span>, <span class="string">"oracle"</span>, <span class="string">"mysql"</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'oracle', b'mysql']</span></span><br><span class="line">r.linsert(<span class="string">"db"</span>, <span class="string">"before"</span>, <span class="string">"mysql"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'oracle', b'redis', b'mysql']</span></span><br></pre></td></tr></table></figure></li><li><p>lpop(name)<br>删除列表name中的第一个元素，返回值为删除的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.lpush(<span class="string">"db"</span>, <span class="string">"oracle"</span>, <span class="string">"mysql"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'redis', b'mysql', b'oracle']</span></span><br><span class="line">print(r.lpop(<span class="string">"db"</span>))    <span class="comment">#输出结果：b'redis'</span></span><br><span class="line">print(r.lrange(<span class="string">"db"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'mysql', b'oracle']</span></span><br></pre></td></tr></table></figure></li><li><p>lrange(name, start, end)<br>通过分片返回list位于start和end范围的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.lpush(<span class="string">"db"</span>, <span class="string">"oracle"</span>)</span><br><span class="line">r.lpush(<span class="string">"db"</span>, <span class="string">"mysql"</span>)</span><br><span class="line">r.lpush(<span class="string">"db"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db"</span>, <span class="number">0</span>, <span class="number">2</span>))    <span class="comment">#输出结果：[b'redis', b'mysql', b'oracle']</span></span><br><span class="line">print(r.lrange(<span class="string">"db"</span>,<span class="number">0</span>, <span class="number">1</span>))    <span class="comment">#输出结果：[b'redis', b'mysql']</span></span><br></pre></td></tr></table></figure></li><li><p>lset(name, index, value)<br>修改list中指定位置的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.lpush(<span class="string">"db"</span>, <span class="string">"oracle"</span>, <span class="string">"mysql"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'redis', b'mysql', b'oracle']</span></span><br><span class="line">r.lset(<span class="string">"db"</span>, <span class="number">1</span>, <span class="string">"nosql"</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'redis', b'nosql', b'oracle']</span></span><br></pre></td></tr></table></figure></li><li><p>lrem(name, value, num)<br>删除列表name中最先出现的num个值为value的元素。<br><code>num</code>默认值为0，表示删除全部值为value的元素；<br><code>num&gt;0</code>表示删除值为value的元素时从头到尾匹配；<br><code>num&gt;0</code>表示删除值为value的元素时从尾到头匹配。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r.lpush(<span class="string">"db"</span>, <span class="string">"oracle"</span>, <span class="string">"mysql"</span>, <span class="string">"redis"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'redis', b'redis', b'mysql', b'oracle']</span></span><br><span class="line">r.lrem(<span class="string">"db"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'mysql', b'oracle']</span></span><br><span class="line">r.lpush(<span class="string">"db1"</span>, <span class="string">"oracle"</span>, <span class="string">"redis"</span>, <span class="string">"mysql"</span>, <span class="string">"redis"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db1"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'redis', b'redis', b'mysql', b'redis', b'oracle']</span></span><br><span class="line">r.lrem(<span class="string">"db1"</span>, <span class="string">"redis"</span>, <span class="number">1</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db1"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'redis', b'mysql', b'redis', b'oracle']</span></span><br><span class="line">r.lpush(<span class="string">"db2"</span>, <span class="string">"oracle"</span>, <span class="string">"redis"</span>, <span class="string">"mysql"</span>, <span class="string">"redis"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db2"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'redis', b'redis', b'mysql', b'redis', b'oracle']</span></span><br><span class="line">r.lrem(<span class="string">"db2"</span>, <span class="string">"redis"</span>, <span class="number">-2</span>)</span><br><span class="line">print(r.lrange(<span class="string">"db2"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'redis', b'mysql', b'oracle']</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set集合就是不允许重复元素的列表。  </p><ul><li>sadd(name, *values)<br>集合name中添加值。</li><li>scard(name)<br>返回集合name中元素的数量。  </li><li><p>smembers(name)<br>返回集合的所有成员。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.sadd(<span class="string">"dbset"</span>, <span class="string">"oracle"</span>, <span class="string">"mysql"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.scard(<span class="string">"dbset"</span>))    <span class="comment">#输出结果：3</span></span><br><span class="line">print(r.smembers(<span class="string">"dbset"</span>))    <span class="comment">#输出结果：&#123;b'mysql', b'redis', b'oracle'&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>spop(name)<br>随机删除并返回集合name中的一个元素。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.sadd(<span class="string">"dbset"</span>, <span class="string">"oracle"</span>, <span class="string">"mysql"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.smembers(<span class="string">"dbset"</span>))    <span class="comment">#输出结果：&#123;b'redis', b'oracle', b'mysql'&#125;</span></span><br><span class="line">print(r.spop(<span class="string">"dbset"</span>))    <span class="comment">#输出结果：b'mysql'</span></span><br><span class="line">print(r.smembers(<span class="string">"dbset"</span>))    <span class="comment">#输出结果：&#123;b'oracle', b'redis'&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>srem(name, *values)<br>从集合name中删除指定的值。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.sadd(<span class="string">"dbset"</span>, <span class="string">"oracle"</span>, <span class="string">"mysql"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.smembers(<span class="string">"dbset"</span>))     <span class="comment">#输出结果：&#123;b'oracle', b'redis', b'mysql'&#125;</span></span><br><span class="line">r.srem(<span class="string">"dbset"</span>, <span class="string">"mysql"</span>, <span class="string">"redis"</span>)</span><br><span class="line">print(r.smembers(<span class="string">"dbset"</span>))     <span class="comment">#输出结果：&#123;b'oracle'&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>sunion(keys, *args)<br>返回多个集合的并集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.sadd(<span class="string">"set1"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>)</span><br><span class="line">r.sadd(<span class="string">"set2"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>)</span><br><span class="line">r.sadd(<span class="string">"set3"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>)</span><br><span class="line">print(r.sunion(<span class="string">"set1"</span>, <span class="string">"set2"</span>, <span class="string">"set3"</span>))    <span class="comment">#输出结果：&#123;b'5', b'2', b'3', b'1', b'4'&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>sinter()<br>返回多个集合的交集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.sadd(<span class="string">"set1"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>)</span><br><span class="line">r.sadd(<span class="string">"set2"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>)</span><br><span class="line">r.sadd(<span class="string">"set3"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>)</span><br><span class="line">print(r.sinter(<span class="string">"set1"</span>, <span class="string">"set2"</span>, <span class="string">"set3"</span>))    <span class="comment">#输出结果：&#123;b'3'&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>Zset也就是sorted Set，有序集合。在集合的基础上元素的排序根据另外一个值进行比较。所以有序集合每个元素有2个值，即值和分数，分数专门用来做排序。  </p><ul><li><p>zadd(name, <em>args, *</em>kwargs)<br>集合添加元素，下面两种写法是等价的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.zadd(<span class="string">"dbset"</span>, <span class="string">"oracle"</span>, <span class="number">1</span>, <span class="string">"redis"</span>, <span class="number">3</span>, <span class="string">"mysql"</span>, <span class="number">2</span>)</span><br><span class="line">r.zadd(<span class="string">"dbset"</span>, oracle=<span class="number">1</span>, redis=<span class="number">3</span>, mysql=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>zcard(name)<br>有序集合中名称为name的元素个数。  </p></li><li><p>zrange(name, start, end)<br>返回有序集合name中位于start和end之间的元素，默认为升序排列。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.zadd(<span class="string">"dbset"</span>, <span class="string">"oracle"</span>, <span class="number">1</span>, <span class="string">"redis"</span>, <span class="number">3</span>, <span class="string">"mysql"</span>, <span class="number">2</span>)</span><br><span class="line">print(r.zrange(<span class="string">"dbset"</span>, <span class="number">0</span>, <span class="number">-1</span>))    <span class="comment">#输出结果：[b'oracle', b'mysql', b'redis']</span></span><br><span class="line">print(r.zcard(<span class="string">"dbset"</span>))    <span class="comment">#输出结果：3</span></span><br></pre></td></tr></table></figure></li><li><p>zrem(name, *values)<br>删除有序集合name中的值。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.zadd(<span class="string">"dbset"</span>, oracle=<span class="number">1</span>, redis=<span class="number">3</span>, mysql=<span class="number">2</span>)</span><br><span class="line">r.zrem(<span class="string">"dbset"</span>, <span class="string">"oracle"</span>)</span><br><span class="line">print(r.zrange(<span class="string">"dbset"</span>, <span class="number">0</span>, <span class="number">-1</span>))   <span class="comment">#输出结果：[b'mysql', b'redis']</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>redis中的Hash在内存中类似于一个name对应一个dict来存储。  </p><ul><li>hset(name, key, value)<br>名称为name的hash中，将key的值设置为value。<br>若成功添加则返回1，否则返回0.  </li><li><p>hget(name, key)<br>在名称的name的hash中，返回key的对应值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.hset(<span class="string">"dbhash"</span>, <span class="string">"db1"</span>, <span class="string">"oracle"</span>)</span><br><span class="line">print(r.hget(<span class="string">"dbhash"</span>, <span class="string">"db1"</span>))    <span class="comment">#输出结果：b'oracle'</span></span><br></pre></td></tr></table></figure></li><li><p>hmset(name, mapping)<br>名称为name的hash中，根据mapping字典内容添加对应的key和value。  </p></li><li><p>hmget(name, keys, *args)<br>名称为name的hash中获取多个keys的值。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.hmset(<span class="string">"dbhash"</span>, &#123;<span class="string">"db1"</span>: <span class="string">"oracle"</span>, <span class="string">"db2"</span>: <span class="string">"mysql"</span>&#125;)</span><br><span class="line">print(r.hmget(<span class="string">"dbhash"</span>, <span class="string">"db1"</span>, <span class="string">"db2"</span>))    <span class="comment">#输出结果：[b'oracle', b'mysql']</span></span><br></pre></td></tr></table></figure></li><li><p>hkeys(name)<br>列表形式返回名称为name的hash中的keys。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.hmset(<span class="string">"dbhash"</span>, &#123;<span class="string">"db1"</span>: <span class="string">"oracle"</span>, <span class="string">"db2"</span>: <span class="string">"mysql"</span>&#125;)</span><br><span class="line">print(r.hkeys(<span class="string">"dbhash"</span>))     <span class="comment">#输出结果：[b'db1', b'db2']</span></span><br></pre></td></tr></table></figure></li><li><p>hvals()<br>列表形式返回名称为name的hash中的values。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.hmset(<span class="string">"dbhash"</span>, &#123;<span class="string">"db1"</span>: <span class="string">"oracle"</span>, <span class="string">"db2"</span>: <span class="string">"mysql"</span>&#125;)</span><br><span class="line">print(r.hvals(<span class="string">"dbhash"</span>))    <span class="comment">#输出结果：[b'oracle', b'mysql']</span></span><br></pre></td></tr></table></figure></li><li><p>hexists(name, key)<br>名称为name的hash中是否存在key。返回值为布尔值。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.hmset(<span class="string">"dbhash"</span>, &#123;<span class="string">"db1"</span>: <span class="string">"oracle"</span>, <span class="string">"db2"</span>: <span class="string">"mysql"</span>&#125;)</span><br><span class="line">print(r.hexists(<span class="string">"dbhash"</span>, <span class="string">"db1"</span>))     <span class="comment">#输出结果：True</span></span><br><span class="line">print(r.hexists(<span class="string">"dbhash"</span>, <span class="string">"db3"</span>))     <span class="comment">#输出结果：False</span></span><br></pre></td></tr></table></figure></li><li><p>hdel(name, keys)<br>删除名称为name的hash中的keys。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.hmset(<span class="string">"dbhash"</span>, &#123;<span class="string">"db1"</span>: <span class="string">"oracle"</span>, <span class="string">"db2"</span>: <span class="string">"mysql"</span>&#125;)</span><br><span class="line">print(r.hdel(<span class="string">"dbhash"</span>, <span class="string">"db1"</span>))    <span class="comment">#输出结果：1</span></span><br><span class="line">print(r.hkeys(<span class="string">"dbhash"</span>))    <span class="comment">#输出结果：[b'db2']</span></span><br></pre></td></tr></table></figure></li><li><p>hlen(name)<br>返回名称为name的hash中元素的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.hmset(<span class="string">"dbhash"</span>, &#123;<span class="string">"db1"</span>: <span class="string">"oracle"</span>, <span class="string">"db2"</span>: <span class="string">"mysql"</span>&#125;)</span><br><span class="line">print(r.hlen(<span class="string">"dbhash"</span>))    <span class="comment">#输出结果：2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="其它常用操作"><a href="#其它常用操作" class="headerlink" title="其它常用操作"></a>其它常用操作</h3><p>下面的操作适用于上述所有类型</p><ul><li><p>keys(pattern=’*’)<br>返回匹配pattern的key。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.set(<span class="string">"dbset"</span>, <span class="number">1</span>)</span><br><span class="line">r.set(<span class="string">"dbstr"</span>, <span class="number">2</span>)</span><br><span class="line">r.set(<span class="string">"int"</span>, <span class="number">3</span>)</span><br><span class="line">print(r.keys(pattern=<span class="string">'db*'</span>))    <span class="comment">#输出结果：[b'dbstr', b'dbset']</span></span><br></pre></td></tr></table></figure></li><li><p>delete(<em>names)<br>删除</em>name指定的一个或多个keys。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.set(<span class="string">"dbset"</span>, <span class="number">1</span>)</span><br><span class="line">r.set(<span class="string">"dbstr"</span>, <span class="number">2</span>)</span><br><span class="line">r.set(<span class="string">"int"</span>, <span class="number">3</span>)</span><br><span class="line">print(r.delete(<span class="string">"dbset"</span>, <span class="string">"dbstr"</span>))</span><br><span class="line">print(r.keys())</span><br></pre></td></tr></table></figure></li><li><p>exists(name)<br>判断key为name是否存在。返回值为布尔值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.set(<span class="string">"dbset"</span>, <span class="number">1</span>)</span><br><span class="line">print(r.exists(<span class="string">"dbset"</span>))     <span class="comment">#输出结果：True</span></span><br><span class="line">print(r.exists(<span class="string">"dbstr"</span>))     <span class="comment">#输出结果：False</span></span><br></pre></td></tr></table></figure></li><li><p>rename(src, dst)<br>修改key的名称，修改成功返回True，否则返回错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.set(<span class="string">"dbset"</span>, <span class="number">1</span>)</span><br><span class="line">print(r.rename(<span class="string">"dbset"</span>, <span class="string">"db"</span>))    <span class="comment">#输出结果：True</span></span><br><span class="line">print(r.keys())    <span class="comment">#输出结果：[b'db']</span></span><br></pre></td></tr></table></figure></li><li><p>expire(name, time)<br>设置key的过期时间。  </p></li><li><p>type()<br>返回key所存储值的类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.set(<span class="string">"dbset"</span>, <span class="number">1</span>)</span><br><span class="line">print(r.type(<span class="string">"dbset"</span>))    <span class="comment">#输出结果：b'string'</span></span><br><span class="line">r.zadd(<span class="string">"dbset1"</span>, oracle=<span class="number">1</span>, redis=<span class="number">3</span>, mysql=<span class="number">2</span>)</span><br><span class="line">print(r.type(<span class="string">"dbset1"</span>))    <span class="comment">#输出结果：b'zset'</span></span><br></pre></td></tr></table></figure></li><li><p>move(name, db)<br>将key为name的元素迁移至db。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.set(<span class="string">"dbset"</span>, <span class="string">"dbstr"</span>)</span><br><span class="line">print(r.move(<span class="string">"dbset"</span>, <span class="number">1</span>))    <span class="comment">#输出结果：True</span></span><br></pre></td></tr></table></figure></li><li><p>flushall()<br>删除所有的key。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于常用nosql数据库介绍及redis安装配置的介绍，点击&lt;a href=&quot;https://rosinelan.coding.me/2018/05/17/python%E8%AE%BF%E9%97%AEredis/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;python访问redis&lt;/a&gt;查看。&lt;br&gt;前面介绍了&lt;code&gt;redis&lt;/code&gt;常用的数据类型，包括&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Hash&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;和&lt;code&gt;Sorted Set&lt;/code&gt;。下面针对不同数据类型的操作进行介绍。&lt;/p&gt;
&lt;h3 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;set(name, value)&lt;br&gt;设置值，默认不存在则创建，存在则修改
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="redis" scheme="https://rosinelan.github.io/tags/redis/"/>
    
      <category term="get" scheme="https://rosinelan.github.io/tags/get/"/>
    
      <category term="set" scheme="https://rosinelan.github.io/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>python访问redis</title>
    <link href="https://rosinelan.github.io/2018/05/17/python%E8%AE%BF%E9%97%AEredis/"/>
    <id>https://rosinelan.github.io/2018/05/17/python访问redis/</id>
    <published>2018-05-17T00:05:59.000Z</published>
    <updated>2018-05-18T17:13:57.356Z</updated>
    
    <content type="html"><![CDATA[<p>首先看个案例<br>无论是电商网站还是支付系统，都离不开数据的存储和增删改查，在这种情况下，每一次登录、访问等都会访问，这样会给数据库造成很大的压力，当数据库无法支撑过高的访问量，轻则影响用户体验，重则导致数据库宕机，网站无法访问。<br>如何解决数据库压力过大的问题呢？  </p><ol><li>优化应用程序，减少数据库的连接数，尽量使用数据库连接池。<a id="more"></a></li><li>使用消息队列，常见的有RabbitMQ,ActiveMQ，Kafka,RocketMQ等。</li><li>通过使用redis等缓存数据，分担数据库读压力，同时直接从内存读数据速度更快。</li></ol><p>下面主要针对redis等nosql数据库进行介绍。  </p><h3 id="nosql介绍"><a href="#nosql介绍" class="headerlink" title="nosql介绍"></a>nosql介绍</h3><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>对于NoSQL并没有一个明确的范围和定义，但是他们都普遍存在下面一些共同特征：</p><ol><li>不需要预定义模式：不需要事先定义数据模式，预定义表结构。数据中的每条记录都可能有不同的属性和格式。当插入数据时，并不需要预先定义它们的模式。</li><li>无共享架构：相对于将所有数据存储的存储区域网络中的全共享架构。NoSQL往往将数据划分后存储在各个本地服务器上。因为从本地磁盘读取数据的性能往往好于通过网络传输读取数据的性能，从而提高了系统的性能。</li><li>弹性可扩展：可以在系统运行的时候，动态增加或者删除结点。不需要停机维护，数据可以自动迁移。</li><li>分区：相对于将数据存放于同一个节点，NoSQL数据库需要将数据进行分区，将记录分散在多个节点上面。并且通常分区的同时还要做复制。这样既提高了并行性能，又能保证没有单点失效的问题。</li><li>异步复制：和RAID存储系统不同的是，NoSQL中的复制，往往是基于日志的异步复制。这样，数据就可以尽快地写入一个节点，而不会被网络传输引起迟延。缺点是并不总是能保证一致性，这样的方式在出现故障的时候，可能会丢失少量的数据。</li><li>BASE：相对于事务严格的ACID特性，NoSQL数据库保证的是BASE特性。BASE是最终一致性和软事务。<br>NoSQL数据库并没有一个统一的架构，两种NoSQL数据库之间的不同，甚至远远超过两种关系型数据库的不同。可以说，NoSQL各有所长，成功的NoSQL必然特别适用于某些场合或者某些应用，在这些场合中会远远胜过关系型数据库和其他的NoSQL<h4 id="常用的nosql数据库"><a href="#常用的nosql数据库" class="headerlink" title="常用的nosql数据库"></a>常用的nosql数据库</h4>临时性键值存储|永久性键值存储|面向文档的数据库|面向列的数据库<br>-|:-:|:-:|:-:|<br>Memcached|Tokyo Tyrant|MangoDB|Cassandra<br>Redis|Flare|CouchDB|HBase<br>&nbsp;|ROMA||HyperTable<br>&nbsp;|Redis||<h3 id="redis安装和配置"><a href="#redis安装和配置" class="headerlink" title="redis安装和配置"></a>redis安装和配置</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4>redis主要用于linux下，下面centos7下面安装最新版本redis-4.0.9。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-4.0.9.tar.gz</span><br><span class="line">tar xzf redis-4.0.9.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-4.0.9/</span><br><span class="line">make</span><br><span class="line"><span class="built_in">cd</span> src &amp;&amp; make all</span><br></pre></td></tr></table></figure></li></ol><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>redis可以单机多实例，通过修改配置文件，不同实例使用不同的配置文件和端口号即可。<br>下面配置文件统一存放在<code>conf</code>目录中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/   </span><br><span class="line">mv redis-4.0.9 redis    <span class="comment">#目录重命名，取消版本信息</span></span><br><span class="line"><span class="built_in">cd</span> redis</span><br><span class="line">mkdir conf     <span class="comment">#新建配置文件目录，统一存放配置文件</span></span><br><span class="line">cp redis.conf conf/redis_6379.conf    <span class="comment">#配置文件，以端口号命名</span></span><br></pre></td></tr></table></figure></p><p>修改<code>redis_6379.conf</code>文件，默认该配置项为no，修改为yes。<br>该参数表示是否使用守护线程的方式启动。<br>当设置为<code>yes</code>时，表示开启守护进程模式。该模式下，redis在后台运行，并将进程pid写入至配置文件中设置的pidfile中，此时redis将一直运行，除非手动kill该进程。<br>当设置为<code>no</code>时，当前界面将进入redis的命令行界面，ctrl+c强制退出或者关闭连接工具都会导致redis进程退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br></pre></td></tr></table></figure></p><p><strong>启动</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /usr/<span class="built_in">local</span>/src/redis/conf/redis_6379.conf</span><br></pre></td></tr></table></figure></p><p><strong>确认是否启动</strong><br>通过进程确认<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_4_centos conf]# ps aux|grep redis</span><br><span class="line">root     25841  0.0  0.1 141772  1976 ?        Ssl  23:26   0:00 redis-server 127.0.0.1:6379</span><br><span class="line">root     25856  0.0  0.0 112644   964 pts/1    R+   23:26   0:00 grep --color=auto redis</span><br></pre></td></tr></table></figure></p><p>通过端口号确认<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_4_centos conf]# netstat -lntp |grep 6379</span><br><span class="line">tcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN      25841/redis-server</span><br></pre></td></tr></table></figure></p><h4 id="错误信息说明"><a href="#错误信息说明" class="headerlink" title="错误信息说明"></a>错误信息说明</h4><ul><li>未安装gcc编译工具<br>redis基于C语言编写，需要使用gcc等编译工具，若未安装，在<code>make</code>编译过程中会报错。使用<code>yum install gcc</code>安装，默认会安装gcc及对应的依赖包即可。</li><li>未安装<code>jemalloc</code><br>默认情况下redis的<code>memory allocator</code>是<code>jemalloc</code>，若未安装会出现下面报错信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zmalloc.h:50:31: fatal error: jemalloc/jemalloc.h: No such file or directory</span><br><span class="line"> <span class="comment">#include &lt;jemalloc/jemalloc.h&gt;</span></span><br><span class="line">                               ^</span><br><span class="line">compilation terminated.</span><br><span class="line">make[1]: *** [adlist.o] Error 1</span><br><span class="line">make[1]: Leaving directory `/usr/<span class="built_in">local</span>/src/redis-4.0.9/src<span class="string">'</span></span><br><span class="line"><span class="string">make: *** [all] Error 2</span></span><br></pre></td></tr></table></figure></li></ul><p>可以设置使用<code>libc malloc</code>，编译的时候使用<code>make MALLOC=libc</code>即可。<br>具体更多内容可以参见redis解压目录下的<code>redis.MD</code>文件中<code>Allocator</code>部分。</p><ul><li>异机连接端口不通<br>在redis配置文件中，默认情况下<code>bing 127.0.0.1</code>，也就是仅允许本机连接。当通过其他机器连接的时候会出现无法连接的情况。<br>修改redis配置文件，将<code>bing 127.0.0.1</code>修改为<code>bind 0.0.0.0</code>，然后重启<code>redis-server</code>服务。<h3 id="redis数据类型"><a href="#redis数据类型" class="headerlink" title="redis数据类型"></a>redis数据类型</h3>redis支持5种数据类型，分别是String(字符串)、List(列表)、Hash(字典)、Set(集合)、Sorted Set(有序集合)。<br>本质上来说，redis存储的是key-value对，其中key是字符串，对应的value类型决定了redis的数据类型。</li><li><p>String(字符串)<br>string是redis最基本的类型，其基本模型也是一个key对应一个value。<br>string类型是二进制安全的。也就是说redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。<br>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET name <span class="string">"xiaohh"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line"><span class="string">"xiaohh"</span></span><br></pre></td></tr></table></figure></li><li><p>List(列表)<br>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush xiaohh redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush xiaohh mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush xiaohh rabitmq</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange xiaohh 0 2</span><br><span class="line">1) <span class="string">"rabitmq"</span></span><br><span class="line">2) <span class="string">"mongodb"</span></span><br><span class="line">3) <span class="string">"redis"</span></span><br></pre></td></tr></table></figure></li><li><p>Hash(字典)<br>Redis hash 是一个键值(key=&gt;value)对集合。<br>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HMSET myhash fileld1 <span class="string">"Hello"</span> fileld2 <span class="string">"World"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HGET myhash fileld1</span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line">127.0.0.1:6379&gt; HGET myhash fileld2</span><br><span class="line"><span class="string">"World"</span></span><br></pre></td></tr></table></figure></li><li><p>Set(集合)<br>Redis的Set是string类型的无序集合。<br>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">27.0.0.1:6379&gt; sadd <span class="built_in">type</span> redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">type</span> mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">type</span> rabbitmq</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd <span class="built_in">type</span> rabbitmq</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers <span class="built_in">type</span></span><br><span class="line">1) <span class="string">"rabbitmq"</span></span><br><span class="line">2) <span class="string">"mongodb"</span></span><br><span class="line">3) <span class="string">"redis"</span></span><br></pre></td></tr></table></figure></li></ul><p>由于Set中元素具有唯一性的，所以重复添加的<code>rabbitmq</code>只有一个，第二次添加将被忽略。</p><ul><li>Sorted Set(有序集合)<br>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br>zset的成员是唯一的,但分数(score)却可以重复。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd  type1 0 redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd type1 3 mongodb</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd type1 2 rabbitmq</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd type1 2 rabbitmq</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE type1 0 10</span><br><span class="line">1) <span class="string">"redis"</span></span><br><span class="line">2) <span class="string">"rabbitmq"</span></span><br><span class="line">3) <span class="string">"mongodb"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="python访问redis"><a href="#python访问redis" class="headerlink" title="python访问redis"></a>python访问redis</h3><p>python访问redis需要安装对应的<code>redis</code>包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure></p><p>redis连接池<br>redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。<br>默认，每个Redis实例都会维护一个自己的连接。可以直接建立一个连接池，然后作为Redis参数，这样就可以实现多个Redis实例共享一个连接池。<br>连接redis服务器<br>连接redis服务器需要提供redis服务器的地址和端口号，默认端口号为6379。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">"118.24.18.158"</span>, port=<span class="string">"6379"</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line">r.set(<span class="string">"name"</span>, <span class="string">"xiaohh"</span>)</span><br><span class="line">print(r.get(<span class="string">"name"</span>))    <span class="comment">#输出结果："xiaohh"</span></span><br></pre></td></tr></table></figure></p><p>通过python对redis数据库进行操作，首先建立redis的连接，然后对不同的数据类型采用不同的方法进行操作。<br>具体操作方法点击<a href="https://rosinelan.coding.me/2018/05/18/python%E8%AE%BF%E9%97%AEredis-%E4%BA%8C/" target="_blank" rel="noopener">python访问redis</a>查看。<br>更多redis相关内容可以点击查看<a href="https://redis.io/documentation" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先看个案例&lt;br&gt;无论是电商网站还是支付系统，都离不开数据的存储和增删改查，在这种情况下，每一次登录、访问等都会访问，这样会给数据库造成很大的压力，当数据库无法支撑过高的访问量，轻则影响用户体验，重则导致数据库宕机，网站无法访问。&lt;br&gt;如何解决数据库压力过大的问题呢？  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优化应用程序，减少数据库的连接数，尽量使用数据库连接池。
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="redis" scheme="https://rosinelan.github.io/tags/redis/"/>
    
      <category term="nosql" scheme="https://rosinelan.github.io/tags/nosql/"/>
    
  </entry>
  
  <entry>
    <title>python中使用SQLAlchemy(二)</title>
    <link href="https://rosinelan.github.io/2018/05/14/python%E4%B8%AD%E4%BD%BF%E7%94%A8SQLAlchemy-%E4%BA%8C/"/>
    <id>https://rosinelan.github.io/2018/05/14/python中使用SQLAlchemy-二/</id>
    <published>2018-05-14T07:30:26.000Z</published>
    <updated>2018-05-14T09:21:05.187Z</updated>
    
    <content type="html"><![CDATA[<p>关于<code>SQLAlchemy</code>使用建表、插入和查询内容，点击<a href="https://rosinelan.coding.me/2018/05/11/python%E4%B8%AD%E4%BD%BF%E7%94%A8SQLAlchemy/" target="_blank" rel="noopener">python中使用SQLAlchemy</a>查看。<br>继续以前面建立的<code>student</code>表作为示例进行后面的操作。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc student;</span><br><span class="line">+---------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field   | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+---------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id      | int(11)      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name    | varchar(100) | YES  |     | NULL    |                |</span><br><span class="line">| age     | int(11)      | YES  |     | NULL    |                |</span><br><span class="line">| address | varchar(100) | YES  |     | NULL    |                |</span><br><span class="line">+---------+--------------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.15 sec)</span><br><span class="line">mysql&gt; select * from student;</span><br><span class="line">+------+-------+------+---------+</span><br><span class="line">| id   | name  | age  | address |</span><br><span class="line">+------+-------+------+---------+</span><br><span class="line">| 1001 | Alice |   25 | anhui   |</span><br><span class="line">| 1002 | Bob   |   69 | beijing |</span><br><span class="line">| 1003 | Cerry |   14 | jiangsu |</span><br><span class="line">+------+-------+------+---------+</span><br><span class="line">3 rows in set (0.07 sec)</span><br></pre></td></tr></table></figure></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新时，首先查询需要更新的数据，然后直接更新对应字段即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, Column, Integer, String</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:123456@localhost/test"</span>)</span><br><span class="line">DBsession = sessionmaker(bind=engine)</span><br><span class="line">session = DBsession()</span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'student'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">100</span>))</span><br><span class="line">    age = Column(Integer)</span><br><span class="line">    address = Column(String(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">student1 = session.query(Student).filter(Student.name == <span class="string">'Alice'</span>).one()</span><br><span class="line">print(<span class="string">"更新前age：&#123;0&#125;"</span>.format(student1.age))</span><br><span class="line">student1.age = <span class="string">'38'</span></span><br><span class="line">session.commit()</span><br><span class="line">print(<span class="string">"更新后age：&#123;0&#125;"</span>.format(student1.age))</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">更新前age：<span class="number">25</span></span><br><span class="line">更新后age：<span class="number">38</span></span><br></pre></td></tr></table></figure></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除时，首先查询出需要删除的数据，然后直接调用<code>delete()</code>方法直接删除即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student2 = session.query(Student).filter(Student.name == <span class="string">'Alice'</span>).delete()</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></p><p>数据库结果确认<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+------+-------+------+---------+</span><br><span class="line">| id   | name  | age  | address |</span><br><span class="line">+------+-------+------+---------+</span><br><span class="line">| 1002 | Bob   |   69 | beijing |</span><br><span class="line">| 1003 | Cerry |   14 | jiangsu |</span><br><span class="line">+------+-------+------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>在进行分组及排序操作前，先插入几条数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">student1 = Student(id=<span class="number">1001</span>, name=<span class="string">'Alice'</span>, age=<span class="number">22</span>, address=<span class="string">'beijing'</span>)</span><br><span class="line">student2 = Student(id=<span class="number">1004</span>, name=<span class="string">'Dany'</span>, age=<span class="number">14</span>, address=<span class="string">'beijing'</span>)</span><br><span class="line">student3 = Student(id=<span class="number">1005</span>, name=<span class="string">'Ever'</span>, age=<span class="number">97</span>, address=<span class="string">'beijing'</span>)</span><br><span class="line">student4 = Student(id=<span class="number">1006</span>, name=<span class="string">'For'</span>, age=<span class="number">50</span>, address=<span class="string">'beijing'</span>)</span><br><span class="line">session.add_all([student1, student2, student3, student4])</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></p><p>数据库结果确认<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+------+-------+------+---------+</span><br><span class="line">| id   | name  | age  | address |</span><br><span class="line">+------+-------+------+---------+</span><br><span class="line">| 1001 | Alice |   22 | beijing |</span><br><span class="line">| 1002 | Bob   |   69 | beijing |</span><br><span class="line">| 1003 | Cerry |   14 | jiangsu |</span><br><span class="line">| 1004 | Dany  |   14 | beijing |</span><br><span class="line">| 1005 | Ever  |   97 | beijing |</span><br><span class="line">| 1006 | For   |   50 | beijing |</span><br><span class="line">+------+-------+------+---------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>统计方法为<code>count()</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count_student = session.query(Student).filter(Student.name.like(<span class="string">'%e%'</span>)).count()</span><br><span class="line">print(<span class="string">"姓名中带字母e的人&#123;0&#125;个"</span>.format(count_student))</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">姓名中带字母e的人<span class="number">3</span>个</span><br></pre></td></tr></table></figure></p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>分组方法为<code>group_by()</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">group_student = session.query(Student).group_by(Student.address).all()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> group_student:</span><br><span class="line">    print(i.id, i.name, i.age, i.address)</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1001</span> Alice <span class="number">22</span> beijing</span><br><span class="line"><span class="number">1003</span> Cerry <span class="number">14</span> jiangsu</span><br></pre></td></tr></table></figure></p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>排序方法为<code>order_by()</code>，默认为升序，反序在order_by里面使用<code>desc()</code>方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">order_student = session.query(Student).filter(Student.age &gt; <span class="number">30</span>).order_by(Student.age).all()</span><br><span class="line">print(<span class="string">"默认排序输出"</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> order_student:</span><br><span class="line">    print(x.id, x.name, x.age, x.address)</span><br><span class="line"></span><br><span class="line">orderdesc_student = session.query(Student).filter(Student.age &gt; <span class="number">30</span>).order_by(Student.age.desc()).all()</span><br><span class="line">print(<span class="string">"反序输出"</span>)</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> orderdesc_student:</span><br><span class="line">    print(y.id, y.name, y.age, y.address)</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">默认排序输出</span><br><span class="line"><span class="number">1006</span> For <span class="number">50</span> beijing</span><br><span class="line"><span class="number">1002</span> Bob <span class="number">69</span> beijing</span><br><span class="line"><span class="number">1005</span> Ever <span class="number">97</span> beijing</span><br><span class="line">反序输出</span><br><span class="line"><span class="number">1005</span> Ever <span class="number">97</span> beijing</span><br><span class="line"><span class="number">1002</span> Bob <span class="number">69</span> beijing</span><br><span class="line"><span class="number">1006</span> For <span class="number">50</span> beijing</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><ol><li><p>创建引擎engine</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:123456@localhost/test"</span>)</span><br></pre></td></tr></table></figure></li><li><p>创建session</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DBsession = sessionmaker(bind=engine)</span><br><span class="line">session = DBsession()</span><br></pre></td></tr></table></figure></li><li><p>定义模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span>    <span class="comment">#Student类继承自Base类，</span></span><br><span class="line">    __tablename__ = <span class="string">'student'</span>    <span class="comment">#对应数据库表名</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)    <span class="comment">#对应数据库各字段</span></span><br><span class="line">    name = Column(String(<span class="number">100</span>))</span><br><span class="line">    age = Column(Integer)</span><br><span class="line">    address = Column(String(<span class="number">100</span>))</span><br></pre></td></tr></table></figure></li></ol><p>接下来基于前面创建的<code>session</code>和<code>Student</code>类及属性进行增删改查的操作。</p><h4 id="常见查询总结"><a href="#常见查询总结" class="headerlink" title="常见查询总结"></a>常见查询总结</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#简单查询</span></span><br><span class="line">print(session.query(Student).all())</span><br><span class="line">print(session.query(Student.id, Student.name).all())</span><br><span class="line">print(session.query(Student, Student.name).all())</span><br><span class="line"><span class="comment">#带条件查询</span></span><br><span class="line">print(session.query(Student).filter_by(name=<span class="string">'Bob'</span>).all())</span><br><span class="line">print(session.query(Student).filter(Student.name == <span class="string">'Bob'</span>).all())</span><br><span class="line">print(session.query(Student).filter(Student.name.like(<span class="string">'%e%'</span>)).all())</span><br><span class="line"><span class="comment">#多条件查询</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> and_, or_</span><br><span class="line">print(session.query(Student).filter(and_(Student.age &gt; <span class="number">20</span>, Student.name.like(<span class="string">'%e%'</span>))).all())</span><br><span class="line">print(session.query(Student).filter(or_(Student.age &gt; <span class="number">20</span>, Student.name.like(<span class="string">'%e%'</span>))).all())</span><br><span class="line"><span class="comment">#sql过滤</span></span><br><span class="line">print(session.query(Student).filter(<span class="string">"id=:id"</span>).params(id=<span class="number">1001</span>).all())</span><br><span class="line"><span class="comment">#关联查询</span></span><br><span class="line">print(session.query(User, Address).filter(User.id == Address.user_id).all())</span><br><span class="line">print(session.query(User).join(User.addresses).all())</span><br><span class="line">print(session.query(User).outerjoin(User.addresses).all())</span><br><span class="line"><span class="comment">#聚合查询</span></span><br><span class="line">print(session.query(User.name, func.count(<span class="string">'*'</span>).label(<span class="string">"user_count"</span>)).group_by(User.name).all())</span><br><span class="line">print(session.query(User.name, func.sum(User.id).label(<span class="string">"user_id_sum"</span>)).group_by(User.name).all())</span><br><span class="line"><span class="comment">#子查询</span></span><br><span class="line"> stmt = session.query(Address.user_id, func.count(<span class="string">'*'</span>).label(<span class="string">"address_count"</span>)).group_by(Address.user_id).subquery()</span><br><span class="line">print(session.query(User, stmt.c.address_count).outerjoin((stmt, User.id == stmt.c.user_id)).order_by(User.id).all())</span><br><span class="line"><span class="comment">#exists</span></span><br><span class="line">print(session.query(User).filter(exists().where(Address.user_id == User.id)))</span><br><span class="line">print(session.query(User).filter(User.addresses.any()))</span><br></pre></td></tr></table></figure><p>限制返回字段查询<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person = session.query(Person.name, Person.created_at,                     </span><br><span class="line">             Person.updated_at).filter_by(name=<span class="string">"zhongwei"</span>).order_by(            </span><br><span class="line">             Person.created_at).first()</span><br></pre></td></tr></table></figure></p><p>记录总数查询<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line"></span><br><span class="line">session.query(func.count(User.id))</span><br><span class="line"></span><br><span class="line">session.query(func.count(User.id)).\</span><br><span class="line">        group_by(User.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> distinct</span><br><span class="line"></span><br><span class="line">session.query(func.count(distinct(User.name)))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于&lt;code&gt;SQLAlchemy&lt;/code&gt;使用建表、插入和查询内容，点击&lt;a href=&quot;https://rosinelan.coding.me/2018/05/11/python%E4%B8%AD%E4%BD%BF%E7%94%A8SQLAlchemy/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;python中使用SQLAlchemy&lt;/a&gt;查看。&lt;br&gt;继续以前面建立的&lt;code&gt;student&lt;/code&gt;表作为示例进行后面的操作。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="update" scheme="https://rosinelan.github.io/tags/update/"/>
    
      <category term="delete" scheme="https://rosinelan.github.io/tags/delete/"/>
    
      <category term="count" scheme="https://rosinelan.github.io/tags/count/"/>
    
      <category term="groupby" scheme="https://rosinelan.github.io/tags/groupby/"/>
    
      <category term="orderby" scheme="https://rosinelan.github.io/tags/orderby/"/>
    
      <category term="统计" scheme="https://rosinelan.github.io/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="分组" scheme="https://rosinelan.github.io/tags/%E5%88%86%E7%BB%84/"/>
    
      <category term="排序" scheme="https://rosinelan.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>python中使用SQLAlchemy</title>
    <link href="https://rosinelan.github.io/2018/05/11/python%E4%B8%AD%E4%BD%BF%E7%94%A8SQLAlchemy/"/>
    <id>https://rosinelan.github.io/2018/05/11/python中使用SQLAlchemy/</id>
    <published>2018-05-11T03:35:35.000Z</published>
    <updated>2018-05-13T12:40:16.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念简介"><a href="#概念简介" class="headerlink" title="概念简介"></a>概念简介</h3><ul><li>ORM<br><code>ORM</code>是Object-Relational Mapping的简写。今天学习的<code>SQLAlchemy</code>其实就是ORM框架中最有名的一个。<br><code>SQLAlchemy</code>框架工作<br>通过数据的API，使用关系对象映射进行数据库操作，也就是：将对象转换成SQL，然后使用数据API执行SQL并获取执行结果。  <a id="more"></a><img src="http://cdn.rosinelan.com/blog/program/orm-sqlalchemy-core.jpg" alt="orm-sqlalchemy-core" title="orm-sqlalchemy-core"><br>SQLAlchemy本身无法操作数据库，其必须通过<code>pymysql</code>等第三方插件。上图中Dialect用于和数据API进行交流，根据配置文件的不同调用不同的数据库API，从而实现对数据库的操作。  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysqldb</span></span><br><span class="line">mysql+mysqldb://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;</span><br><span class="line"><span class="comment"># pymysql</span></span><br><span class="line">mysql+pymysql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;dbname&gt;[?&lt;options&gt;]</span><br><span class="line"><span class="comment"># mysql-connector</span></span><br><span class="line">mysql+mysqlconnector://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;</span><br><span class="line"><span class="comment"># cx_oracle</span></span><br><span class="line"> oracle+cx_oracle://user:pass@host:port/dbname[?key=value&amp;key=value...]</span><br></pre></td></tr></table></figure></li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>ORM思想的核心是隐藏了数据访问细节，提供了通用的数据库交互。并且完全不用考虑SQL语句，从而快速开发。  </p><ul><li>使用SQL创建表<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  age <span class="built_in">int</span>,</span><br><span class="line">  address <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>上述是一个简单的创建单表的语句。  </p><ul><li>使用SQLAlchemy<br>方法1<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, Column, String, Integer, MetaData</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:123456@localhost/test"</span>, encoding=<span class="string">'UTF-8'</span>, echo=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">Base = declarative_base()    <span class="comment">#生成orm基类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'student'</span>    <span class="comment">#指定表名</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">100</span>))</span><br><span class="line">    age = Column(Integer)</span><br><span class="line">    address = Column(String(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">Base.metadata.create_all(engine)    <span class="comment">#创建表结构</span></span><br></pre></td></tr></table></figure></li></ul><p>方法2<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Table, MetaData, Column, Integer, String, create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> mapper</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:123456@localhost/test"</span>, encoding=<span class="string">'UTF-8'</span>, echo=<span class="keyword">True</span>)</span><br><span class="line">metadata = MetaData()</span><br><span class="line"></span><br><span class="line">student = Table(<span class="string">'student'</span>, metadata,</span><br><span class="line">             Column(<span class="string">'id'</span>, Integer, primary_key=<span class="keyword">True</span>),</span><br><span class="line">             Column(<span class="string">'name'</span>, String(<span class="number">100</span>)),</span><br><span class="line">             Column(<span class="string">'age'</span>, Integer),</span><br><span class="line">             Column(<span class="string">'address'</span>, String(<span class="number">100</span>))</span><br><span class="line">             )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, address)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.address = address</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mapper(Student, student)    <span class="comment">#此处有问题，待解决</span></span><br></pre></td></tr></table></figure></p><p>说明<br><code>echo=True</code> 显示每条执行的SQL语句，可以关闭。<br><code>create_engine()</code>返回一个Engine的实例，并且表示通过数据库语法处理细节的核心接口，这种情况下数据库语法将被解释成python的类方法。<br>上面简单示例对比了下使用SQL直接创建表和使用ORM框架建表的区别，下面开始介绍<code>SQLAlchemy</code>的使用。  </p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>通过<code>pip install SQLAlchemy</code>安装，访问mysql使用<code>pymysql</code>，安装方法<code>pip install pumysql</code>。可以参照<a href="https://rosinelan.coding.me/2018/05/06/python%E8%AE%BF%E9%97%AEmysql/" target="_blank" rel="noopener">python访问mysql</a>。  </p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine, Column, String, Integer, MetaData</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">"mysql+pymysql://root:123456@localhost/test"</span>, encoding=<span class="string">'UTF-8'</span>, echo=<span class="keyword">True</span>)</span><br><span class="line">DBsession = sessionmaker(bind=engine) <span class="comment">#创建与数据库的会话session class ,注意,这里返回给session的是个class,不是实例</span></span><br><span class="line">session = DBsession()    <span class="comment">#生成session实例</span></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'student'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">100</span>))</span><br><span class="line">    age = Column(Integer)</span><br><span class="line">    address = Column(String(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">student1 = Student(id=<span class="number">1001</span>, name=<span class="string">'Alice'</span>, age=<span class="number">25</span>, address=<span class="string">"anhui"</span>)</span><br><span class="line">student2 = Student(id=<span class="number">1002</span>, name=<span class="string">'Bob'</span>, age=<span class="number">69</span>, address=<span class="string">"beijing"</span>)</span><br><span class="line">student3 = Student(id=<span class="number">1003</span>, name=<span class="string">'Cerry'</span>, age=<span class="number">14</span>, address=<span class="string">"jiangsu"</span>)</span><br><span class="line"></span><br><span class="line">session.add_all([student1, student2, student3])</span><br><span class="line">session.commit()</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>查询是通过Session的<code>query()</code>方法创建一个查询对象，这个函数的参数可以是任何类或者类的描述的集合。<br>查询出来的数据是一个对象，直接通过对象的属性调用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> db.orm2 <span class="keyword">import</span> Student</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">'mysql+pymysql://root:123456@localhost/test'</span>)</span><br><span class="line">DBsession = sessionmaker(bind=engine)</span><br><span class="line">session = DBsession()</span><br><span class="line"></span><br><span class="line">a = session.query(Student)</span><br><span class="line">print(a)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i.id, i.name, i.age, i.address)</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT student.id AS student_id, student.name AS student_name, student.age AS student_age, student.address AS student_address </span><br><span class="line">FROM student</span><br><span class="line"><span class="number">1001</span> Alice <span class="number">25</span> anhui</span><br><span class="line"><span class="number">1002</span> Bob <span class="number">69</span> beijing</span><br><span class="line"><span class="number">1003</span> Cerry <span class="number">14</span> jiangsu</span><br></pre></td></tr></table></figure></p><p><code>session.query(Student)</code>结果为查询的SQL语句，若出现查询结果错误可以通过查看SQL确认。  </p><ul><li>filter()和filter_by()<br>过滤条件。<code>==</code>、<code>!=</code>、<code>like</code>等过滤操作都可以在filter函数中使用。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> db.orm2 <span class="keyword">import</span> Student</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">'mysql+pymysql://root:123456@localhost/test'</span>)</span><br><span class="line">DBsession = sessionmaker(bind=engine)</span><br><span class="line">session = DBsession()</span><br><span class="line"></span><br><span class="line">a = session.query(Student).filter(Student.id == <span class="number">1001</span>)</span><br><span class="line">b = session.query(Student).filter_by(id=<span class="number">1001</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">    print(x.id, x.name, x.age, x.address)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    print(i.id, i.name, i.age, i.address)</span><br></pre></td></tr></table></figure></li></ul><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1001</span> Alice <span class="number">25</span> anhui</span><br><span class="line"><span class="number">1001</span> Alice <span class="number">25</span> anhui</span><br></pre></td></tr></table></figure></p><p><code>filter()</code>和<code>filter_by()</code>区别<br>filter可以像写sql的where条件那样写&gt;、&lt;等条件，但引用列名时，需要通过<code>类名.属性名</code>的方式。<br>filter_by可以使用python的正常参数传递方法传递条件，指定列名时，不需要额外指定类名，参数名对应类中的属性名，不能使用&gt;、&lt;等条件。<br>当使用filter的时候条件之间是使用<code>==</code>，filter_by使用的是<code>=</code>。<br>filter不支持组合查询，只能连续调用filter变相实现。filter_by的参数是**kwargs，直接支持组合查询。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filters = &#123;<span class="string">'id'</span>:<span class="number">1002</span>, <span class="string">'name'</span>:<span class="string">'Bob'</span>&#125;</span><br><span class="line">b = session.query(Student).filter_by(**filters)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    print(i.id, i.name, i.age, i.address)</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1002</span> Bob <span class="number">69</span> beijing</span><br></pre></td></tr></table></figure></p><ul><li>all()<br>返回一个列表，可以通过遍历列表获取每个对象。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = session.query(Student).filter(Student.id &gt; <span class="number">1001</span>).all()</span><br><span class="line">print(a)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">    print(x.id, x.name, x.age, x.address)</span><br></pre></td></tr></table></figure></li></ul><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&lt;db.orm2.Student object at <span class="number">0x00000197ECC759E8</span>&gt;, &lt;db.orm2.Student object at <span class="number">0x00000197ECC75A58</span>&gt;]</span><br><span class="line"><span class="number">1002</span> Bob <span class="number">69</span> beijing</span><br><span class="line"><span class="number">1003</span> Cerry <span class="number">14</span> jiangsu</span><br></pre></td></tr></table></figure></p><ul><li>one()<br>返回且仅返回一个查询结果。当结果数量不足或者多于一个时会报错。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = session.query(Student).filter(Student.id == <span class="number">1001</span>).one()</span><br><span class="line">print(a)</span><br><span class="line">print(a.id, a.name, a.age, a.address)</span><br></pre></td></tr></table></figure></li></ul><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;db.orm2.Student object at <span class="number">0x000001B7C57E7908</span>&gt;</span><br><span class="line"><span class="number">1001</span> Alice <span class="number">25</span> anhui</span><br></pre></td></tr></table></figure></p><ul><li>first()<br>返回至多一个结果，而且以单项形式，而不是只有一个元素的tuple形式返回。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = session.query(Student).filter(Student.id &gt; <span class="number">1001</span>).first()</span><br><span class="line">print(a)</span><br><span class="line">print(a.id, a.name, a.age, a.address)</span><br></pre></td></tr></table></figure></li></ul><p>输出结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;db.orm2.Student object at <span class="number">0x000001C63E536B00</span>&gt;</span><br><span class="line"><span class="number">1002</span> Bob <span class="number">69</span> beijing</span><br></pre></td></tr></table></figure></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>MetaData类<br>主要用于保存表结构，连接字符串等数据，是一个多表共享的对象。<br><code>metadata = MetaData(engine)</code>绑定一个数据源的metadata。<br><code>metadata.create_all(engine)</code> 创建表，该操作会先判断表是否存在，若存在则不创建。  </li><li>Table类<br>构造函数为<code>Table.__init__(self, name, metadata,*args, **kwargs)</code><br>name  表名<br>metadata 共享的元数据<br><em>args中<code>Column</code>是列定义<br>下面是可变参数`*</em>kwargs`定义<br>schema 此表的结构名称，默认None<br>autoload 自动从现有表中读入表结构，默认False<br>autoload_with 从其他engine读取结构，默认None<br>include_columns 如果autoload设置为True，则此项数组中的列明将被引用，没有写的列明将被忽略，None表示所有都列明都引用，默认None<br>mustexist 如果为True，表示这个表必须在其他的python应用中定义，必须是metadata的一部分，默认False<br>useexisting 如果为True，表示这个表必须被其他应用定义过，将忽略结构定义，默认False<br>owner 表所有者，用于Orcal，默认None<br>quote 设置为True，如果表明是SQL关键字，将强制转义，默认False<br>quote_schema  设置为True，如果列明是SQL关键字，将强制转义，默认False<br>mysql_engine  mysql专用，可以设置’InnoDB’或’MyISAM’</li><li>Column类<br>构造函数为<code>Column.__init__(self,  name,  type_,  *args,  **kwargs)</code><br>name 列名<br>type_ 类型，更多类型sqlalchemy.types<br>下面是<code>*args</code>参数定义<br>Constraint（约束）<br>ForeignKey（外键）<br>ColumnDefault（默认）<br>Sequenceobjects（序列）定义<br>key 列名的别名，默认None<br>下面是<code>**kwargs</code>参数定义<br>primary_key 如果为True，则是主键<br>nullable 是否可为Null，默认是True<br>default 默认值，默认是None<br>index 是否是索引，默认是True<br>unique 是否唯一键，默认是False<br>onupdate 指定一个更新时候的值，这个操作是定义在SQLAlchemy中，不是在数据库里的，当更新一条数据时设置，大部分用于updateTime这类字段<br>autoincrement 设置为整型自动增长，只有没有默认值，并且是Integer类型，默认是True<br>quote 如果列明是关键字，则强制转义，默认False</li><li>创建会话<br>Session的主要目的是建立与数据库的会话，它维护你加载和关联的所有数据库对象。它是数据库查询（Query）的一个入口。<br>在<code>SQLAlchemy</code>中，数据库的查询操作是通过Query对象来实现的,而Session提供了创建Query对象的接口。Query对象返回的结果是一组同一映射（Identity Map）对象组成的集合。事实上，集合中的一个对象，对应于数据库表中的一行（即一条记录）。所谓同一映射，是指每个对象有一个唯一的ID。如果两个对象（的引用）ID相同，则认为它们对应的是相同的对象。<br>要完成数据库查询，就需要建立与数据库的连接。这就需要用到Engine对象。一个Engine可能是关联一个Session对象，也可能关联一个数据库表。<br>当然Session最重要的功能还是实现原子操作。<br>ORM通过session与数据库建立连接进行通信，如下所示<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line">DBSession = sessionmaker(bind=engine)</span><br><span class="line">session = DBSession()</span><br></pre></td></tr></table></figure></li></ol><p>通过sessionmake方法创建一个Session工厂，然后在调用工厂的方法来实例化一个Session对象。</p><p>要了解更多关于<code>SQLAlchemy</code>内容可以点击<a href="http://docs.sqlalchemy.org/en/latest/dialects/index.html" target="_blank" rel="noopener">SQLAlchemy Documentation</a>查看官方介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念简介&quot;&gt;&lt;a href=&quot;#概念简介&quot; class=&quot;headerlink&quot; title=&quot;概念简介&quot;&gt;&lt;/a&gt;概念简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ORM&lt;br&gt;&lt;code&gt;ORM&lt;/code&gt;是Object-Relational Mapping的简写。今天学习的&lt;code&gt;SQLAlchemy&lt;/code&gt;其实就是ORM框架中最有名的一个。&lt;br&gt;&lt;code&gt;SQLAlchemy&lt;/code&gt;框架工作&lt;br&gt;通过数据的API，使用关系对象映射进行数据库操作，也就是：将对象转换成SQL，然后使用数据API执行SQL并获取执行结果。
    
    </summary>
    
      <category term="编程" scheme="https://rosinelan.github.io/categories/program/"/>
    
      <category term="python" scheme="https://rosinelan.github.io/categories/program/python/"/>
    
    
      <category term="ORM" scheme="https://rosinelan.github.io/tags/ORM/"/>
    
      <category term="SQLAIchemy" scheme="https://rosinelan.github.io/tags/SQLAIchemy/"/>
    
  </entry>
  
</feed>
